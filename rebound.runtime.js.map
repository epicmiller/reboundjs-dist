{"version":3,"sources":["rebound.shims.js","node_modules/browserify/node_modules/browser-pack/_prelude.js","dist/cjs/property-compiler/property-compiler.js","dist/cjs/rebound-component/component.js","dist/cjs/rebound-component/factory.js","dist/cjs/rebound-data/collection.js","dist/cjs/rebound-data/computed-property.js","dist/cjs/rebound-data/model.js","dist/cjs/rebound-data/rebound-data.js","dist/cjs/rebound-htmlbars/helpers.js","dist/cjs/rebound-htmlbars/hooks.js","dist/cjs/rebound-htmlbars/hooks/attribute.js","dist/cjs/rebound-htmlbars/hooks/bindScope.js","dist/cjs/rebound-htmlbars/hooks/cleanupRenderNode.js","dist/cjs/rebound-htmlbars/hooks/component.js","dist/cjs/rebound-htmlbars/hooks/concat.js","dist/cjs/rebound-htmlbars/hooks/content.js","dist/cjs/rebound-htmlbars/hooks/createChildEnv.js","dist/cjs/rebound-htmlbars/hooks/createChildScope.js","dist/cjs/rebound-htmlbars/hooks/createFreshEnv.js","dist/cjs/rebound-htmlbars/hooks/createFreshScope.js","dist/cjs/rebound-htmlbars/hooks/destroyRenderNode.js","dist/cjs/rebound-htmlbars/hooks/didCleanupTree.js","dist/cjs/rebound-htmlbars/hooks/get.js","dist/cjs/rebound-htmlbars/hooks/getValue.js","dist/cjs/rebound-htmlbars/hooks/invokeHelper.js","dist/cjs/rebound-htmlbars/hooks/linkRenderNode.js","dist/cjs/rebound-htmlbars/hooks/partial.js","dist/cjs/rebound-htmlbars/hooks/subexpr.js","dist/cjs/rebound-htmlbars/hooks/willCleanupTree.js","dist/cjs/rebound-htmlbars/lazy-value.js","dist/cjs/rebound-htmlbars/rebound-htmlbars.js","dist/cjs/rebound-htmlbars/render.js","dist/cjs/rebound-router/loader.js","dist/cjs/rebound-router/rebound-router.js","dist/cjs/rebound-router/service.js","dist/cjs/rebound-utils/ajax.js","dist/cjs/rebound-utils/events.js","dist/cjs/rebound-utils/rebound-utils.js","dist/cjs/rebound-utils/urls.js","dist/cjs/runtime.js","node_modules/acorn/dist/acorn.js","node_modules/backbone/backbone.js","node_modules/backbone/node_modules/underscore/underscore.js","node_modules/browserify/lib/_empty.js","node_modules/htmlbars/dist/cjs/dom-helper.js","node_modules/htmlbars/dist/cjs/dom-helper/dom-helper/build-html-dom.js","node_modules/htmlbars/dist/cjs/dom-helper/dom-helper/classes.js","node_modules/htmlbars/dist/cjs/dom-helper/dom-helper/prop.js","node_modules/htmlbars/dist/cjs/htmlbars-runtime/htmlbars-runtime/expression-visitor.js","node_modules/htmlbars/dist/cjs/htmlbars-runtime/htmlbars-runtime/hooks.js","node_modules/htmlbars/dist/cjs/htmlbars-runtime/htmlbars-runtime/morph.js","node_modules/htmlbars/dist/cjs/htmlbars-runtime/htmlbars-runtime/node-visitor.js","node_modules/htmlbars/dist/cjs/htmlbars-runtime/htmlbars-runtime/render.js","node_modules/htmlbars/dist/cjs/htmlbars-util.js","node_modules/htmlbars/dist/cjs/htmlbars-util/htmlbars-util/array-utils.js","node_modules/htmlbars/dist/cjs/htmlbars-util/handlebars/htmlbars-util/handlebars/safe-string.js","node_modules/htmlbars/dist/cjs/htmlbars-util/handlebars/htmlbars-util/handlebars/utils.js","node_modules/htmlbars/dist/cjs/htmlbars-util/htmlbars-util/morph-utils.js","node_modules/htmlbars/dist/cjs/htmlbars-util/htmlbars-util/namespaces.js","node_modules/htmlbars/dist/cjs/htmlbars-util/htmlbars-util/object-utils.js","node_modules/htmlbars/dist/cjs/htmlbars-util/htmlbars-util/safe-string.js","node_modules/htmlbars/dist/cjs/htmlbars-util/htmlbars-util/template-utils.js","node_modules/htmlbars/dist/cjs/htmlbars-util/htmlbars-util/void-tag-names.js","node_modules/htmlbars/dist/cjs/morph-attr.js","node_modules/htmlbars/dist/cjs/morph-attr/morph-attr/sanitize-attribute-value.js","node_modules/htmlbars/dist/cjs/morph-range.js","node_modules/htmlbars/dist/cjs/morph-range/morph-range/morph-list.js","node_modules/htmlbars/dist/cjs/morph-range/morph-range/utils.js","node_modules/qs/lib/index.js","node_modules/qs/lib/parse.js","node_modules/qs/lib/stringify.js","node_modules/qs/lib/utils.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACv6CA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3wGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACt2DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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WAAW,CAAC,IAAI,CAAC,CAAC;AAC7B,QAAI,IAAI,KAAK,QAAQ,EAAE;AACrB,YAAM;KACP;AACD,QAAI,GAAG,QAAQ,CAAC;GACjB,QAAQ,IAAI,EAAE;CAChB;;AAEM,SAAS,YAAY,CAAC,UAAU,EAAE,SAAS,EAAE,QAAQ,EAAE,OAAO,EAAE;AACrE,MAAI,IAAI,GAAG,SAAS,CAAC;AACrB,MAAI,QAAQ,CAAC;AACb,KAAG;AACD,YAAQ,GAAG,IAAI,CAAC,WAAW,CAAC;AAC5B,cAAU,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;AACvC,QAAI,IAAI,KAAK,QAAQ,EAAE;AACrB,YAAM;KACP;AACD,QAAI,GAAG,QAAQ,CAAC;GACjB,QAAQ,IAAI,EAAE;CAChB;;;AC3BD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"rebound.runtime.js","sourcesContent":["// Console-polyfill. MIT license.\n// https://github.com/paulmillr/console-polyfill\n// Make it safe to do console.log() always.\n(function(global) {\n  'use strict';\n  global.console = global.console || {};\n  var con = global.console;\n  var prop, method;\n  var empty = {};\n  var dummy = function() {};\n  var properties = 'memory'.split(',');\n  var methods = ('assert,clear,count,debug,dir,dirxml,error,exception,group,' +\n     'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' +\n     'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(',');\n  while (prop = properties.pop()) if (!con[prop]) con[prop] = empty;\n  while (method = methods.pop()) if (!con[method]) con[method] = dummy;\n})(typeof window === 'undefined' ? this : window);\n// Using `this` for web workers while maintaining compatibility with browser\n// targeted script loaders such as Browserify or Webpack where the only way to\n// get to the global object is via `window`.\n\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Mller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n(function() {\n    var lastTime = 0;\n    var vendors = ['ms', 'moz', 'webkit', 'o'];\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] \n                                   || window[vendors[x]+'CancelRequestAnimationFrame'];\n    }\n \n    if (!window.requestAnimationFrame)\n        window.requestAnimationFrame = function(callback, element) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, \n              timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n \n    if (!window.cancelAnimationFrame)\n        window.cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n}());\n// document.currentScript polyfill by Adam Miller\n\n// MIT license\n\n(function(document){\n  var currentScript = \"currentScript\",\n      scripts = document.getElementsByTagName('script'); // Live NodeList collection\n\n  // If browser needs currentScript polyfill, add get currentScript() to the document object\n  if (!(currentScript in document)) {\n    Object.defineProperty(document, currentScript, {\n      get: function(){\n\n        // IE 6-10 supports script readyState\n        // IE 10+ support stack trace\n        try { throw new Error(); }\n        catch (err) {\n\n          // Find the second match for the \"at\" string to get file src url from stack.\n          // Specifically works with the format of stack traces in IE.\n          var i, res = ((/.*at [^\\(]*\\((.*):.+:.+\\)$/ig).exec(err.stack) || [false])[1];\n\n          // For all scripts on the page, if src matches or if ready state is interactive, return the script tag\n          for(i in scripts){\n            if(scripts[i].src == res || scripts[i].readyState == \"interactive\"){\n              return scripts[i];\n            }\n          }\n\n          // If no match, return null\n          return null;\n        }\n      }\n    });\n  }\n})(document);\n\n/*\n * classList.js: Cross-browser full element.classList implementation.\n * 1.1.20150312\n *\n * By Eli Grey, http://eligrey.com\n * License: Dedicated to the public domain.\n *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md\n */\n\n/*global self, document, DOMException */\n\n/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */\n\nif (\"document\" in self) {\n\n// Full polyfill for browsers with no classList support\n// Including IE < Edge missing SVGElement.classList\nif (!(\"classList\" in document.createElement(\"_\")) \n\t|| document.createElementNS && !(\"classList\" in document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\"))) {\n\n(function (view) {\n\n\"use strict\";\n\nif (!('Element' in view)) return;\n\nvar\n\t  classListProp = \"classList\"\n\t, protoProp = \"prototype\"\n\t, elemCtrProto = view.Element[protoProp]\n\t, objCtr = Object\n\t, strTrim = String[protoProp].trim || function () {\n\t\treturn this.replace(/^\\s+|\\s+$/g, \"\");\n\t}\n\t, arrIndexOf = Array[protoProp].indexOf || function (item) {\n\t\tvar\n\t\t\t  i = 0\n\t\t\t, len = this.length\n\t\t;\n\t\tfor (; i < len; i++) {\n\t\t\tif (i in this && this[i] === item) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t// Vendors: please allow content code to instantiate DOMExceptions\n\t, DOMEx = function (type, message) {\n\t\tthis.name = type;\n\t\tthis.code = DOMException[type];\n\t\tthis.message = message;\n\t}\n\t, checkTokenAndGetIndex = function (classList, token) {\n\t\tif (token === \"\") {\n\t\t\tthrow new DOMEx(\n\t\t\t\t  \"SYNTAX_ERR\"\n\t\t\t\t, \"An invalid or illegal string was specified\"\n\t\t\t);\n\t\t}\n\t\tif (/\\s/.test(token)) {\n\t\t\tthrow new DOMEx(\n\t\t\t\t  \"INVALID_CHARACTER_ERR\"\n\t\t\t\t, \"String contains an invalid character\"\n\t\t\t);\n\t\t}\n\t\treturn arrIndexOf.call(classList, token);\n\t}\n\t, ClassList = function (elem) {\n\t\tvar\n\t\t\t  trimmedClasses = strTrim.call(elem.getAttribute(\"class\") || \"\")\n\t\t\t, classes = trimmedClasses ? trimmedClasses.split(/\\s+/) : []\n\t\t\t, i = 0\n\t\t\t, len = classes.length\n\t\t;\n\t\tfor (; i < len; i++) {\n\t\t\tthis.push(classes[i]);\n\t\t}\n\t\tthis._updateClassName = function () {\n\t\t\telem.setAttribute(\"class\", this.toString());\n\t\t};\n\t}\n\t, classListProto = ClassList[protoProp] = []\n\t, classListGetter = function () {\n\t\treturn new ClassList(this);\n\t}\n;\n// Most DOMException implementations don't allow calling DOMException's toString()\n// on non-DOMExceptions. Error's toString() is sufficient here.\nDOMEx[protoProp] = Error[protoProp];\nclassListProto.item = function (i) {\n\treturn this[i] || null;\n};\nclassListProto.contains = function (token) {\n\ttoken += \"\";\n\treturn checkTokenAndGetIndex(this, token) !== -1;\n};\nclassListProto.add = function () {\n\tvar\n\t\t  tokens = arguments\n\t\t, i = 0\n\t\t, l = tokens.length\n\t\t, token\n\t\t, updated = false\n\t;\n\tdo {\n\t\ttoken = tokens[i] + \"\";\n\t\tif (checkTokenAndGetIndex(this, token) === -1) {\n\t\t\tthis.push(token);\n\t\t\tupdated = true;\n\t\t}\n\t}\n\twhile (++i < l);\n\n\tif (updated) {\n\t\tthis._updateClassName();\n\t}\n};\nclassListProto.remove = function () {\n\tvar\n\t\t  tokens = arguments\n\t\t, i = 0\n\t\t, l = tokens.length\n\t\t, token\n\t\t, updated = false\n\t\t, index\n\t;\n\tdo {\n\t\ttoken = tokens[i] + \"\";\n\t\tindex = checkTokenAndGetIndex(this, token);\n\t\twhile (index !== -1) {\n\t\t\tthis.splice(index, 1);\n\t\t\tupdated = true;\n\t\t\tindex = checkTokenAndGetIndex(this, token);\n\t\t}\n\t}\n\twhile (++i < l);\n\n\tif (updated) {\n\t\tthis._updateClassName();\n\t}\n};\nclassListProto.toggle = function (token, force) {\n\ttoken += \"\";\n\n\tvar\n\t\t  result = this.contains(token)\n\t\t, method = result ?\n\t\t\tforce !== true && \"remove\"\n\t\t:\n\t\t\tforce !== false && \"add\"\n\t;\n\n\tif (method) {\n\t\tthis[method](token);\n\t}\n\n\tif (force === true || force === false) {\n\t\treturn force;\n\t} else {\n\t\treturn !result;\n\t}\n};\nclassListProto.toString = function () {\n\treturn this.join(\" \");\n};\n\nif (objCtr.defineProperty) {\n\tvar classListPropDesc = {\n\t\t  get: classListGetter\n\t\t, enumerable: true\n\t\t, configurable: true\n\t};\n\ttry {\n\t\tobjCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n\t} catch (ex) { // IE 8 doesn't support enumerable:true\n\t\tif (ex.number === -0x7FF5EC54) {\n\t\t\tclassListPropDesc.enumerable = false;\n\t\t\tobjCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n\t\t}\n\t}\n} else if (objCtr[protoProp].__defineGetter__) {\n\telemCtrProto.__defineGetter__(classListProp, classListGetter);\n}\n\n}(self));\n\n} else {\n// There is full or partial native classList support, so just check if we need\n// to normalize the add/remove and toggle APIs.\n\n(function () {\n\t\"use strict\";\n\n\tvar testElement = document.createElement(\"_\");\n\n\ttestElement.classList.add(\"c1\", \"c2\");\n\n\t// Polyfill for IE 10/11 and Firefox <26, where classList.add and\n\t// classList.remove exist but support only one argument at a time.\n\tif (!testElement.classList.contains(\"c2\")) {\n\t\tvar createMethod = function(method) {\n\t\t\tvar original = DOMTokenList.prototype[method];\n\n\t\t\tDOMTokenList.prototype[method] = function(token) {\n\t\t\t\tvar i, len = arguments.length;\n\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\ttoken = arguments[i];\n\t\t\t\t\toriginal.call(this, token);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\tcreateMethod('add');\n\t\tcreateMethod('remove');\n\t}\n\n\ttestElement.classList.toggle(\"c3\", false);\n\n\t// Polyfill for IE 10 and Firefox <24, where classList.toggle does not\n\t// support the second argument.\n\tif (testElement.classList.contains(\"c3\")) {\n\t\tvar _toggle = DOMTokenList.prototype.toggle;\n\n\t\tDOMTokenList.prototype.toggle = function(token, force) {\n\t\t\tif (1 in arguments && !this.contains(token) === !force) {\n\t\t\t\treturn force;\n\t\t\t} else {\n\t\t\t\treturn _toggle.call(this, token);\n\t\t\t}\n\t\t};\n\n\t}\n\n\ttestElement = null;\n}());\n\n}\n\n}\n\n\nthis.Element && function(ElementPrototype) {\n\tElementPrototype.matchesSelector = ElementPrototype.matchesSelector || \n\tElementPrototype.mozMatchesSelector ||\n\tElementPrototype.msMatchesSelector ||\n\tElementPrototype.oMatchesSelector ||\n\tElementPrototype.webkitMatchesSelector ||\n\tfunction (selector) {\n\t\tvar node = this, nodes = (node.parentNode || node.document).querySelectorAll(selector), i = -1;\n\n\t\twhile (nodes[++i] && nodes[i] != node);\n\n\t\treturn !!nodes[i];\n\t}\n}(Element.prototype);\n/*!\nCopyright (C) 2014-2015 by WebReflection\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n(function(window, document, Object, REGISTER_ELEMENT){'use strict';\n\n// in case it's there or already patched\nif (REGISTER_ELEMENT in document) return;\n\n// DO NOT USE THIS FILE DIRECTLY, IT WON'T WORK\n// THIS IS A PROJECT BASED ON A BUILD SYSTEM\n// THIS FILE IS JUST WRAPPED UP RESULTING IN\n// build/document-register-element.js\n// and its .max.js counter part\n\nvar\n  // IE < 11 only + old WebKit for attributes + feature detection\n  EXPANDO_UID = '__' + REGISTER_ELEMENT + (Math.random() * 10e4 >> 0),\n\n  // shortcuts and costants\n  ATTACHED = 'attached',\n  DETACHED = 'detached',\n  EXTENDS = 'extends',\n  ADDITION = 'ADDITION',\n  MODIFICATION = 'MODIFICATION',\n  REMOVAL = 'REMOVAL',\n  DOM_ATTR_MODIFIED = 'DOMAttrModified',\n  DOM_CONTENT_LOADED = 'DOMContentLoaded',\n  DOM_SUBTREE_MODIFIED = 'DOMSubtreeModified',\n  PREFIX_TAG = '<',\n  PREFIX_IS = '=',\n\n  // valid and invalid node names\n  validName = /^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,\n  invalidNames = [\n    'ANNOTATION-XML',\n    'COLOR-PROFILE',\n    'FONT-FACE',\n    'FONT-FACE-SRC',\n    'FONT-FACE-URI',\n    'FONT-FACE-FORMAT',\n    'FONT-FACE-NAME',\n    'MISSING-GLYPH'\n  ],\n\n  // registered types and their prototypes\n  types = [],\n  protos = [],\n\n  // to query subnodes\n  query = '',\n\n  // html shortcut used to feature detect\n  documentElement = document.documentElement,\n\n  // ES5 inline helpers || basic patches\n  indexOf = types.indexOf || function (v) {\n    for(var i = this.length; i-- && this[i] !== v;){}\n    return i;\n  },\n\n  // other helpers / shortcuts\n  OP = Object.prototype,\n  hOP = OP.hasOwnProperty,\n  iPO = OP.isPrototypeOf,\n\n  defineProperty = Object.defineProperty,\n  gOPD = Object.getOwnPropertyDescriptor,\n  gOPN = Object.getOwnPropertyNames,\n  gPO = Object.getPrototypeOf,\n  sPO = Object.setPrototypeOf,\n\n  // jshint proto: true\n  hasProto = !!Object.__proto__,\n\n  // used to create unique instances\n  create = Object.create || function Bridge(proto) {\n    // silly broken polyfill probably ever used but short enough to work\n    return proto ? ((Bridge.prototype = proto), new Bridge()) : this;\n  },\n\n  // will set the prototype if possible\n  // or copy over all properties\n  setPrototype = sPO || (\n    hasProto ?\n      function (o, p) {\n        o.__proto__ = p;\n        return o;\n      } : (\n    (gOPN && gOPD) ?\n      (function(){\n        function setProperties(o, p) {\n          for (var\n            key,\n            names = gOPN(p),\n            i = 0, length = names.length;\n            i < length; i++\n          ) {\n            key = names[i];\n            if (!hOP.call(o, key)) {\n              defineProperty(o, key, gOPD(p, key));\n            }\n          }\n        }\n        return function (o, p) {\n          do {\n            setProperties(o, p);\n          } while ((p = gPO(p)) && !iPO.call(p, o));\n          return o;\n        };\n      }()) :\n      function (o, p) {\n        for (var key in p) {\n          o[key] = p[key];\n        }\n        return o;\n      }\n  )),\n\n  // DOM shortcuts and helpers, if any\n\n  MutationObserver = window.MutationObserver ||\n                     window.WebKitMutationObserver,\n\n  HTMLElementPrototype = (\n    window.HTMLElement ||\n    window.Element ||\n    window.Node\n  ).prototype,\n\n  IE8 = !iPO.call(HTMLElementPrototype, documentElement),\n\n  isValidNode = IE8 ?\n    function (node) {\n      return node.nodeType === 1;\n    } :\n    function (node) {\n      return iPO.call(HTMLElementPrototype, node);\n    },\n\n  targets = IE8 && [],\n\n  cloneNode = HTMLElementPrototype.cloneNode,\n  setAttribute = HTMLElementPrototype.setAttribute,\n  removeAttribute = HTMLElementPrototype.removeAttribute,\n\n  // replaced later on\n  createElement = document.createElement,\n\n  // shared observer for all attributes\n  attributesObserver = MutationObserver && {\n    attributes: true,\n    characterData: true,\n    attributeOldValue: true\n  },\n\n  // useful to detect only if there's no MutationObserver\n  DOMAttrModified = MutationObserver || function(e) {\n    doesNotSupportDOMAttrModified = false;\n    documentElement.removeEventListener(\n      DOM_ATTR_MODIFIED,\n      DOMAttrModified\n    );\n  },\n\n  // will both be used to make DOMNodeInserted asynchronous\n  asapQueue,\n  rAF = window.requestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        window.mozRequestAnimationFrame ||\n        window.msRequestAnimationFrame ||\n        function (fn) { setTimeout(fn, 10); },\n\n  // internal flags\n  setListener = false,\n  doesNotSupportDOMAttrModified = true,\n  dropDomContentLoaded = true,\n\n  // needed for the innerHTML helper\n  notFromInnerHTMLHelper = true,\n\n  // optionally defined later on\n  onSubtreeModified,\n  callDOMAttrModified,\n  getAttributesMirror,\n  observer,\n\n  // based on setting prototype capability\n  // will check proto or the expando attribute\n  // in order to setup the node once\n  patchIfNotAlready,\n  patch\n;\n\nif (sPO || hasProto) {\n    patchIfNotAlready = function (node, proto) {\n      if (!iPO.call(proto, node)) {\n        setupNode(node, proto);\n      }\n    };\n    patch = setupNode;\n} else {\n    patchIfNotAlready = function (node, proto) {\n      if (!node[EXPANDO_UID]) {\n        node[EXPANDO_UID] = Object(true);\n        setupNode(node, proto);\n      }\n    };\n    patch = patchIfNotAlready;\n}\nif (IE8) {\n  doesNotSupportDOMAttrModified = false;\n  (function (){\n    var\n      descriptor = gOPD(HTMLElementPrototype, 'addEventListener'),\n      addEventListener = descriptor.value,\n      patchedRemoveAttribute = function (name) {\n        var e = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true});\n        e.attrName = name;\n        e.prevValue = this.getAttribute(name);\n        e.newValue = null;\n        e[REMOVAL] = e.attrChange = 2;\n        removeAttribute.call(this, name);\n        this.dispatchEvent(e);\n      },\n      patchedSetAttribute = function (name, value) {\n        var\n          had = this.hasAttribute(name),\n          old = had && this.getAttribute(name),\n          e = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true})\n        ;\n        setAttribute.call(this, name, value);\n        e.attrName = name;\n        e.prevValue = had ? old : null;\n        e.newValue = value;\n        if (had) {\n          e[MODIFICATION] = e.attrChange = 1;\n        } else {\n          e[ADDITION] = e.attrChange = 0;\n        }\n        this.dispatchEvent(e);\n      },\n      onPropertyChange = function (e) {\n        // jshint eqnull:true\n        var\n          node = e.currentTarget,\n          superSecret = node[EXPANDO_UID],\n          propertyName = e.propertyName,\n          event\n        ;\n        if (superSecret.hasOwnProperty(propertyName)) {\n          superSecret = superSecret[propertyName];\n          event = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true});\n          event.attrName = superSecret.name;\n          event.prevValue = superSecret.value || null;\n          event.newValue = (superSecret.value = node[propertyName] || null);\n          if (event.prevValue == null) {\n            event[ADDITION] = event.attrChange = 0;\n          } else {\n            event[MODIFICATION] = event.attrChange = 1;\n          }\n          node.dispatchEvent(event);\n        }\n      }\n    ;\n    descriptor.value = function (type, handler, capture) {\n      if (\n        type === DOM_ATTR_MODIFIED &&\n        this.attributeChangedCallback &&\n        this.setAttribute !== patchedSetAttribute\n      ) {\n        this[EXPANDO_UID] = {\n          className: {\n            name: 'class',\n            value: this.className\n          }\n        };\n        this.setAttribute = patchedSetAttribute;\n        this.removeAttribute = patchedRemoveAttribute;\n        addEventListener.call(this, 'propertychange', onPropertyChange);\n      }\n      addEventListener.call(this, type, handler, capture);\n    };\n    defineProperty(HTMLElementPrototype, 'addEventListener', descriptor);\n  }());\n} else if (!MutationObserver) {\n  documentElement.addEventListener(DOM_ATTR_MODIFIED, DOMAttrModified);\n  documentElement.setAttribute(EXPANDO_UID, 1);\n  documentElement.removeAttribute(EXPANDO_UID);\n  if (doesNotSupportDOMAttrModified) {\n    onSubtreeModified = function (e) {\n      var\n        node = this,\n        oldAttributes,\n        newAttributes,\n        key\n      ;\n      if (node === e.target) {\n        oldAttributes = node[EXPANDO_UID];\n        node[EXPANDO_UID] = (newAttributes = getAttributesMirror(node));\n        for (key in newAttributes) {\n          if (!(key in oldAttributes)) {\n            // attribute was added\n            return callDOMAttrModified(\n              0,\n              node,\n              key,\n              oldAttributes[key],\n              newAttributes[key],\n              ADDITION\n            );\n          } else if (newAttributes[key] !== oldAttributes[key]) {\n            // attribute was changed\n            return callDOMAttrModified(\n              1,\n              node,\n              key,\n              oldAttributes[key],\n              newAttributes[key],\n              MODIFICATION\n            );\n          }\n        }\n        // checking if it has been removed\n        for (key in oldAttributes) {\n          if (!(key in newAttributes)) {\n            // attribute removed\n            return callDOMAttrModified(\n              2,\n              node,\n              key,\n              oldAttributes[key],\n              newAttributes[key],\n              REMOVAL\n            );\n          }\n        }\n      }\n    };\n    callDOMAttrModified = function (\n      attrChange,\n      currentTarget,\n      attrName,\n      prevValue,\n      newValue,\n      action\n    ) {\n      var e = {\n        attrChange: attrChange,\n        currentTarget: currentTarget,\n        attrName: attrName,\n        prevValue: prevValue,\n        newValue: newValue\n      };\n      e[action] = attrChange;\n      onDOMAttrModified(e);\n    };\n    getAttributesMirror = function (node) {\n      for (var\n        attr, name,\n        result = {},\n        attributes = node.attributes,\n        i = 0, length = attributes.length;\n        i < length; i++\n      ) {\n        attr = attributes[i];\n        name = attr.name;\n        if (name !== 'setAttribute') {\n          result[name] = attr.value;\n        }\n      }\n      return result;\n    };\n  }\n}\n\nfunction loopAndVerify(list, action) {\n  for (var i = 0, length = list.length; i < length; i++) {\n    verifyAndSetupAndAction(list[i], action);\n  }\n}\n\nfunction loopAndSetup(list) {\n  for (var i = 0, length = list.length, node; i < length; i++) {\n    node = list[i];\n    patch(node, protos[getTypeIndex(node)]);\n  }\n}\n\nfunction executeAction(action) {\n  return function (node) {\n    if (isValidNode(node)) {\n      verifyAndSetupAndAction(node, action);\n      loopAndVerify(\n        node.querySelectorAll(query),\n        action\n      );\n    }\n  };\n}\n\nfunction getTypeIndex(target) {\n  var\n    is = target.getAttribute('is'),\n    nodeName = target.nodeName.toUpperCase(),\n    i = indexOf.call(\n      types,\n      is ?\n          PREFIX_IS + is.toUpperCase() :\n          PREFIX_TAG + nodeName\n    )\n  ;\n  return is && -1 < i && !isInQSA(nodeName, is) ? -1 : i;\n}\n\nfunction isInQSA(name, type) {\n  return -1 < query.indexOf(name + '[is=\"' + type + '\"]');\n}\n\nfunction onDOMAttrModified(e) {\n  var\n    node = e.currentTarget,\n    attrChange = e.attrChange,\n    attrName = e.attrName,\n    target = e.target\n  ;\n  if (notFromInnerHTMLHelper &&\n      (!target || target === node) &&\n      node.attributeChangedCallback &&\n      attrName !== 'style' &&\n      e.prevValue !== e.newValue) {\n    node.attributeChangedCallback(\n      attrName,\n      attrChange === e[ADDITION] ? null : e.prevValue,\n      attrChange === e[REMOVAL] ? null : e.newValue\n    );\n  }\n}\n\nfunction onDOMNode(action) {\n  var executor = executeAction(action);\n  return function (e) {\n    asapQueue.push(executor, e.target);\n  };\n}\n\nfunction onReadyStateChange(e) {\n  if (dropDomContentLoaded) {\n    dropDomContentLoaded = false;\n    e.currentTarget.removeEventListener(DOM_CONTENT_LOADED, onReadyStateChange);\n  }\n  loopAndVerify(\n    (e.target || document).querySelectorAll(query),\n    e.detail === DETACHED ? DETACHED : ATTACHED\n  );\n  if (IE8) purge();\n}\n\nfunction patchedSetAttribute(name, value) {\n  // jshint validthis:true\n  var self = this;\n  setAttribute.call(self, name, value);\n  onSubtreeModified.call(self, {target: self});\n}\n\nfunction setupNode(node, proto) {\n  setPrototype(node, proto);\n  if (observer) {\n    observer.observe(node, attributesObserver);\n  } else {\n    if (doesNotSupportDOMAttrModified) {\n      node.setAttribute = patchedSetAttribute;\n      node[EXPANDO_UID] = getAttributesMirror(node);\n      node.addEventListener(DOM_SUBTREE_MODIFIED, onSubtreeModified);\n    }\n    node.addEventListener(DOM_ATTR_MODIFIED, onDOMAttrModified);\n  }\n  if (node.createdCallback && notFromInnerHTMLHelper) {\n    node.created = true;\n    node.createdCallback();\n    node.created = false;\n  }\n}\n\nfunction purge() {\n  for (var\n    node,\n    i = 0,\n    length = targets.length;\n    i < length; i++\n  ) {\n    node = targets[i];\n    if (!documentElement.contains(node)) {\n      length--;\n      targets.splice(i--, 1);\n      verifyAndSetupAndAction(node, DETACHED);\n    }\n  }\n}\n\nfunction throwTypeError(type) {\n  throw new Error('A ' + type + ' type is already registered');\n}\n\nfunction verifyAndSetupAndAction(node, action) {\n  var\n    fn,\n    i = getTypeIndex(node)\n  ;\n  if (-1 < i) {\n    patchIfNotAlready(node, protos[i]);\n    i = 0;\n    if (action === ATTACHED && !node[ATTACHED]) {\n      node[DETACHED] = false;\n      node[ATTACHED] = true;\n      i = 1;\n      if (IE8 && indexOf.call(targets, node) < 0) {\n        targets.push(node);\n      }\n    } else if (action === DETACHED && !node[DETACHED]) {\n      node[ATTACHED] = false;\n      node[DETACHED] = true;\n      i = 1;\n    }\n    if (i && (fn = node[action + 'Callback'])) fn.call(node);\n  }\n}\n\n// set as enumerable, writable and configurable\ndocument[REGISTER_ELEMENT] = function registerElement(type, options) {\n  upperType = type.toUpperCase();\n  if (!setListener) {\n    // only first time document.registerElement is used\n    // we need to set this listener\n    // setting it by default might slow down for no reason\n    setListener = true;\n    if (MutationObserver) {\n      observer = (function(attached, detached){\n        function checkEmAll(list, callback) {\n          for (var i = 0, length = list.length; i < length; callback(list[i++])){}\n        }\n        return new MutationObserver(function (records) {\n          for (var\n            current, node, newValue,\n            i = 0, length = records.length; i < length; i++\n          ) {\n            current = records[i];\n            if (current.type === 'childList') {\n              checkEmAll(current.addedNodes, attached);\n              checkEmAll(current.removedNodes, detached);\n            } else {\n              node = current.target;\n              if (notFromInnerHTMLHelper &&\n                  node.attributeChangedCallback &&\n                  current.attributeName !== 'style') {\n                newValue = node.getAttribute(current.attributeName);\n                if (newValue !== current.oldValue) {\n                  node.attributeChangedCallback(\n                    current.attributeName,\n                    current.oldValue,\n                    newValue\n                  );\n                }\n              }\n            }\n          }\n        });\n      }(executeAction(ATTACHED), executeAction(DETACHED)));\n      observer.observe(\n        document,\n        {\n          childList: true,\n          subtree: true\n        }\n      );\n    } else {\n      asapQueue = [];\n      rAF(function ASAP() {\n        while (asapQueue.length) {\n          asapQueue.shift().call(\n            null, asapQueue.shift()\n          );\n        }\n        rAF(ASAP);\n      });\n      document.addEventListener('DOMNodeInserted', onDOMNode(ATTACHED));\n      document.addEventListener('DOMNodeRemoved', onDOMNode(DETACHED));\n    }\n\n    document.addEventListener(DOM_CONTENT_LOADED, onReadyStateChange);\n    document.addEventListener('readystatechange', onReadyStateChange);\n\n    document.createElement = function (localName, typeExtension) {\n      var\n        node = createElement.apply(document, arguments),\n        name = '' + localName,\n        i = indexOf.call(\n          types,\n          (typeExtension ? PREFIX_IS : PREFIX_TAG) +\n          (typeExtension || name).toUpperCase()\n        ),\n        setup = -1 < i\n      ;\n      if (typeExtension) {\n        node.setAttribute('is', typeExtension = typeExtension.toLowerCase());\n        if (setup) {\n          setup = isInQSA(name.toUpperCase(), typeExtension);\n        }\n      }\n      notFromInnerHTMLHelper = !document.createElement.innerHTMLHelper;\n      if (setup) patch(node, protos[i]);\n      return node;\n    };\n\n    HTMLElementPrototype.cloneNode = function (deep) {\n      var\n        node = cloneNode.call(this, !!deep),\n        i = getTypeIndex(node)\n      ;\n      if (-1 < i) patch(node, protos[i]);\n      if (deep) loopAndSetup(node.querySelectorAll(query));\n      return node;\n    };\n  }\n\n  if (-2 < (\n    indexOf.call(types, PREFIX_IS + upperType) +\n    indexOf.call(types, PREFIX_TAG + upperType)\n  )) {\n    throwTypeError(type);\n  }\n\n  if (!validName.test(upperType) || -1 < indexOf.call(invalidNames, upperType)) {\n    throw new Error('The type ' + type + ' is invalid');\n  }\n\n  var\n    constructor = function () {\n      return extending ?\n        document.createElement(nodeName, upperType) :\n        document.createElement(nodeName);\n    },\n    opt = options || OP,\n    extending = hOP.call(opt, EXTENDS),\n    nodeName = extending ? options[EXTENDS].toUpperCase() : upperType,\n    upperType,\n    i\n  ;\n\n  if (extending && -1 < (\n    indexOf.call(types, PREFIX_TAG + nodeName)\n  )) {\n    throwTypeError(nodeName);\n  }\n\n  i = types.push((extending ? PREFIX_IS : PREFIX_TAG) + upperType) - 1;\n\n  query = query.concat(\n    query.length ? ',' : '',\n    extending ? nodeName + '[is=\"' + type.toLowerCase() + '\"]' : nodeName\n  );\n\n  constructor.prototype = (\n    protos[i] = hOP.call(opt, 'prototype') ?\n      opt.prototype :\n      create(HTMLElementPrototype)\n  );\n\n  loopAndVerify(\n    document.querySelectorAll(query),\n    ATTACHED\n  );\n\n  return constructor;\n};\n\n}(window, document, Object, 'registerElement'));\n(function (global, undefined) {\n    \"use strict\";\n\n    var tasks = (function () {\n        function Task(handler, args) {\n            this.handler = handler;\n            this.args = args;\n        }\n        Task.prototype.run = function () {\n            // See steps in section 5 of the spec.\n            if (typeof this.handler === \"function\") {\n                // Choice of `thisArg` is not in the setImmediate spec; `undefined` is in the setTimeout spec though:\n                // http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html\n                this.handler.apply(undefined, this.args);\n            } else {\n                var scriptSource = \"\" + this.handler;\n                /*jshint evil: true */\n                eval(scriptSource);\n            }\n        };\n\n        var nextHandle = 1; // Spec says greater than zero\n        var tasksByHandle = {};\n        var currentlyRunningATask = false;\n\n        return {\n            addFromSetImmediateArguments: function (args) {\n                var handler = args[0];\n                var argsToHandle = Array.prototype.slice.call(args, 1);\n                var task = new Task(handler, argsToHandle);\n\n                var thisHandle = nextHandle++;\n                tasksByHandle[thisHandle] = task;\n                return thisHandle;\n            },\n            runIfPresent: function (handle) {\n                // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n                // So if we're currently running a task, we'll need to delay this invocation.\n                if (!currentlyRunningATask) {\n                    var task = tasksByHandle[handle];\n                    if (task) {\n                        currentlyRunningATask = true;\n                        try {\n                            task.run();\n                        } finally {\n                            delete tasksByHandle[handle];\n                            currentlyRunningATask = false;\n                        }\n                    }\n                } else {\n                    // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n                    // \"too much recursion\" error.\n                    global.setTimeout(function () {\n                        tasks.runIfPresent(handle);\n                    }, 0);\n                }\n            },\n            remove: function (handle) {\n                delete tasksByHandle[handle];\n            }\n        };\n    }());\n\n    function canUseNextTick() {\n        // Don't get fooled by e.g. browserify environments.\n        return typeof process === \"object\" &&\n               Object.prototype.toString.call(process) === \"[object process]\";\n    }\n\n    function canUseMessageChannel() {\n        return !!global.MessageChannel;\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n\n        if (!global.postMessage || global.importScripts) {\n            return false;\n        }\n\n        var postMessageIsAsynchronous = true;\n        var oldOnMessage = global.onmessage;\n        global.onmessage = function () {\n            postMessageIsAsynchronous = false;\n        };\n        global.postMessage(\"\", \"*\");\n        global.onmessage = oldOnMessage;\n\n        return postMessageIsAsynchronous;\n    }\n\n    function canUseReadyStateChange() {\n        return \"document\" in global && \"onreadystatechange\" in global.document.createElement(\"script\");\n    }\n\n    function installNextTickImplementation(attachTo) {\n        attachTo.setImmediate = function () {\n            var handle = tasks.addFromSetImmediateArguments(arguments);\n\n            process.nextTick(function () {\n                tasks.runIfPresent(handle);\n            });\n\n            return handle;\n        };\n    }\n\n    function installMessageChannelImplementation(attachTo) {\n        var channel = new global.MessageChannel();\n        channel.port1.onmessage = function (event) {\n            var handle = event.data;\n            tasks.runIfPresent(handle);\n        };\n        attachTo.setImmediate = function () {\n            var handle = tasks.addFromSetImmediateArguments(arguments);\n\n            channel.port2.postMessage(handle);\n\n            return handle;\n        };\n    }\n\n    function installPostMessageImplementation(attachTo) {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var MESSAGE_PREFIX = \"com.bn.NobleJS.setImmediate\" + Math.random();\n\n        function isStringAndStartsWith(string, putativeStart) {\n            return typeof string === \"string\" && string.substring(0, putativeStart.length) === putativeStart;\n        }\n\n        function onGlobalMessage(event) {\n            // This will catch all incoming messages (even from other windows!), so we need to try reasonably hard to\n            // avoid letting anyone else trick us into firing off. We test the origin is still this window, and that a\n            // (randomly generated) unpredictable identifying prefix is present.\n            if (event.source === global && isStringAndStartsWith(event.data, MESSAGE_PREFIX)) {\n                var handle = event.data.substring(MESSAGE_PREFIX.length);\n                tasks.runIfPresent(handle);\n            }\n        }\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        attachTo.setImmediate = function () {\n            var handle = tasks.addFromSetImmediateArguments(arguments);\n\n            // Make `global` post a message to itself with the handle and identifying prefix, thus asynchronously\n            // invoking our onGlobalMessage listener above.\n            global.postMessage(MESSAGE_PREFIX + handle, \"*\");\n\n            return handle;\n        };\n    }\n\n    function installReadyStateChangeImplementation(attachTo) {\n        attachTo.setImmediate = function () {\n            var handle = tasks.addFromSetImmediateArguments(arguments);\n\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var scriptEl = global.document.createElement(\"script\");\n            scriptEl.onreadystatechange = function () {\n                tasks.runIfPresent(handle);\n\n                scriptEl.onreadystatechange = null;\n                scriptEl.parentNode.removeChild(scriptEl);\n                scriptEl = null;\n            };\n            global.document.documentElement.appendChild(scriptEl);\n\n            return handle;\n        };\n    }\n\n    function installSetTimeoutImplementation(attachTo) {\n        attachTo.setImmediate = function () {\n            var handle = tasks.addFromSetImmediateArguments(arguments);\n\n            global.setTimeout(function () {\n                tasks.runIfPresent(handle);\n            }, 0);\n\n            return handle;\n        };\n    }\n\n    if (!global.setImmediate) {\n        // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n        var attachTo = typeof Object.getPrototypeOf === \"function\" && \"setTimeout\" in Object.getPrototypeOf(global) ?\n                          Object.getPrototypeOf(global)\n                        : global;\n\n        if (canUseNextTick()) {\n            // For Node.js before 0.9\n            installNextTickImplementation(attachTo);\n        } else if (canUsePostMessage()) {\n            // For non-IE10 modern browsers\n            installPostMessageImplementation(attachTo);\n        } else if (canUseMessageChannel()) {\n            // For web workers, where supported\n            installMessageChannelImplementation(attachTo);\n        } else if (canUseReadyStateChange()) {\n            // For IE 68\n            installReadyStateChangeImplementation(attachTo);\n        } else {\n            // For older browsers\n            installSetTimeoutImplementation(attachTo);\n        }\n\n        attachTo.clearImmediate = tasks.remove;\n    }\n}(typeof global === \"object\" && global ? global : this));\n\n(function(root) {\n\n\t// Use polyfill for setImmediate for performance gains\n\tvar asap = (typeof setImmediate === 'function' && setImmediate) ||\n\t\tfunction(fn) { setTimeout(fn, 1); };\n\n\t// Polyfill for Function.prototype.bind\n\tfunction bind(fn, thisArg) {\n\t\treturn function() {\n\t\t\tfn.apply(thisArg, arguments);\n\t\t}\n\t}\n\n\tvar isArray = Array.isArray || function(value) { return Object.prototype.toString.call(value) === \"[object Array]\" };\n\n\tfunction Promise(fn) {\n\t\tif (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n\t\tif (typeof fn !== 'function') throw new TypeError('not a function');\n\t\tthis._state = null;\n\t\tthis._value = null;\n\t\tthis._deferreds = []\n\n\t\tdoResolve(fn, bind(resolve, this), bind(reject, this))\n\t}\n\n\tfunction handle(deferred) {\n\t\tvar me = this;\n\t\tif (this._state === null) {\n\t\t\tthis._deferreds.push(deferred);\n\t\t\treturn\n\t\t}\n\t\tasap(function() {\n\t\t\tvar cb = me._state ? deferred.onFulfilled : deferred.onRejected\n\t\t\tif (cb === null) {\n\t\t\t\t(me._state ? deferred.resolve : deferred.reject)(me._value);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar ret;\n\t\t\ttry {\n\t\t\t\tret = cb(me._value);\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tdeferred.reject(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdeferred.resolve(ret);\n\t\t})\n\t}\n\n\tfunction resolve(newValue) {\n\t\ttry { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n\t\t\tif (newValue === this) throw new TypeError('A promise cannot be resolved with itself.');\n\t\t\tif (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n\t\t\t\tvar then = newValue.then;\n\t\t\t\tif (typeof then === 'function') {\n\t\t\t\t\tdoResolve(bind(then, newValue), bind(resolve, this), bind(reject, this));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._state = true;\n\t\t\tthis._value = newValue;\n\t\t\tfinale.call(this);\n\t\t} catch (e) { reject.call(this, e); }\n\t}\n\n\tfunction reject(newValue) {\n\t\tthis._state = false;\n\t\tthis._value = newValue;\n\t\tfinale.call(this);\n\t}\n\n\tfunction finale() {\n\t\tfor (var i = 0, len = this._deferreds.length; i < len; i++) {\n\t\t\thandle.call(this, this._deferreds[i]);\n\t\t}\n\t\tthis._deferreds = null;\n\t}\n\n\tfunction Handler(onFulfilled, onRejected, resolve, reject){\n\t\tthis.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n\t\tthis.onRejected = typeof onRejected === 'function' ? onRejected : null;\n\t\tthis.resolve = resolve;\n\t\tthis.reject = reject;\n\t}\n\n\t/**\n\t * Take a potentially misbehaving resolver function and make sure\n\t * onFulfilled and onRejected are only called once.\n\t *\n\t * Makes no guarantees about asynchrony.\n\t */\n\tfunction doResolve(fn, onFulfilled, onRejected) {\n\t\tvar done = false;\n\t\ttry {\n\t\t\tfn(function (value) {\n\t\t\t\tif (done) return;\n\t\t\t\tdone = true;\n\t\t\t\tonFulfilled(value);\n\t\t\t}, function (reason) {\n\t\t\t\tif (done) return;\n\t\t\t\tdone = true;\n\t\t\t\tonRejected(reason);\n\t\t\t})\n\t\t} catch (ex) {\n\t\t\tif (done) return;\n\t\t\tdone = true;\n\t\t\tonRejected(ex);\n\t\t}\n\t}\n\n\tPromise.prototype['catch'] = function (onRejected) {\n\t\treturn this.then(null, onRejected);\n\t};\n\n\tPromise.prototype.then = function(onFulfilled, onRejected) {\n\t\tvar me = this;\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\thandle.call(me, new Handler(onFulfilled, onRejected, resolve, reject));\n\t\t})\n\t};\n\n\tPromise.all = function () {\n\t\tvar args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);\n\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tif (args.length === 0) return resolve([]);\n\t\t\tvar remaining = args.length;\n\t\t\tfunction res(i, val) {\n\t\t\t\ttry {\n\t\t\t\t\tif (val && (typeof val === 'object' || typeof val === 'function')) {\n\t\t\t\t\t\tvar then = val.then;\n\t\t\t\t\t\tif (typeof then === 'function') {\n\t\t\t\t\t\t\tthen.call(val, function (val) { res(i, val) }, reject);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\targs[i] = val;\n\t\t\t\t\tif (--remaining === 0) {\n\t\t\t\t\t\tresolve(args);\n\t\t\t\t\t}\n\t\t\t\t} catch (ex) {\n\t\t\t\t\treject(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\t\tres(i, args[i]);\n\t\t\t}\n\t\t});\n\t};\n\n\tPromise.resolve = function (value) {\n\t\tif (value && typeof value === 'object' && value.constructor === Promise) {\n\t\t\treturn value;\n\t\t}\n\n\t\treturn new Promise(function (resolve) {\n\t\t\tresolve(value);\n\t\t});\n\t};\n\n\tPromise.reject = function (value) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\treject(value);\n\t\t});\n\t};\n\n\tPromise.race = function (values) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tfor(var i = 0, len = values.length; i < len; i++) {\n\t\t\t\tvalues[i].then(resolve, reject);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Set the immediate function to execute callbacks\n\t * @param fn {function} Function to execute\n\t * @private\n\t */\n\tPromise._setImmediateFn = function _setImmediateFn(fn) {\n\t\tasap = fn;\n\t};\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = Promise;\n\t} else if (!root.Promise) {\n\t\troot.Promise = Promise;\n\t}\n\n})(this);","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _acorn = require('acorn');\n\nfunction tokenizer(input, options) {\n  return new _acorn.Parser(options, input);\n} // Property Compiler\n// ----------------\n\nvar TERMINATORS = [';', ',', '==', '>', '<', '>=', '<=', '>==', '<==', '!=', '!==', '===', '&&', '||', '+', '-', '/', '*', '{', '}'];\n\nfunction reduceMemos(memo, paths) {\n  var newMemo = [];\n  paths = !_.isArray(paths) ? [paths] : paths;\n  _.each(paths, function (path) {\n    _.each(memo, function (mem) {\n      newMemo.push(_.compact([mem, path]).join('.').replace('.[', '['));\n    });\n  });\n  return newMemo;\n}\n\n// TODO: Make this farrrrrr more robust...very minimal right now\n\nfunction compile(prop, name) {\n  var output = {};\n\n  if (prop.__params) return prop.__params;\n\n  var str = prop.toString(),\n      //.replace(/(?:\\/\\*(?:[\\s\\S]*?)\\*\\/)|(?:([\\s;])+\\/\\/(?:.*)$)/gm, '$1'), // String representation of function sans comments\n  token = tokenizer(str, {\n    ecmaVersion: 6,\n    sourceType: 'script'\n  }),\n      finishedPaths = [],\n      listening = 0,\n      paths = [],\n      attrs = [],\n      workingpath = [];\n\n  do {\n\n    // console.log(token.type.label, token.value);\n    token.nextToken();\n\n    if (token.value === 'this') {\n      listening++;\n      workingpath = [];\n    }\n\n    // TODO: handle gets on collections\n    if (token.value === 'get') {\n      token.nextToken();\n      while (_.isUndefined(token.value)) {\n        token.nextToken();\n      }\n      // Replace any access to a collection with the generic @each placeholder and push dependancy\n      workingpath.push(token.value.replace(/\\[.+\\]/g, \".@each\").replace(/^\\./, ''));\n    }\n\n    if (token.value === 'pluck') {\n      token.nextToken();\n      while (_.isUndefined(token.value)) {\n        token.nextToken();\n      }\n\n      workingpath.push('@each.' + token.value);\n    }\n\n    if (token.value === 'slice' || token.value === 'clone' || token.value === 'filter') {\n      token.nextToken();\n      if (token.type.label === '(') workingpath.push('@each');\n    }\n\n    if (token.value === 'at') {\n      token.nextToken();\n      while (_.isUndefined(token.value)) {\n        token.nextToken();\n      }\n      workingpath.push('@each');\n    }\n\n    if (token.value === 'where' || token.value === 'findWhere') {\n      workingpath.push('@each');\n      token.nextToken();\n      attrs = [];\n      var itr = 0;\n      while (token.type.label !== ')') {\n        if (token.value) {\n          if (itr % 2 === 0) {\n            attrs.push(token.value);\n          }\n          itr++;\n        }\n        token.nextToken();\n      }\n      workingpath.push(attrs);\n    }\n\n    if (listening && (_.indexOf(TERMINATORS, token.type.label) > -1 || _.indexOf(TERMINATORS, token.value) > -1)) {\n      workingpath = _.reduce(workingpath, reduceMemos, ['']);\n      finishedPaths = _.compact(_.union(finishedPaths, workingpath));\n      workingpath = [];\n      listening--;\n    }\n  } while (token.start !== token.end && token.type !== _acorn.tokTypes.eof);\n\n  // Save our finished paths directly on the function\n  prop.__params = finishedPaths;\n\n  // Return the dependancies list\n  return finishedPaths;\n}\n\nexports.default = { compile: compile };","\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }; // Rebound Component\n// ----------------\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _backbone = require(\"backbone\");\n\nvar _backbone2 = _interopRequireDefault(_backbone);\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _reboundData = require(\"rebound-data/rebound-data\");\n\nvar _render2 = require(\"rebound-htmlbars/render\");\n\nvar _render3 = _interopRequireDefault(_render2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// New Backbone Component\nvar Component = _reboundData.Model.extend({\n\n  isComponent: true,\n  isHydrated: true,\n  defaults: {},\n\n  constructor: function constructor(el, data, options) {\n\n    // Ensure options is an object\n    options || (options = {});\n\n    // Bind certian methods to ensure they are run in the context of our Component\n    _.bindAll(this, '_callOnComponent', '_listenToService');\n\n    // Set instance cid and caches for this Component\n    this.cid = _reboundUtils.$.uniqueId('component');\n    this.attributes = {};\n    this.changed = {};\n    this.consumers = [];\n    this.services = {};\n    this.loadCallbacks = [];\n    this.options = options;\n\n    // If we are told this is not a hydrated component, mark it as such\n    if (options.isHydrated === false) {\n      this.isHydrated = false;\n    }\n\n    // Components are always the top of their data tree. Set parent and root to itself.\n    this.__parent__ = this.__root__ = this;\n\n    // Take our parsed data and add it to our backbone data structure. Does a deep defaults set.\n    // In the model, primatives (arrays, objects, etc) are converted to Backbone Objects\n    // Functions are compiled to find their dependancies and added as computed properties\n    // Set our component's context with the passed data merged with the component's defaults\n    this.set(this.defaults || {});\n    this.set(data || {});\n\n    // Get any additional routes passed in from options\n    this.routes = _.defaults(options.routes || {}, this.routes);\n\n    // Ensure that all route functions exist\n    _.each(this.routes, function (value, key, routes) {\n      if (typeof value !== 'string') {\n        throw 'Function name passed to routes in  ' + this.tagName + ' component must be a string!';\n      }\n      if (!this[value]) {\n        throw 'Callback function ' + value + ' does not exist on the  ' + this.tagName + ' component!';\n      }\n    }, this);\n\n    // Set or create our element and template if we have them\n    this.el = el || document.createDocumentFragment();\n    this.$el = _.isFunction(_backbone2.default.$) ? _backbone2.default.$(this.el) : false;\n\n    // Render our dom and place the dom in our custom element\n    this.render();\n\n    // Add active class to this newly rendered template's link elements that require it\n    (0, _reboundUtils.$)(this.el).markLinks();\n\n    // Call user provided initialize\n    this.initialize();\n\n    return this;\n  },\n  _callOnComponent: function _callOnComponent(name, event) {\n    if (!_.isFunction(this[name])) {\n      throw \"ERROR: No method named \" + name + \" on component \" + this.tagName + \"!\";\n    }\n    return this[name].call(this, event);\n  },\n  _listenToService: function _listenToService(key, service) {\n    var _this = this;\n\n    var self = this;\n    this.listenTo(service, 'all', function (type, model, value) {\n      var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n      var attr,\n          path = model.__path(),\n          changed;\n\n      // Send the service's key via options\n      // TODO: Find a better way to get service keys in their path() method\n      options.service = key;\n\n      if (type.indexOf('change:') === 0) {\n        changed = model.changedAttributes();\n        for (attr in changed) {\n          // TODO: Modifying arguments array is bad. change this\n          type = 'change:' + key + '.' + path + (path && '.') + attr; // jshint ignore:line\n          _this.trigger.call(_this, type, model, value, options);\n        }\n        return void 0;\n      }\n\n      return _this.trigger.call(_this, type, model, value, options);\n    });\n  },\n\n  // Render our dom and place the dom in our custom element\n  // TODO: Check if template is a string, and if the compiler exists on the page, and compile if needed\n  render: function render() {\n    (0, _reboundUtils.$)(this.el).empty();\n    (0, _render3.default)(this.el, this[_reboundUtils.REBOUND_SYMBOL].template, this);\n  },\n  deinitialize: function deinitialize() {\n    var _this2 = this;\n\n    if (this.consumers.length) {\n      return void 0;\n    }\n    _.each(this.services, function (service, key) {\n      _.each(service.consumers, function (consumer, index) {\n        if (consumer.component === _this2) service.consumers.splice(index, 1);\n      });\n    });\n    delete this.services;\n    _reboundData.Model.prototype.deinitialize.apply(this, arguments);\n  },\n\n  // LazyComponents have an onLoad function that calls all the registered callbacks\n  // after it has been hydrated. If we are calling onLoad on an already loaded\n  // component, just call the callback provided.\n  onLoad: function onLoad(cb) {\n    if (!this.isHydrated) {\n      this.loadCallbacks.push(cb);\n    } else {\n      cb(this);\n    }\n  },\n\n  // Set is overridden on components to accept components as a valid input type.\n  // Components set on other Components are mixed in as a shared object. {raw: true}\n  // It also marks itself as a consumer of this component\n  set: function set(key, val, options) {\n    var attrs, attr, serviceOptions;\n    if ((typeof key === \"undefined\" ? \"undefined\" : _typeof(key)) === 'object') {\n      attrs = key.isModel ? key.attributes : key;\n      options = val;\n    } else (attrs = {})[key] = val;\n    options || (options = {});\n\n    // If reset option passed, do a reset. If nothing passed, return.\n    if (options.reset === true) return this.reset(attrs, options);\n    if (options.defaults === true) this.defaults = attrs;\n    if (_.isEmpty(attrs)) {\n      return void 0;\n    }\n\n    // For each attribute passed:\n    for (key in attrs) {\n      attr = attrs[key];\n      if (attr && attr.isComponent) {\n        if (attr.isLazyComponent && attr._component) {\n          attr = attr._component;\n        }\n        serviceOptions || (serviceOptions = _.defaults(_.clone(options), { raw: true }));\n        attr.consumers.push({ key: key, component: this });\n        this.services[key] = attr;\n        this._listenToService(key, attr);\n        _reboundData.Model.prototype.set.call(this, key, attr, serviceOptions);\n      }\n      _reboundData.Model.prototype.set.call(this, key, attr, options);\n    }\n\n    return this;\n  },\n  $: function $(selector) {\n    if (!this.$el) {\n      return console.error('No DOM manipulation library on the page!');\n    }\n    return this.$el.find(selector);\n  },\n\n  // Trigger all events on both the component and the element\n  trigger: function trigger(eventName) {\n    if (this.el) {\n      (0, _reboundUtils.$)(this.el).trigger(eventName, arguments);\n    }\n    _backbone2.default.Model.prototype.trigger.apply(this, arguments);\n  },\n  _onAttributeChange: function _onAttributeChange(attrName, oldVal, newVal) {\n    // Commented out because tracking attribute changes and making sure they dont infinite loop is hard.\n    // TODO: Make work.\n    // try{ newVal = JSON.parse(newVal); } catch (e){ newVal = newVal; }\n    //\n    // // data attributes should be referanced by their camel case name\n    // attrName = attrName.replace(/^data-/g, \"\").replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });\n    //\n    // oldVal = this.get(attrName);\n    //\n    // if(newVal === null){ this.unset(attrName); }\n    //\n    // // If oldVal is a number, and newVal is only numerical, preserve type\n    // if(_.isNumber(oldVal) && _.isString(newVal) && newVal.match(/^[0-9]*$/i)){\n    //   newVal = parseInt(newVal);\n    // }\n    //\n    // else{ this.set(attrName, newVal, {quiet: true}); }\n  }\n});\n\nfunction processProps(protoProps, staticProps) {\n\n  var reservedMethods = {\n    'trigger': 1, 'get': 1, 'set': 1, 'has': 1, 'escape': 1,\n    'unset': 1, 'clear': 1, 'cid': 1, 'attributes': 1, 'hasChanged': 1,\n    'changed': 1, 'toJSON': 1, 'isValid': 1, 'isNew': 1, 'validationError': 1,\n    'previous': 1, 'toggle': 1, 'previousAttributes': 1, 'changedAttributes': 1\n  },\n      configProperties = {\n    'id': 1, 'idAttribute': 1, 'url': 1, 'urlRoot': 1,\n    'routes': 1, 'createdCallback': 1, 'attachedCallback': 1, 'detachedCallback': 1,\n    'attributeChangedCallback': 1, 'defaults': 1\n  };\n\n  // These properties exist on all instances of the Component\n  protoProps || (protoProps = {});\n  protoProps.defaults = {};\n\n  // These properties exist on the custom Component constructor\n  // Ensure every constructor has a template and stylesheet\n  staticProps || (staticProps = {});\n  staticProps.template || (staticProps.template = null);\n  staticProps.stylesheet || (staticProps.stylesheet = '');\n\n  // Convert computed properties (getters and setters on this object) to Computed\n  // Property primitives\n  _reboundUtils.$.extractComputedProps(protoProps);\n\n  // For each property passed into our component base class determine if it is\n  // intended as a default value (move it into the defaults hash) or a component\n  // method (leave it alone).\n  for (var key in protoProps) {\n    var value = protoProps[key];\n\n    // If this isn't an actual property, keep going\n    if (!protoProps.hasOwnProperty(key)) {\n      continue;\n    }\n\n    // If this is a reserved property name, yell\n    if (reservedMethods[key]) {\n      throw \"ERROR: \" + key + \" is a reserved method name in \" + staticProps.type + \"!\";\n    }\n\n    // If a configuration property, or not actually on the obj, ignore it\n    if (!protoProps.hasOwnProperty(key) || configProperties[key]) {\n      continue;\n    }\n\n    // If a primative, backbone type object, or computed property, move it to our defaults\n    if (!_.isFunction(value) || value.isComputedProto || value.isModel || value.isComponent) {\n      protoProps.defaults[key] = value;\n      delete protoProps[key];\n    }\n\n    // All other values are component methods, leave them be.\n  }\n}\n\nComponent.hydrate = function hydrateComponent() {\n  var protoProps = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n  var staticProps = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  // If already hydrated, return.\n  if (this.isHydrated) {\n    return void 0;\n  }\n\n  // Process our new properties objects\n  processProps(protoProps, staticProps);\n\n  // Extend our prototype with any protoProps, overriting pre-defined ones\n  if (protoProps) {\n    _.extend(this.prototype, protoProps);\n  }\n\n  // Add any static props to the function object itself\n  if (staticProps) {\n    _.extend(this, staticProps);\n  }\n\n  // Ensure we have a type, template and stylesheet\n  this.prototype[_reboundUtils.REBOUND_SYMBOL] = {\n    type: staticProps.type || 'anonymous-component',\n    template: staticProps.template || null,\n    stylesheet: staticProps.stylesheet || '',\n    isHydrated: true\n  };\n};\n\nComponent.extend = function extendComponent() {\n  var protoProps = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n  var staticProps = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  var parent = this,\n\n  // Call our parent Component constructor and pass through the instance specific\n  // name, template and stylesheet via options if no other name, template or\n  // stylesheet is present.\n  Component = function Component(type) {\n    var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    return parent.call(this, type, data, options);\n  },\n\n  // Surrogate constructor allows us to inherit everything from the parent and\n  // retain a referance to our component specific constructor as `this.constructor`\n  // on component instances' prototype chains. This is also the object we augment\n  // with additional protoProps on component hydration if needed.\n  Surrogate = function Surrogate() {\n    this.constructor = Component;\n  };\n\n  // Our class should inherit everything from its parent, defined above\n  Surrogate.prototype = parent.prototype;\n  Component.prototype = new Surrogate();\n\n  // Set our ancestry\n  Component.__super__ = parent.prototype;\n\n  // Process our new properties objects\n  processProps(protoProps, staticProps);\n\n  // Extend our prototype with any remaining protoProps, overriting pre-defined ones\n  if (protoProps) {\n    _.extend(Component.prototype, protoProps);\n  }\n\n  // Add any static props to the function object itself\n  if (staticProps) {\n    _.extend(Component, parent, staticProps);\n  }\n\n  // Ensure we hae a type, template and stylesheet\n  Component.prototype[_reboundUtils.REBOUND_SYMBOL] = {\n    type: staticProps.type || 'anonymous-component',\n    template: staticProps.template || null,\n    stylesheet: staticProps.stylesheet || '',\n    isHydrated: staticProps.hasOwnProperty('isHydrated') ? staticProps.isHydrated : true\n  };\n\n  return Component;\n};\n\nexports.default = Component;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ComponentFactory = undefined;\nexports.registerComponent = registerComponent;\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _component = require(\"rebound-component/component\");\n\nvar _component2 = _interopRequireDefault(_component);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Rebound Component Factory\n// ----------------\n\nvar REGISTRY = {};\nvar DUMMY_TEMPLATE = false;\n\n// Used to transport component specific data to the native element created callback\n// in leu of a good API for passing initialization data to document.createElement.\n// When registry.create is called, it stashes instance data on this object in a\n// shared scope. After createElement is finished, it cleans this transport object\nvar ELEMENT_DATA;\n\nfunction registerComponent(type) {\n  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  // Ensure our options are set nicely and extract the prototype provided to us\n  var proto = options.prototype || {};\n  delete options.prototype;\n  options.type = type;\n  options.isHydrated = true;\n\n  // If the component exists in the registry, and is already hydrated, then this\n  // is a conflicting component name  exit and log an error.\n  if (REGISTRY[type] && REGISTRY[type].isHydrated) {\n    return console.error('A component of type', type, 'already exists!');\n  }\n\n  // If there is a non-hydrated component in the registry, hydrate it with the\n  // newly provided prototype.\n  if (REGISTRY[type]) {\n    REGISTRY[type].hydrate(proto, options);\n  }\n\n  // Otherwise, create and save a new component subclass and register the element\n  else {\n      REGISTRY[type] = _component2.default.extend(proto, options);\n    }\n\n  // Create our new element prototype object\n  var element = Object.create(HTMLElement.prototype, {});\n\n  // On element creation, make a new instance of the component and attach it\n  // to the element object as `data`\n  element.createdCallback = function () {\n    var _this = this;\n\n    // If `this.data` already exists on this element, then it was present on the\n    // page via a `new Component(component-name);` call before this component was\n    // actually registered. Now, we need to finish hydrating this instance of the\n    // component data object.\n    if (this.data) {\n\n      // Anything that is not already set on our component should be set to our\n      // new default if it exists\n      // TODO: If a default value perscribes a certain user-defined subclass\n      // of Component or Model for a property already passed into a component,\n      // the existing vanila Component or Model should be upgraded to that subclass\n      var current = this.data.toJSON();\n      var defaults = this.data.defaults;\n      for (var key in defaults) {\n        if (!current.hasOwnProperty(key) && defaults.hasOwnProperty(key)) {\n          this.data.set(key, defaults[key]);\n        }\n      }\n      this.data.render();\n      this.data.isHydrated = true;\n      this.data.loadCallbacks.forEach(function (cb) {\n        cb(_this.data);\n      });\n    }\n\n    // If we have element data, then we have come from a `new Component(component-name);`\n    // call and may have been provided data to initialize with. Call the component\n    // constructor with the provided properties. We don't need `new` here because\n    // the instance we are building is provided for us, so we use `component.call`\n    // to call the component constructor using that scope.\n    else if (ELEMENT_DATA) {\n        this.data = new REGISTRY[type](this, ELEMENT_DATA.data, ELEMENT_DATA.options);\n      }\n\n      // Otherwise, this is an upgraded instance of the element that was pre-existing\n      // in the dom, or just created using `document.createElement`. Go ahead and\n      // give it a new component object.\n      else {\n          this.data = new REGISTRY[type](this);\n        }\n\n    // Call user provided `attachedCallback`\n    _.isFunction(proto.createdCallback) && proto.createdCallback.call(this.data);\n  };\n\n  // Call user provided `attachedCallback`\n  element.attachedCallback = function () {\n    _.isFunction(proto.attachedCallback) && proto.attachedCallback.call(this.data);\n  };\n\n  // Call user provided `detachedCallback`\n  element.detachedCallback = function () {\n    _.isFunction(proto.detachedCallback) && proto.detachedCallback.call(this.data);\n  };\n\n  // Call user provided `attributeChangedCallback`\n  element.attributeChangedCallback = function (attrName, oldVal, newVal) {\n    this.data._onAttributeChange(attrName, oldVal, newVal);\n    _.isFunction(proto.attributeChangedCallback) && proto.attributeChangedCallback.call(this.data, attrName, oldVal, newVal);\n  };\n\n  // Register our new element\n  document.registerElement(type, { prototype: element });\n\n  // Return the new component constructor\n  return REGISTRY[type];\n}\n\nvar ComponentFactory = exports.ComponentFactory = function ComponentFactory(type) {\n  var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n  // If type is not a valid component name, error\n  if (typeof type !== 'string') {\n    return console.error('Invalid component type provided to createComponent. Instead received:', type);\n  }\n\n  var el;\n\n  // If this component is not in the registry, register a dehydrated component\n  // as a placeholder. Once the actual component is loaded, all running instances\n  // of this component type will be hydrated.\n  if (!REGISTRY[type] || !REGISTRY[type].isHydrated) {\n    el = document.createElement(type);\n    options.isHydrated = false;\n    REGISTRY[type] = REGISTRY[type] || _component2.default.extend({}, {\n      isHydrated: false,\n      type: type,\n      template: DUMMY_TEMPLATE\n    }, options);\n    el.data = new REGISTRY[type](el, data, options);\n  }\n\n  // If this component is in the registry, save the instance specific data to\n  // deliver to the createElement call, and create the element. As part of the\n  // `createdCallback` a new instance of\n  else {\n      ELEMENT_DATA = { data: data, options: options };\n      el = document.createElement(type);\n      ELEMENT_DATA = void 0;\n    }\n\n  return el.data;\n};\n\nComponentFactory.registerComponent = registerComponent;\n\nexports.default = ComponentFactory;","\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }; // Rebound Collection\n// ----------------\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _backbone = require(\"backbone\");\n\nvar _backbone2 = _interopRequireDefault(_backbone);\n\nvar _model = require(\"rebound-data/model\");\n\nvar _model2 = _interopRequireDefault(_model);\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _reboundUtils2 = _interopRequireDefault(_reboundUtils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction pathGenerator(collection) {\n  return function () {\n    return collection.__path() + '[' + collection.indexOf(collection._byId[this.cid]) + ']';\n  };\n}\n\nvar Collection = _backbone2.default.Collection.extend({\n\n  isCollection: true,\n  isData: true,\n\n  model: _model2.default,\n\n  __path: function __path() {\n    return '';\n  },\n\n  constructor: function constructor(models, options) {\n    models || (models = []);\n    options || (options = {});\n    this._byValue = {};\n    this.helpers = {};\n    this.cid = _reboundUtils2.default.uniqueId('collection');\n\n    // Set lineage\n    this.setParent(options.parent || this);\n    this.setRoot(options.root || this);\n    this.__path = options.path || this.__path;\n\n    _backbone2.default.Collection.apply(this, arguments);\n\n    // When a model is removed from its original collection, destroy it\n    // TODO: Fix this. Computed properties now somehow allow collection to share a model. They may be removed from one but not the other. That is bad.\n    // The clone = false options is the culprit. Find a better way to copy all of the collections custom attributes over to the clone.\n    this.on('remove', function (model, collection, options) {\n      // model.deinitialize();\n    });\n  },\n\n  get: function get(key, options) {\n    var _this = this;\n\n    // Split the path at all '.', '[' and ']' and find the value referanced.\n    var parts = _.isString(key) ? _reboundUtils2.default.splitPath(key) : [],\n        result = this,\n        l = parts.length,\n        i = 0;\n    options || (options = {});\n\n    // If the key is a number or object, or just a single string that is not a path,\n    // get by id and return the first occurance\n    if (typeof key == 'number' || (typeof key === \"undefined\" ? \"undefined\" : _typeof(key)) == 'object' || parts.length == 1 && !options.isPath) {\n      if (key === null) {\n        return void 0;\n      }\n      var id = this.modelId(this._isModel(key) ? key.attributes : key);\n      var responses = [].concat(this._byValue[key], this._byId[key] || this._byId[id] || this._byId[key.cid]);\n      var res = responses[0],\n          idx = Infinity;\n\n      responses.forEach(function (value) {\n        if (!value) {\n          return void 0;\n        }\n        var i = _.indexOf(_this.models, value);\n        if (i > -1 && i < idx) {\n          idx = i;res = value;\n        }\n      });\n\n      return res;\n    }\n\n    // If key is not a string, return undefined\n    if (!_.isString(key)) {\n      return void 0;\n    }\n\n    if (_.isUndefined(key) || _.isNull(key)) {\n      return key;\n    }\n    if (key === '' || parts.length === 0) {\n      return result;\n    }\n\n    if (parts.length > 0) {\n      for (i = 0; i < l; i++) {\n        // If returning raw, always return the first computed property found. If undefined, you're done.\n        if (result && result.isComputedProperty && options.raw) return result;\n        if (result && result.isComputedProperty) result = result.value();\n        if (_.isUndefined(result) || _.isNull(result)) return result;\n        if (parts[i] === '@parent') result = result.__parent__;else if (result.isCollection) result = result.models[parts[i]];else if (result.isModel) result = result.attributes[parts[i]];else if (result.hasOwnProperty(parts[i])) result = result[parts[i]];\n      }\n    }\n\n    if (result && result.isComputedProperty && !options.raw) result = result.value();\n\n    return result;\n  },\n\n  set: function set(models, options) {\n    var newModels = [],\n        parts = _.isString(models) ? _reboundUtils2.default.splitPath(models) : [],\n        res,\n        lineage = {\n      parent: this,\n      root: this.__root__,\n      path: pathGenerator(this),\n      silent: true\n    };\n    options = options || {},\n\n    // If no models passed, implies an empty array\n    models || (models = []);\n\n    // If models is a string, and it has parts, call set at that path\n    if (_.isString(models) && parts.length > 1 && !isNaN(Number(parts[0]))) {\n      var index = Number(parts[0]);\n      return this.at(index).set(parts.splice(1, parts.length).join('.'), options);\n    }\n\n    // If another collection, treat like an array\n    models = models.isCollection ? models.models : models;\n    // Ensure models is an array\n    models = !_.isArray(models) ? [models] : models;\n\n    // If the model already exists in this collection, or we are told not to clone it, let Backbone handle the merge\n    // Otherwise, create our copy of this model, give them the same cid so our helpers treat them as the same object\n    // Use the more unique of the two constructors. If our Model has a custom constructor, use that. Otherwise, use\n    // Collection default Model constructor.\n    _.each(models, function (data, index) {\n      if (data.isModel && options.clone === false || this._byId[data.cid]) return newModels[index] = data;\n      var constructor = data.constructor !== Object && data.constructor !== Rebound.Model ? data.constructor : this.model;\n      newModels[index] = new constructor(data, _.defaults(lineage, options));\n      data.isModel && (newModels[index].cid = data.cid);\n    }, this);\n\n    // Ensure that this element now knows that it has children now. Without this cyclic dependancies cause issues\n    this._hasAncestry || (this._hasAncestry = newModels.length > 0);\n\n    // Call original set function with model duplicates\n    return _backbone2.default.Collection.prototype.set.call(this, newModels, options);\n  }\n\n});\n\nexports.default = Collection;","\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }; // Rebound Computed Property\n// ----------------\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _backbone = require(\"backbone\");\n\nvar _backbone2 = _interopRequireDefault(_backbone);\n\nvar _propertyCompiler = require(\"property-compiler/property-compiler\");\n\nvar _propertyCompiler2 = _interopRequireDefault(_propertyCompiler);\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _reboundUtils2 = _interopRequireDefault(_reboundUtils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar NOOP = function NOOP() {\n  return void 0;\n};\n\nvar TO_CALL = [];\nvar CALL_TIMEOUT;\n\n// Returns true if str starts with test\nfunction startsWith(str, test) {\n  if (str === test) {\n    return true;\n  }\n  return str.substring(0, test.length + 1) === test + '.';\n}\n\n// Push all elements in `arr` to the end of an array. Mark all Computed Properties\n// as dirty on their way in.\nfunction push(arr) {\n  var i,\n      len = arr.length;\n  this.added || (this.added = {});\n  for (i = 0; i < len; i++) {\n    arr[i].markDirty();\n    if (this.added[arr[i].cid]) continue;\n    this.added[arr[i].cid] = 1;\n    this.push(arr[i]);\n  }\n}\n\n// Called after callstack is exausted to call all of this computed property's\n// dependants that need to be recomputed\nfunction recomputeCallback() {\n  var len = TO_CALL.length;\n  CALL_TIMEOUT = null;\n  while (len--) {\n    (TO_CALL.shift() || NOOP).call();\n  }\n\n  TO_CALL.added = {};\n}\n\nvar ComputedProperty = function ComputedProperty(getter, setter) {\n  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n  if (!_.isFunction(getter) && !_.isFunction(setter)) {\n    return console.error('ComputedProperty constructor must be passed getter and setter functions!', getter, 'and', setter, 'Found instead.');\n  }\n\n  this.cid = _reboundUtils2.default.uniqueId('computedPropety');\n  this.name = options.name;\n  this.returnType = null;\n  this.waiting = {};\n\n  this.isChanging = false;\n  this.isDirty = true;\n  _.bindAll(this, 'onModify', 'markDirty');\n\n  if (getter) {\n    this.getter = getter;\n  }\n  if (setter) {\n    this.setter = setter;\n  }\n  this.deps = _propertyCompiler2.default.compile(this.getter, this.name);\n\n  // Create lineage to pass to our cache objects\n  var lineage = {\n    parent: this.setParent(options.parent || this),\n    root: this.setRoot(options.root || options.parent || this),\n    path: this.__path = options.path || this.__path\n  };\n\n  // Results Cache Objects\n  // These data objects will never be re-created for the lifetime of the Computed Proeprty\n  // On Recompute they are updated with new values.\n  // On Change their new values are pushed to the object it is tracking\n  this.cache = {\n    model: new Rebound.Model({}, lineage),\n    collection: new Rebound.Collection([], lineage),\n    value: undefined\n  };\n\n  // Listen to objects in the cache and push changes to them on modify\n  this.listenTo(this.cache.model, 'all', this.onModify);\n  this.listenTo(this.cache.collection, 'all', this.onModify);\n\n  this.wire();\n};\n\n_.extend(ComputedProperty.prototype, _backbone2.default.Events, {\n\n  isComputedProperty: true,\n  isData: true,\n  __path: function __path() {\n    return '';\n  },\n\n  getter: NOOP,\n  setter: NOOP,\n\n  // If the Computed Property is not already dirty, mark it as such and trigger\n  // a `dirty` event.\n  markDirty: function markDirty() {\n    if (this.isDirty) {\n      return void 0;\n    }\n    this.isDirty = true;\n    this.trigger('dirty', this);\n  },\n\n  // Attached to listen to all events where this Computed Property's dependancies\n  // are stored. See wire(). Will re-evaluate any computed properties that\n  // depend on the changed data value which triggered this callback.\n  onRecompute: function onRecompute(type, model, collection, options) {\n    var shortcircuit = { change: 1, sort: 1, request: 1, destroy: 1, sync: 1, error: 1, invalid: 1, route: 1, dirty: 1 };\n    if (shortcircuit[type] || !model.isData) {\n      return void 0;\n    }\n    model || (model = {});\n    collection || (collection = {});\n    options || (options = {});\n    !collection.isData && (options = collection) && (collection = model);\n    var path, vector;\n\n    // Compute the path to this data object that triggered the event\n    // TODO: Figure out a better way to prefix service data paths with their local path name\n    vector = path = (options.service ? options.service + \".\" : '') + collection.__path().replace(/\\.?\\[.*\\]/ig, '.@each');\n\n    // If a reset event on a Model, check for computed properties that depend\n    // on each changed attribute's full path.\n    if (type === 'reset' && options.previousAttributes) {\n      _.each(options.previousAttributes, function (value, key) {\n        vector = path + (path && '.') + key;\n        _.each(this.__computedDeps, function (dependants, dependancy) {\n          startsWith(vector, dependancy) && push.call(TO_CALL, dependants);\n        }, this);\n      }, this);\n    }\n\n    // If a reset event on a Collction, check for computed properties that depend\n    // on anything inside that collection.\n    else if (type === 'reset' && options.previousModels) {\n        _.each(this.__computedDeps, function (dependants, dependancy) {\n          startsWith(dependancy, vector) && push.call(TO_CALL, dependants);\n        }, this);\n      }\n\n      // If an add or remove event, check for computed properties that depend on\n      // anything inside that collection or that contains that collection.\n      else if (type === 'add' || type === 'remove') {\n          _.each(this.__computedDeps, function (dependants, dependancy) {\n            if (startsWith(dependancy, vector) || startsWith(vector, dependancy)) push.call(TO_CALL, dependants);\n          }, this);\n        }\n\n        // If a change event, trigger anything that depends on that changed path.\n        else if (type.indexOf('change:') === 0) {\n            vector = type.replace('change:', '').replace(/\\.?\\[.*\\]/ig, '.@each');\n            _.each(this.__computedDeps, function (dependants, dependancy) {\n              startsWith(vector, dependancy) && push.call(TO_CALL, dependants);\n            }, this);\n          }\n\n    // Notifies all computed properties in the dependants array to recompute.\n    // Push all recomputes to the end of our stack trace so all Computed Properties\n    // already queued for recompute get a chance to.\n    if (!CALL_TIMEOUT) {\n      CALL_TIMEOUT = setTimeout(_.bind(recomputeCallback, this), 0);\n    }\n  },\n\n  // Called when a Computed Property's active cache object changes.\n  // Pushes any changes to Computed Property that returns a data object back to\n  // the original object.\n  // TODO: Will be a hair faster with individual callbacks for each event type\n  onModify: function onModify(type) {\n    var model = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n    var collection = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n    var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n    var shortcircuit = { sort: 1, request: 1, destroy: 1, sync: 1, error: 1, invalid: 1, route: 1 };\n    if (this.isChanging || !this.tracking || shortcircuit[type] || ~type.indexOf('change:')) {\n      return void 0;\n    }\n    !collection.isData && _.isObject(collection) && (options = collection) && (collection = model);\n\n    var path = collection.__path().replace(this.__path(), '').replace(/^\\./, '');\n\n    // Need to pass isPath: true here because when syncing across computed properties\n    // that return collections we may just be passing the model index for the path.\n    var dest = this.tracking.get(path, { raw: true, isPath: true });\n\n    if (_.isUndefined(dest)) {\n      return void 0;\n    }\n    if (type === 'change' && model.changedAttributes()) {\n      dest.set && dest.set(model.changedAttributes());\n    } else if (type === 'reset') {\n      dest.reset && dest.reset(model);\n    } else if (type === 'update') {\n      dest.set && dest.set(model);\n    } else if (type === 'add') {\n      dest.add && dest.add(model);\n    } else if (type === 'remove') {\n      dest.remove && dest.remove(model);\n    }\n    // TODO: Add sort\n  },\n\n  // Adds a litener to the root object and tells it what properties this\n  // Computed Property depend on.\n  // The listener will re-compute this Computed Property when any are changed.\n  wire: function wire() {\n    var root = this.__root__;\n    var context = this.__parent__;\n    root.__computedDeps || (root.__computedDeps = {});\n\n    _.each(this.deps, function (path) {\n\n      // For each dependancy, mark ourselves as dirty if they become dirty\n      var dep = root.get(path, { raw: true, isPath: true });\n      if (dep && dep.isComputedProperty) {\n        dep.on('dirty', this.markDirty);\n      }\n\n      // Find actual context and path from relative paths\n      var split = _reboundUtils2.default.splitPath(path);\n      while (split[0] === '@parent') {\n        context = context.__parent__;\n        split.shift();\n      }\n      path = context.__path().replace(/\\.?\\[.*\\]/ig, '.@each');\n      path = path + (path && '.') + split.join('.');\n\n      // Add ourselves as dependants\n      root.__computedDeps[path] || (root.__computedDeps[path] = []);\n      root.__computedDeps[path].push(this);\n    }, this);\n\n    // Ensure we only have one listener per Model at a time.\n    context.off('all', this.onRecompute).on('all', this.onRecompute);\n  },\n\n  unwire: function unwire() {\n    var root = this.__root__;\n    var context = this.__parent__;\n\n    _.each(this.deps, function (path) {\n      var dep = root.get(path, { raw: true, isPath: true });\n      if (!dep || !dep.isComputedProperty) {\n        return void 0;\n      }\n      dep.off('dirty', this.markDirty);\n    }, this);\n\n    context.off('all', this.onRecompute);\n  },\n\n  // Call this computed property like you would with Function.call()\n  call: function call() {\n    var args = Array.prototype.slice.call(arguments),\n        context = args.shift();\n    return this.apply(context, args);\n  },\n\n  // Call this computed property like you would with Function.apply()\n  // Only properties that are marked as dirty and are not already computing\n  // themselves are evaluated to prevent cyclic callbacks. If any dependants\n  // aren't finished computeding, we add ourselved to their waiting list.\n  // Vanilla objects returned from the function are promoted to Rebound Objects.\n  // Then, set the proper return type for future fetches from the cache and set\n  // the new computed value. Track changes to the cache to push it back up to\n  // the original object and return the value.\n  apply: function apply(context, params) {\n\n    context || (context = this.__parent__);\n\n    // Only re-evaluate this Computed Property if this value is dirty, not already\n    // evaluating, and part of a data tree.\n    if (!this.isDirty || this.isChanging || !context) {\n      return void 0;\n    }\n\n    // Mark this Computed Property as in the process of changing\n    this.isChanging = true;\n\n    // Check all of our dependancies to see if they are evaluating.\n    // If we have a dependancy that is dirty and this isnt its first run,\n    // Let this dependancy know that we are waiting for it.\n    // It will re-run this Computed Property after it finishes.\n    _.each(this.deps, function (dep) {\n      var dependancy = context.get(dep, { raw: true, isPath: true });\n      if (!dependancy || !dependancy.isComputedProperty) {\n        return void 0;\n      }\n      if (dependancy.isDirty && dependancy.returnType !== null) {\n        dependancy.waiting[this.cid] = this;\n        dependancy.apply(); // Try to re-evaluate this dependancy if it is dirty\n        if (dependancy.isDirty) {\n          return this.isChanging = false;\n        }\n      }\n      delete dependancy.waiting[this.cid];\n      // TODO: There can be a check here looking for cyclic dependancies.\n    }, this);\n\n    if (!this.isChanging) {\n      return void 0;\n    }\n\n    // Run our getter method to fetch the new result value and retreive current\n    // value from the cache\n    var result = this.getter.apply(context, params);\n    var value = this.cache[this.returnType];\n\n    // Promote vanilla objects to Rebound Data keeping the same original objects\n    if (_.isArray(result)) {\n      result = new Rebound.Collection(result, { clone: false });\n    } else if (_.isObject(result) && !result.isData) {\n      result = new Rebound.Model(result, { clone: false });\n    }\n\n    // If result is undefined, reset our cache item\n    if (_.isUndefined(result) || _.isNull(result)) {\n      this.returnType = 'value';\n      this.isCollection = this.isModel = false;\n      this.set(undefined);\n    }\n\n    // Set result and return types, bind events\n    // Use .set instead of .reset to trigger individual changes for internal models\n    else if (result.isCollection) {\n        this.returnType = 'collection';\n        this.isCollection = true;\n        this.isModel = false;\n        this.set(result);\n        this.track(result);\n      }\n\n      // If this is a model, set the return types and bind events.\n      // If this model is the same as a previus run, just apply the changes to it.\n      // If this is a different model, reset all of the values to the new ones.\n      else if (result.isModel) {\n          this.returnType = 'model';\n          this.isCollection = false;\n          this.isModel = true;\n          this.reset(result);\n          this.track(result);\n        }\n\n        // Otherwise, result is a primitive. Set values appropreately.\n        else {\n            this.returnType = 'value';\n            this.isCollection = this.isModel = false;\n            this.set(result);\n          }\n\n    return this.value();\n  },\n\n  // When we receive a new model to set in our cache, unbind the tracker from\n  // the previous cache object, sync the objects' cids so helpers think they\n  // are the same object, save a referance to the object we are tracking,\n  // and re-bind our onModify hook.\n  track: function track(object) {\n    var target = this.value();\n    if (!object || !target || !target.isData || !object.isData) {\n      return void 0;\n    }\n    target._cid || (target._cid = target.cid);\n    object._cid || (object._cid = object.cid);\n    target.cid = object.cid;\n    this.tracking = object;\n  },\n\n  // Get from the Computed Property's cache\n  get: function get(key) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    if (this.returnType === 'value') {\n      return console.error('Called get on the `' + this.name + '` computed property which returns a primitive value.');\n    }\n    return this.value().get(key, options);\n  },\n\n  // Set the Computed Property's cache to a new value and trigger appropreate events.\n  // Changes will propagate back to the original object if a Rebound Data Object and re-compute.\n  // If Computed Property returns a value, all downstream dependancies will re-compute.\n  set: function set(key, val) {\n    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    if (this.returnType === null) {\n      return void 0;\n    }\n    var attrs = key;\n    var value = this.value();\n\n    // Noralize the data passed in\n    if (this.returnType === 'model') {\n      if ((typeof key === \"undefined\" ? \"undefined\" : _typeof(key)) === 'object') {\n        attrs = key.isModel ? key.attributes : key;\n        options = val || {};\n      } else {\n        (attrs = {})[key] = val;\n      }\n    }\n    if (this.returnType !== 'model') {\n      options = val || {};\n    }\n    attrs = attrs && attrs.isComputedProperty ? attrs.value() : attrs;\n\n    // If a new value, set it and trigger events\n    this.setter && this.setter.call(this.__root__, attrs);\n\n    if (this.returnType === 'value' && this.cache.value !== attrs) {\n      this.cache.value = attrs;\n      if (!options.quiet) {\n        // If set was called not through computedProperty.call(), this is a fresh new event burst.\n        if (!this.isDirty && !this.isChanging) this.__parent__.changed = {};\n        this.__parent__.changed[this.name] = attrs;\n        this.trigger('change', this.__parent__);\n        this.trigger('change:' + this.name, this.__parent__, attrs);\n        delete this.__parent__.changed[this.name];\n      }\n    } else if (this.returnType !== 'value' && options.reset) {\n      key = value.reset(attrs, options);\n    } else if (this.returnType !== 'value') {\n      key = value.set(attrs, options);\n    }\n    this.isDirty = this.isChanging = false;\n\n    // Call all reamining computed properties waiting for this value to resolve.\n    _.each(this.waiting, function (prop) {\n      prop && prop.call();\n    });\n\n    return key;\n  },\n\n  // Return the current value from the cache, running if dirty.\n  value: function value() {\n    if (this.isDirty) {\n      this.apply();\n    }\n    return this.cache[this.returnType];\n  },\n\n  // Reset the current value in the cache, unless if first run.\n  reset: function reset(obj) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    if (_.isNull(this.returnType)) {\n      return void 0;\n    }\n    options.reset = true;\n    return this.set(obj, options);\n  },\n\n  // Cyclic dependancy safe toJSON method.\n  toJSON: function toJSON() {\n    if (this._isSerializing) {\n      return this.cid;\n    }\n    var val = this.value();\n    this._isSerializing = true;\n    var json = val && _.isFunction(val.toJSON) ? val.toJSON() : val;\n    this._isSerializing = false;\n    return json;\n  }\n\n});\n\nexports.default = ComputedProperty;","\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }; // Rebound Model\n// ----------------\n\n// Rebound **Models** are the basic data object in the framework - frequently\n// representing a row in a table in a database on your server. The inherit from\n// Backbone Models and have all of the same useful methods you are used to for\n// performing computations and transformations on that data. Rebound augments\n// Backbone Models by enabling deep data nesting. You can now have **Rebound Collections**\n// and **Rebound Computed Properties** as properties of the Model.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _backbone = require(\"backbone\");\n\nvar _backbone2 = _interopRequireDefault(_backbone);\n\nvar _computedProperty = require(\"rebound-data/computed-property\");\n\nvar _computedProperty2 = _interopRequireDefault(_computedProperty);\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _reboundUtils2 = _interopRequireDefault(_reboundUtils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Returns a function that, when called, generates a path constructed from its\n// parent's path and the key it is assigned to. Keeps us from re-naming children\n// when parents change.\nfunction pathGenerator(parent, key) {\n  return function () {\n    var path = parent.__path();\n    return path + (path === '' ? '' : '.') + key;\n  };\n}\n\nvar Model = _backbone2.default.Model.extend({\n  // Set this object's data types\n  isModel: true,\n  isData: true,\n\n  // A method that returns a root path by default. Meant to be overridden on\n  // instantiation.\n  __path: function __path() {\n    return '';\n  },\n\n  // Create a new Model with the specified attributes. The Model's lineage is set\n  // up here to keep track of it's place in the data tree.\n  constructor: function constructor(attributes) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    var self = this;\n    if (attributes === null || attributes === undefined) {\n      attributes = {};\n    }\n    attributes.isModel && (attributes = attributes.attributes);\n    this.helpers = {};\n    this.defaults = this.defaults || {};\n    this.setParent(options.parent || this);\n    this.setRoot(options.root || this);\n    this.__path = options.path || this.__path;\n\n    // Convert getters and setters to computed properties\n    _reboundUtils2.default.extractComputedProps(attributes);\n\n    _backbone2.default.Model.call(this, attributes, options);\n  },\n\n  // New convenience function to toggle boolean values in the Model.\n  toggle: function toggle(attr, options) {\n    options = options ? _.clone(options) : {};\n    var val = this.get(attr);\n    if (!_.isBoolean(val)) console.error('Tried to toggle non-boolean value ' + attr + '!', this);\n    return this.set(attr, !val, options);\n  },\n\n  destroy: function destroy(options) {\n    options = options ? _.clone(options) : {};\n    var model = this;\n    var success = options.success;\n    var wait = options.wait;\n\n    var destroy = function destroy() {\n      model.trigger('destroy', model, model.collection, options);\n    };\n\n    options.success = function (resp) {\n      if (wait) {\n        destroy();\n      }\n      if (success) {\n        success.call(options.context, model, resp, options);\n      }\n      if (!model.isNew()) {\n        model.trigger('sync', model, resp, options);\n      }\n    };\n\n    var xhr = false;\n    if (this.isNew()) {\n      _.defer(options.success);\n    } else {\n      wrapError(this, options);\n      xhr = this.sync('delete', this, options);\n    }\n    if (!wait) {\n      destroy();\n    }\n    return xhr;\n  },\n\n  // Model Reset does a deep reset on the data tree starting at this Model.\n  // A `previousAttributes` property is set on the `options` property with the Model's\n  // old values.\n  reset: function reset(obj, options) {\n    var changed = {},\n        key,\n        value;\n    options || (options = {});\n    options.reset = true;\n    obj = obj && obj.isModel && obj.attributes || obj || {};\n    options.previousAttributes = _.clone(this.attributes);\n\n    // Any unset previously existing values will be set back to default\n    _.each(this.defaults, function (val, key) {\n      if (!obj.hasOwnProperty(key)) {\n        obj[key] = val;\n      }\n    }, this);\n\n    // Iterate over the Model's attributes:\n    // - If the property is the `idAttribute`, skip.\n    // - If the properties are already the same, skip\n    // - If the property is currently undefined and being changed, assign\n    // - If the property is a `Model`, `Collection`, or `ComputedProperty`, reset it.\n    // - If the passed object has the property, set it to the new value.\n    // - If the Model has a default value for this property, set it back to default.\n    // - Otherwise, unset the attribute.\n    for (key in this.attributes) {\n      value = this.attributes[key];\n      if (value === obj[key]) {\n        continue;\n      } else if (_.isUndefined(value) && !_.isUndefined(obj[key])) {\n        changed[key] = obj[key];\n      } else if (value.isComponent) {\n        continue;\n      } else if (value.isCollection || value.isModel || value.isComputedProperty) {\n        value.reset(obj[key] || [], { silent: true });\n        if (value.isCollection) changed[key] = value.previousModels;else if (value.isModel && value.isComputedProperty) changed[key] = value.cache.model.changedAttributes();else if (value.isModel) changed[key] = value.changedAttributes();\n      } else if (obj.hasOwnProperty(key)) {\n        changed[key] = obj[key];\n      } else {\n        changed[key] = undefined;\n        this.unset(key, { silent: true });\n      }\n    }\n\n    // Any new values will be set to on the model\n    _.each(obj, function (val, key) {\n      if (_.isUndefined(changed[key])) {\n        changed[key] = val;\n      }\n    });\n\n    // Reset our model\n    obj = this.set(obj, _.extend({}, options, { silent: true, reset: false }));\n\n    // Trigger custom reset event\n    this.changed = changed;\n    if (!options.silent) {\n      this.trigger('reset', this, options);\n    }\n\n    // Return new values\n    return obj;\n  },\n\n  // **Model.Get** is overridden to provide support for getting from a deep data tree.\n  // `key` may now be any valid json-like identifier. Ex: `obj.coll[3].value`.\n  // It needs to traverse `Models`, `Collections` and `Computed Properties` to\n  // find the correct value.\n  // - If key is undefined, return `undefined`.\n  // - If key is empty string, return `this`.\n  //\n  // For each part:\n  // - If a `Computed Property` and `options.raw` is true, return it.\n  // - If a `Computed Property` traverse to its value.\n  // - If not set, return its falsy value.\n  // - If a `Model` or `Collection`, traverse to it.\n  get: function get(key, options) {\n    options || (options = {});\n    var parts = _reboundUtils2.default.splitPath(key),\n        result = this,\n        i,\n        l = parts.length;\n\n    if (_.isUndefined(key) || _.isNull(key)) {\n      return void 0;\n    }\n    if (key === '' || parts.length === 0) {\n      return result;\n    }\n\n    for (i = 0; i < l; i++) {\n      if (result && result.isComputedProperty && options.raw) return result;\n      if (result && result.isComputedProperty) result = result.value();\n      if (_.isUndefined(result) || _.isNull(result)) return result;\n      if (parts[i] === '@parent') result = result.__parent__;else if (result.isCollection) result = result.models[parts[i]];else if (result.isModel) result = result.attributes[parts[i]];else if (result && result.hasOwnProperty(parts[i])) result = result[parts[i]];\n    }\n\n    if (result && result.isComputedProperty && !options.raw) result = result.value();\n    return result;\n  },\n\n  // **Model.Set** is overridden to provide support for getting from a deep data tree.\n  // `key` may now be any valid json-like identifier. Ex: `obj.coll[3].value`.\n  // It needs to traverse `Models`, `Collections` and `Computed Properties` to\n  // find the correct value to call the original `Backbone.Set` on.\n  set: function set(key, value, options) {\n    var _this = this;\n\n    var attrs,\n        newKey,\n        destination,\n        props = [];\n\n    if ((typeof key === \"undefined\" ? \"undefined\" : _typeof(key)) === 'object') {\n      attrs = key.isModel ? key.attributes : key;\n      options = value;\n    } else (attrs = {})[key] = value;\n    options || (options = {});\n\n    // Convert getters and setters to computed properties\n    _reboundUtils2.default.extractComputedProps(attrs);\n\n    // If reset option passed, do a reset. If nothing passed, return.\n    if (options.reset === true) return this.reset(attrs, options);\n    if (options.defaults === true) this.defaults = attrs;\n    if (_.isEmpty(attrs)) {\n      return void 0;\n    }\n\n    // For each attribute passed:\n    var _loop = function _loop() {\n      var val = attrs[key],\n          paths = _reboundUtils2.default.splitPath(key),\n          attr = paths.pop() || '',\n          // The key          ex: foo[0].bar --> bar\n      target = _this.get(paths.join('.')),\n          // The element    ex: foo.bar.baz --> foo.bar\n      lineage = undefined;\n\n      // If target currently doesnt exist, construct its tree\n      if (_.isUndefined(target)) {\n        target = _this;\n        _.each(paths, function (part) {\n          var tmp = target.get(part);\n          if (_.isUndefined(tmp)) tmp = target.set(part, {}).get(part);\n          target = tmp;\n        }, _this);\n      }\n\n      // The old value of `attr` in `target`\n      destination = target.get(attr, { raw: true }) || {};\n\n      // Create this new object's lineage.\n      lineage = {\n        name: key,\n        parent: target,\n        root: _this.__root__,\n        path: pathGenerator(target, attr),\n        silent: true,\n        defaults: options.defaults\n      };\n      // - If val is `null` or `undefined`, set to default value.\n      // - If val is a `Computed Property`, get its current cache object.\n      // - If val (default value or evaluated computed property) is `null`, set to default value or (fallback `undefined`).\n      // - Else If val is a primitive object instance, convert to primitive value.\n      // - Else If `{raw: true}` option is passed, set the exact object that was passed. No promotion to a Rebound Data object.\n      // - Else If this function is the same as the current computed property, continue.\n      // - Else If this value is a `Function`, turn it into a `Computed Property`.\n      // - Else If this is going to be a cyclical dependancy, use the original object, don't make a copy.\n      // - Else If updating an existing object with its respective data type, let Backbone handle the merge.\n      // - Else If this value is a `Model` or `Collection`, create a new copy of it using its constructor, preserving its defaults while ensuring no shared memory between objects.\n      // - Else If this value is an `Array`, turn it into a `Collection`.\n      // - Else If this value is a `Object`, turn it into a `Model`.\n      // - Else val is a primitive value, set it accordingly.\n\n      if (_.isNull(val) || _.isUndefined(val)) val = _this.defaults[key];\n      if (val && val.isComputedProperty) val = val.value();\n      if (_.isNull(val) || _.isUndefined(val)) val = undefined;else if (val instanceof String) val = String(val);else if (val instanceof Number) val = Number(val);else if (val instanceof Boolean) val = Boolean(val.valueOf());else if (options.raw === true) val = val;else if (destination.isComputedProperty && destination.func === val) return \"continue\";else if (val.isComputedProto) val = new _computedProperty2.default(val.get, val.set, lineage);else if (val.isData && target.hasParent(val)) val = val;else if (destination.isComputedProperty || destination.isCollection && (_.isArray(val) || val.isCollection) || destination.isModel && (_.isObject(val) || val.isModel)) {\n        destination.set(val, options);\n        return \"continue\";\n      } else if (val.isData && options.clone !== false) val = new val.constructor(val.attributes || val.models, lineage);else if (_.isArray(val)) val = new Rebound.Collection(val, lineage); // TODO: Remove global referance\n      else if (_.isObject(val)) val = new Model(val, lineage);\n\n      // If val is a data object, let this object know it is now a parent\n      _this._hasAncestry = val && val.isData || false;\n\n      // Set the value\n      _backbone2.default.Model.prototype.set.call(target, attr, val, options); // TODO: Event cleanup when replacing a model or collection with another value\n    };\n\n    for (key in attrs) {\n      var _ret = _loop();\n\n      if (_ret === \"continue\") continue;\n    }\n\n    return this;\n  },\n\n  // Recursive `toJSON` function traverses the data tree returning a JSON object.\n  // If there are any cyclic dependancies the object's `cid` is used instead of looping infinitely.\n  toJSON: function toJSON() {\n    if (this._isSerializing) {\n      return this.id || this.cid;\n    }\n    this._isSerializing = true;\n    var json = _.clone(this.attributes);\n    _.each(json, function (value, name) {\n      if (_.isNull(value) || _.isUndefined(value)) {\n        return void 0;\n      }\n      _.isFunction(value.toJSON) && (json[name] = value.toJSON());\n    });\n    this._isSerializing = false;\n    return json;\n  }\n\n});\n\n// If default properties are passed into extend, process the computed properties\nModel.extend = function (protoProps, staticProps) {\n  _reboundUtils2.default.extractComputedProps(protoProps.defaults);\n  return _backbone2.default.Model.extend.call(this, protoProps, staticProps);\n};\n\nexports.default = Model;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ComputedProperty = exports.Collection = exports.Model = undefined;\n\nvar _model = require(\"rebound-data/model\");\n\nvar _model2 = _interopRequireDefault(_model);\n\nvar _collection = require(\"rebound-data/collection\");\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nvar _computedProperty = require(\"rebound-data/computed-property\");\n\nvar _computedProperty2 = _interopRequireDefault(_computedProperty);\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _reboundUtils2 = _interopRequireDefault(_reboundUtils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Rebound Data\n// ----------------\n// These are methods inherited by all Rebound data types: **Models**,\n// **Collections** and **Computed Properties**. Controls tree ancestry\n// tracking, deep event propagation and tree destruction.\n\nvar sharedMethods = {\n  // When a change event propagates up the tree it modifies the path part of\n  // `change:<path>` to reflect the fully qualified path relative to that object.\n  // Ex: Would trigger `change:val`, `change:[0].val`, `change:arr[0].val` and `obj.arr[0].val`\n  // on each parent as it is propagated up the tree.\n  propagateEvent: function propagateEvent(type, model) {\n    if (this.__parent__ === this || type === 'dirty') {\n      return void 0;\n    }\n    if (type.indexOf('change:') === 0 && model.isModel) {\n      if (this.isCollection && ~type.indexOf('change:[')) {\n        return void 0;\n      }\n      var key,\n          path = model.__path().replace(this.__parent__.__path(), '').replace(/^\\./, ''),\n          changed = model.changedAttributes();\n\n      for (key in changed) {\n        // TODO: Modifying arguments array is bad. change this\n        arguments[0] = 'change:' + path + (path && '.') + key; // jshint ignore:line\n        this.__parent__.trigger.apply(this.__parent__, arguments);\n      }\n      return void 0;\n    }\n    return this.__parent__.trigger.apply(this.__parent__, arguments);\n  },\n\n  // Set this data object's parent to `parent` and, as long as a data object is\n  // not its own parent, propagate every event triggered on `this` up the tree.\n  setParent: function setParent(parent) {\n    if (this.__parent__) {\n      this.off('all', this.propagateEvent);\n    }\n    this.__parent__ = parent;\n    this._hasAncestry = true;\n    if (parent !== this) {\n      this.on('all', this.__parent__.propagateEvent);\n    }\n    return parent;\n  },\n\n  // Recursively set a data tree's root element starting with `this` to the deepest child.\n  // TODO: I dont like this recursively setting elements root when one element's root changes. Fix this.\n  setRoot: function setRoot(root) {\n    var obj = this;\n    obj.__root__ = root;\n    var val = obj.models || obj.attributes || obj.cache;\n    _.each(val, function (value, key) {\n      if (value && value.isData) {\n        value.setRoot(root);\n      }\n    });\n    return root;\n  },\n\n  // Tests to see if `this` has a parent `obj`.\n  hasParent: function hasParent(obj) {\n    var tmp = this;\n    while (tmp !== obj) {\n      tmp = tmp.__parent__;\n      if (_.isUndefined(tmp)) return false;\n      if (tmp === obj) return true;\n      if (tmp.__parent__ === tmp) return false;\n    }\n    return true;\n  },\n\n  // De-initializes a data tree starting with `this` and recursively calling `deinitialize()` on each child.\n  deinitialize: function deinitialize() {\n    var _this = this;\n\n    // Undelegate Backbone Events from this data object\n    if (this.undelegateEvents) {\n      this.undelegateEvents();\n    }\n    if (this.stopListening) {\n      this.stopListening();\n    }\n    if (this.off) {\n      this.off();\n    }\n    if (this.unwire) {\n      this.unwire();\n    }\n\n    // Destroy this data object's lineage\n    delete this.__parent__;\n    delete this.__root__;\n    delete this.__path;\n\n    // If there is a dom element associated with this data object, destroy all listeners associated with it.\n    // Remove all event listeners from this dom element, recursively remove element lazyvalues,\n    // and then remove the element referance itself.\n    if (this.el) {\n      _.each(this.el.__listeners, function (handler, eventType) {\n        if (this.el.removeEventListener) {\n          this.el.removeEventListener(eventType, handler, false);\n        }\n        if (this.el.detachEvent) {\n          this.el.detachEvent('on' + eventType, handler);\n        }\n      }, this);\n      (0, _reboundUtils2.default)(this.el).walkTheDOM(function (el) {\n        if (el.__lazyValue && el.__lazyValue.destroy()) {\n          n.__lazyValue.destroy();\n        }\n      });\n      delete this.el.__listeners;\n      delete this.el.__events;\n      delete this.$el;\n      delete this.el;\n    }\n\n    // Clean up Hook callback references\n    delete this.__observers;\n\n    // Mark as deinitialized so we don't loop on cyclic dependancies.\n    this.deinitialized = true;\n\n    // Destroy all children of this data object.\n    // If a Collection, de-init all of its Models, if a Model, de-init all of its\n    // Attributes that aren't services, if a Computed Property, de-init its Cache objects.\n    _.each(this.models, function (val) {\n      val && val.deinitialize && val.deinitialize();\n    });\n    this.models && (this.models.length = 0);\n    _.each(this.attributes, function (val, key) {\n      delete _this.attributes[key];\n      val && !val.isComponent && val.deinitialize && val.deinitialize();\n    });\n    if (this.cache) {\n      this.cache.collection.deinitialize();\n      this.cache.model.deinitialize();\n    }\n  }\n};\n\n// Extend all of the **Rebound Data** prototypes with these shared methods\n_.extend(_model2.default.prototype, sharedMethods);\n_.extend(_collection2.default.prototype, sharedMethods);\n_.extend(_computedProperty2.default.prototype, sharedMethods);\n\nexports.Model = _model2.default;\nexports.Collection = _collection2.default;\nexports.ComputedProperty = _computedProperty2.default;\nexports.default = { Model: _model2.default, Collection: _collection2.default, ComputedProperty: _computedProperty2.default };","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasHelper = hasHelper;\nexports.lookupHelper = lookupHelper;\nexports.registerHelper = registerHelper;\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _reboundUtils2 = _interopRequireDefault(_reboundUtils);\n\nvar _lazyValue = require(\"rebound-htmlbars/lazy-value\");\n\nvar _lazyValue2 = _interopRequireDefault(_lazyValue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Rebound Helpers\n// ----------------\n\nvar HELPERS = {};\n\nfunction NOOP() {\n  return '';\n}\n\nfunction hasHelper(env, scope, name) {\n  env && env.helpers || (env = { helpers: HELPERS });\n  return !!(HELPERS[name] || env.helpers[name]);\n}\n\n// lookupHelper returns the given function from the helpers object. Manual checks prevent user from overriding reserved words.\nfunction lookupHelper(env, scope, name) {\n  if (_.isString(env)) {\n    name = env;\n  }\n  env && env.helpers || (env = { helpers: HELPERS });\n\n  // If `name` is a reserved helper, return it\n  if (name === 'length') return HELPERS.length;\n  if (name === 'if') return HELPERS.if;\n  if (name === 'unless') return HELPERS.unless;\n  if (name === 'each') return HELPERS.each;\n  if (name === 'on') return HELPERS.on;\n  if (name === 'debugger') return HELPERS.debugger;\n  if (name === 'log') return HELPERS.log;\n\n  // If not a reserved helper, check env, then global helpers, or return undefined.\n  if (!hasHelper(env, null, name)) {\n    console.error('No helper named', name, 'registered with Rebound');\n  }\n  return HELPERS[name] || env.helpers[name] || NOOP;\n}\n\nfunction registerHelper(name, callback, env) {\n  if (!_.isString(name)) return console.error('Name provided to registerHelper must be a string!');\n  if (!_.isFunction(callback)) return console.error('Callback provided to regierHelper must be a function!');\n  if (hasHelper(env, null, name)) return console.error('A helper called \"' + name + '\" is already registered!');\n\n  HELPERS[name] = callback;\n}\n\n/*******************************\n        Default helpers\n********************************/\n\nHELPERS.debugger = function debuggerHelper(params, hash, options, env) {\n  /* jshint -W087 */\n  debugger;\n  return '';\n};\n\nHELPERS.log = function logHelper(params, hash, options, env) {\n  console.log.apply(console, params);\n  return '';\n};\n\nHELPERS.on = function onHelper(params, hash, options, env) {\n  var i,\n      callback,\n      delegate,\n      element,\n      eventName = params[0],\n      len = params.length;\n\n  // By default everything is delegated on the parent component\n  if (len === 2) {\n    callback = params[1];\n    delegate = options.element;\n    element = options.element;\n  }\n  // If a selector is provided, delegate on the helper's element\n  else if (len === 3) {\n      callback = params[2];\n      delegate = params[1];\n      element = options.element;\n    }\n\n  // Attach event\n  (0, _reboundUtils2.default)(element).on(eventName, delegate, hash, function (event) {\n    if (!_.isFunction(env.root[callback])) {\n      throw \"ERROR: No method named \" + callback + \" on component \" + env.root.tagName + \"!\";\n    }\n    return env.root[callback].call(env.root, event);\n  });\n};\n\nHELPERS.length = function lengthHelper(params, hash, options, env) {\n  return params[0] && params[0].length || 0;\n};\n\nfunction isTruthy(condition) {\n\n  if (condition === true || condition === false) {\n    return condition;\n  }\n\n  // Handle null values\n  if (condition === undefined || condition === null) {\n    return false;\n  }\n\n  // Handle models\n  if (condition.isModel) {\n    return true;\n  }\n\n  // Handle arrays and collection\n  if (_.isArray(condition) || condition.isCollection) {\n    return !!condition.length;\n  }\n\n  // Handle string values\n  if (condition === 'true') {\n    return true;\n  }\n  if (condition === 'false') {\n    return false;\n  }\n\n  return !!condition;\n}\n\nHELPERS.if = function ifHelper(params, hash, templates) {\n\n  var condition = isTruthy(params[0]);\n\n  // If yield does not exist, this is not a block helper.\n  if (!this.yield) {\n    return condition ? params[1] : params[2] || '';\n  }\n\n  // Render the apropreate block statement\n  if (condition && this.yield) {\n    this.yield();\n  } else if (!condition && templates.inverse && templates.inverse.yield) {\n    templates.inverse.yield();\n  } else {\n    return '';\n  }\n};\n\n// Unless proxies to the if helper with an inverted conditional value.\nHELPERS.unless = function unlessHelper(params, hash, templates) {\n  params[0] = !isTruthy(params[0]);\n  return HELPERS.if.apply(this, [params, hash, templates]);\n};\n\nHELPERS.each = function eachHelper(params, hash, templates) {\n\n  // If no data passed, exit\n  if (!params[0]) {\n    return void 0;\n  }\n\n  // Accepts collections, arrays, models, or objects\n  var value = params[0].isCollection ? params[0].models : params[0].isModel ? params[0].attributes : params[0];\n\n  // If the scope has values, render them\n  if (value && (_.isArray(value) && value.length > 0 || _.isObject(value) && Object.keys(value).length > 0)) {\n    // For each value in the array, yield using that data model\n    for (var key in value) {\n      var eachId = value[key] && value[key].isData ? value[key].cid : params[0].cid + key;\n      if (value.hasOwnProperty(key)) {\n        this.yieldItem(eachId, [value[key], key]);\n      }\n    }\n  }\n\n  // Otherwise, render the inverse template\n  else {\n      if (templates.inverse && templates.inverse[\"yield\"]) {\n        templates.inverse[\"yield\"]();\n      }\n    }\n};\n\nexports.default = HELPERS;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _reboundUtils2 = _interopRequireDefault(_reboundUtils);\n\nvar _hooks = require(\"htmlbars-runtime/hooks\");\n\nvar _hooks2 = _interopRequireDefault(_hooks);\n\nvar _render2 = require(\"htmlbars-runtime/render\");\n\nvar _render3 = _interopRequireDefault(_render2);\n\nvar _createFreshEnv = require(\"rebound-htmlbars/hooks/createFreshEnv\");\n\nvar _createFreshEnv2 = _interopRequireDefault(_createFreshEnv);\n\nvar _createChildEnv = require(\"rebound-htmlbars/hooks/createChildEnv\");\n\nvar _createChildEnv2 = _interopRequireDefault(_createChildEnv);\n\nvar _createFreshScope = require(\"rebound-htmlbars/hooks/createFreshScope\");\n\nvar _createFreshScope2 = _interopRequireDefault(_createFreshScope);\n\nvar _createChildScope = require(\"rebound-htmlbars/hooks/createChildScope\");\n\nvar _createChildScope2 = _interopRequireDefault(_createChildScope);\n\nvar _bindScope = require(\"rebound-htmlbars/hooks/bindScope\");\n\nvar _bindScope2 = _interopRequireDefault(_bindScope);\n\nvar _linkRenderNode = require(\"rebound-htmlbars/hooks/linkRenderNode\");\n\nvar _linkRenderNode2 = _interopRequireDefault(_linkRenderNode);\n\nvar _cleanupRenderNode = require(\"rebound-htmlbars/hooks/cleanupRenderNode\");\n\nvar _cleanupRenderNode2 = _interopRequireDefault(_cleanupRenderNode);\n\nvar _destroyRenderNode = require(\"rebound-htmlbars/hooks/destroyRenderNode\");\n\nvar _destroyRenderNode2 = _interopRequireDefault(_destroyRenderNode);\n\nvar _willCleanupTree = require(\"rebound-htmlbars/hooks/willCleanupTree\");\n\nvar _willCleanupTree2 = _interopRequireDefault(_willCleanupTree);\n\nvar _didCleanupTree = require(\"rebound-htmlbars/hooks/didCleanupTree\");\n\nvar _didCleanupTree2 = _interopRequireDefault(_didCleanupTree);\n\nvar _get = require(\"rebound-htmlbars/hooks/get\");\n\nvar _get2 = _interopRequireDefault(_get);\n\nvar _getValue = require(\"rebound-htmlbars/hooks/getValue\");\n\nvar _getValue2 = _interopRequireDefault(_getValue);\n\nvar _invokeHelper = require(\"rebound-htmlbars/hooks/invokeHelper\");\n\nvar _invokeHelper2 = _interopRequireDefault(_invokeHelper);\n\nvar _subexpr = require(\"rebound-htmlbars/hooks/subexpr\");\n\nvar _subexpr2 = _interopRequireDefault(_subexpr);\n\nvar _concat = require(\"rebound-htmlbars/hooks/concat\");\n\nvar _concat2 = _interopRequireDefault(_concat);\n\nvar _content = require(\"rebound-htmlbars/hooks/content\");\n\nvar _content2 = _interopRequireDefault(_content);\n\nvar _attribute = require(\"rebound-htmlbars/hooks/attribute\");\n\nvar _attribute2 = _interopRequireDefault(_attribute);\n\nvar _partial = require(\"rebound-htmlbars/hooks/partial\");\n\nvar _partial2 = _interopRequireDefault(_partial);\n\nvar _component = require(\"rebound-htmlbars/hooks/component\");\n\nvar _component2 = _interopRequireDefault(_component);\n\nvar _helpers = require(\"rebound-htmlbars/helpers\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// __Environment Hooks__ create and modify the template environment objects\n\n_hooks2.default.createFreshEnv = _createFreshEnv2.default; // Rebound Hooks\n// ----------------\n// Here we augment HTMLBars' default hooks to make use of Rebound's evented data\n// objects for automatic databinding.\n\n_hooks2.default.createChildEnv = _createChildEnv2.default;\n\n// __Scope Hooks__ create, access and modify the template scope and data objects\n\n_hooks2.default.createFreshScope = _createFreshScope2.default;\n_hooks2.default.createChildScope = _createChildScope2.default;\n_hooks2.default.bindScope = _bindScope2.default;\n\n// __Lifecycle Hooks__ construct, deconstruct and clean up render nodes over their lifecycles\n\n_hooks2.default.linkRenderNode = _linkRenderNode2.default;\n_hooks2.default.willCleanupTree = _willCleanupTree2.default;\n_hooks2.default.cleanupRenderNode = _cleanupRenderNode2.default;\n_hooks2.default.destroyRenderNode = _cleanupRenderNode2.default;\n_hooks2.default.didCleanupTree = _didCleanupTree2.default;\n\n// __Streaming Hooks__ create streams via LazyValues for data values, helpers, subexpressions and concat groups\n\n_hooks2.default.get = _get2.default;\n_hooks2.default.getValue = _getValue2.default;\n_hooks2.default.invokeHelper = _invokeHelper2.default;\n_hooks2.default.subexpr = _subexpr2.default;\n_hooks2.default.concat = _concat2.default;\n\n// __Render Hooks__ interact with the DOM to output content and bind to form elements for two way databinding\n\n_hooks2.default.content = _content2.default;\n_hooks2.default.attribute = _attribute2.default;\n_hooks2.default.partial = _partial2.default;\n_hooks2.default.registerPartial = _partial.registerPartial;\n_hooks2.default.component = _component2.default;\n\n// __Helper Hooks__ manage the environment's registered helpers\n\n_hooks2.default.hasHelper = _helpers.hasHelper;\n_hooks2.default.lookupHelper = _helpers.lookupHelper;\n_hooks2.default.registerHelper = _helpers.registerHelper;\n\n// Bind local binds a local variable to the scope object and tracks the scope\n// level at which that local was added. See `createChildScope` for description\n// of scope levels\n_hooks2.default.bindLocal = function bindLocal(env, scope, name, value) {\n  scope.localPresent[name] = scope.level;\n  scope.locals[name] = value;\n};\n\n// __buildRenderResult__ is a wrapper for the native HTMLBars render function. It\n// ensures every template is rendered with its own child environment, every environment\n// saves a referance to its unique render result for re-renders, and every render\n// result has a unique id.\n_hooks2.default.buildRenderResult = function buildRenderResult(template, env, scope, options) {\n  var render = _render3.default.default || _render3.default; // Fix for stupid Babel imports\n  env = _hooks2.default.createChildEnv(env);\n  env.template = render(template, env, scope, options);\n  env.template.uid = _reboundUtils2.default.uniqueId('template');\n  return env.template;\n};\n\nexports.default = _hooks2.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = attribute;\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _reboundUtils2 = _interopRequireDefault(_reboundUtils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// All valid text based HTML input types\nvar TEXT_INPUTS = { \"null\": 1, text: 1, email: 1, password: 1,\n  search: 1, url: 1, tel: 1, hidden: 1,\n  number: 1, color: 1, date: 1, datetime: 1,\n  month: 1, range: 1, time: 1, week: 1,\n  \"datetime-local\": 1\n};\n\n// All valid boolean HTML input types\n// ### Attribute Hook\n\nvar BOOLEAN_INPUTS = { checkbox: 1, radio: 1 };\n\n// Attribute Hook\nfunction attribute(attrMorph, env, scope, name, value) {\n\n  var val = value.isLazyValue ? value.value : value,\n      el = attrMorph.element,\n      tagName = el.tagName,\n      type = el.getAttribute(\"type\");\n\n  // If this is a text input element's value prop, wire up our databinding\n  if (tagName === 'INPUT' && TEXT_INPUTS[type] && name === 'value') {\n\n    // If our input events have not been bound yet, bind them\n    if (!attrMorph.eventsBound) {\n      (0, _reboundUtils2.default)(el).on('change input propertychange', function (event) {\n        value.set(value.path, this.value);\n      });\n      attrMorph.eventsBound = true;\n    }\n\n    // Set the value property of the input\n    el.value = val ? String(val) : '';\n  } else if (tagName === 'INPUT' && BOOLEAN_INPUTS[type] && name === 'checked') {\n\n    // If our input events have not been bound yet, bind them\n    if (!attrMorph.eventsBound) {\n      (0, _reboundUtils2.default)(el).on('change propertychange', function (event) {\n        value.set(value.path, this.checked ? true : false);\n      });\n      attrMorph.eventsBound = true;\n    }\n\n    el.checked = val ? true : undefined;\n  }\n\n  // Special case for link elements with dynamic classes.\n  // If the router has assigned it a truthy 'active' property, ensure that the extra class is present on re-render.\n  else if (tagName === 'A' && name === 'class' && el.active) {\n      val = val ? String(val) + ' active' : 'active';\n    }\n\n  // Set the attribute on our element for visual referance\n  val ? el.setAttribute(name, String(val)) : el.removeAttribute(name);\n\n  this.linkRenderNode(attrMorph, env, scope, '@attribute', [value], {});\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = bindScope;\n// ### Bind-Scope Hook\n\n// Make scope available on the environment object to allow hooks to cache streams on it.\nfunction bindScope(env, scope) {\n  env.scope = scope;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cleanupRenderNode;\n// ### Cleanup-Render-Node Hook\n\n// Called before destroying any render node\nfunction cleanupRenderNode(morph) {\n  // morph.lazyValue && morph.lazyValue.destroy();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = component;\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _factory = require(\"rebound-component/factory\");\n\nvar _factory2 = _interopRequireDefault(_factory);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// All valid HTML attributes\nvar ATTRIBUTES = { abbr: 1, \"accept-charset\": 1, accept: 1, accesskey: 1, action: 1,\n  align: 1, alink: 1, alt: 1, archive: 1, axis: 1,\n  background: 1, bgcolor: 1, border: 1, cellpadding: 1, cellspacing: 1,\n  char: 1, charoff: 1, charset: 1, checked: 1, cite: 1,\n  class: 1, classid: 1, clear: 1, code: 1, codebase: 1,\n  codetype: 1, color: 1, cols: 1, colspan: 1, compact: 1,\n  content: 1, coords: 1, data: 1, datetime: 1, declare: 1,\n  defer: 1, dir: 1, disabled: 1, enctype: 1, face: 1,\n  for: 1, frame: 1, frameborder: 1, headers: 1, height: 1,\n  href: 1, hreflang: 1, hspace: 1, \"http-equiv\": 1, id: 1,\n  ismap: 1, label: 1, lang: 1, language: 1, link: 1,\n  longdesc: 1, marginheight: 1, marginwidth: 1, maxlength: 1, media: 1,\n  method: 1, multiple: 1, name: 1, nohref: 1, noresize: 1,\n  noshade: 1, nowrap: 1, object: 1, onblur: 1, onchange: 1,\n  onclick: 1, ondblclick: 1, onfocus: 1, onkeydown: 1, onkeypress: 1,\n  onkeyup: 1, onload: 1, onmousedown: 1, onmousemove: 1, onmouseout: 1,\n  onmouseover: 1, onmouseup: 1, onreset: 1, onselect: 1, onsubmit: 1,\n  onunload: 1, profile: 1, prompt: 1, readonly: 1, rel: 1,\n  rev: 1, rows: 1, rowspan: 1, rules: 1, scheme: 1,\n  scope: 1, scrolling: 1, selected: 1, shape: 1, size: 1,\n  span: 1, src: 1, standby: 1, start: 1, style: 1,\n  summary: 1, tabindex: 1, target: 1, text: 1, title: 1,\n  type: 1, usemap: 1, valign: 1, value: 1, valuetype: 1,\n  version: 1, vlink: 1, vspace: 1, width: 1 };\n\nfunction component(morph, env, scope, tagName, params, attrs, templates, visitor) {\n  var _this = this;\n\n  // Components are only ever rendered once\n  if (morph.componentIsRendered) {\n    return void 0;\n  }\n\n  var component,\n      element,\n      outlet,\n      render = this.buildRenderResult,\n      seedData = {},\n      componentData = {};\n\n  // Create a plain data object to pass to our new component as seed data\n  for (var key in attrs) {\n    seedData[key] = this.getValue(attrs[key]);\n  }\n\n  // For each param passed to our shared component, add it to our custom element\n  component = (0, _factory2.default)(tagName, seedData, _defineProperty({}, _reboundUtils.REBOUND_SYMBOL, { templates: templates, env: env, scope: scope }));\n  element = component.el;\n\n  var _loop = function _loop(key) {\n\n    // For each param passed to our component, create its lazyValue\n    componentData[key] = _this.get(component.env, component.scope, key);\n\n    // Set up two way binding between component and original context\n    if (componentData[key].isLazyValue && attrs[key].isLazyValue) {\n\n      // For each lazy param passed to our component, have it update the original context when changed.\n      componentData[key].onNotify(function () {\n        attrs[key].set(attrs[key].path, componentData[key].value);\n      });\n\n      // For each lazy param passed to our component, have it update the component when changed.\n      attrs[key].onNotify(function () {\n        componentData[key].set(key, attrs[key].value);\n      });\n\n      // Seed the cache\n      componentData[key].value;\n    }\n  };\n\n  for (var key in seedData) {\n    _loop(key);\n  }\n\n  // TODO: Move this to Component\n  // // For each change on our component, update the states of the original context and the element's proeprties.\n  function updateAttrs() {\n    var json = component.toJSON();\n\n    if (_.isString(json)) return; // If is a string, this model is seralizing already\n\n    // Set the properties on our element for visual referance if we are on a top level attribute\n    _.each(json, function (value, key) {\n      // TODO: Currently, showing objects as properties on the custom element causes problems.\n      // Linked models between the context and component become the same exact model and all hell breaks loose.\n      // Find a way to remedy this. Until then, don't show objects.\n      if (_.isObject(value) || _.isUndefined(value)) {\n        return;\n      }\n      value = _.isObject(value) ? JSON.stringify(value) : value;\n      try {\n        ATTRIBUTES[key] ? element.setAttribute(key, value) : element.dataset[key] = value;\n      } catch (e) {\n        console.error(e.message);\n      }\n    });\n  }\n  component.listenTo(component, 'change', updateAttrs);\n  updateAttrs();\n\n  /** The attributeChangedCallback on our custom element updates the component's data. **/\n\n  morph.setNode(element);\n  morph.componentIsRendered = true;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = concat;\n\nvar _lazyValue = require(\"rebound-htmlbars/lazy-value\");\n\nvar _lazyValue2 = _interopRequireDefault(_lazyValue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// ### Concat Hook\n\n// The `concat` hook creates a LazyValue for adjacent expressions so they may be\n// used as a single data point in its parent expression. For example:\n// ```\n// <div class=\"{{foo}} active {{bar}}\"></div>\n// ```\n// The div's attribute expression is passed a concat LazyValue that alerts its\n// subscribers whenever any of its dynamic values change.\n\nvar CONCAT_CACHE = {};\n\nfunction concat(env, params) {\n\n  // If the concat expression only contains a single value, return it.\n  if (params.length === 1) {\n    return params[0];\n  }\n\n  // Each concat LazyValue is unique to its inputs. Compute it's unique name.\n  var name = \"concat: \";\n  _.each(params, function (param, index) {\n    name += \"\" + (param && param.isLazyValue ? param.cid : param);\n  });\n\n  // Check the streams cache and return if this LazyValue has already been made\n  if (CONCAT_CACHE[name]) {\n    return CONCAT_CACHE[name];\n  }\n\n  // Create a lazyvalue that returns the concatted values of all input params\n  // Add it to the streams cache and return\n  return CONCAT_CACHE[name] = new _lazyValue2.default(function (params) {\n    return params.join('');\n  }, {\n    context: params[0].context,\n    path: name,\n    params: params\n  });\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = content;\n// ### Content Hook\n\n// Content Hook\nfunction content(morph, env, context, path, lazyValue) {\n  var el = morph.contextualElement;\n\n  // Two way databinding for textareas\n  if (el.tagName === 'TEXTAREA') {\n    lazyValue.onNotify(function updateTextarea(lazyValue) {\n      el.value = lazyValue.value;\n    });\n    $(el).on('change keyup', function updateTextareaLazyValue(event) {\n      lazyValue.set(lazyValue.path, this.value);\n    });\n  }\n\n  morph.lazyValue = lazyValue;\n\n  return lazyValue.value;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createChildEnv;\n// ### Create-Child-Environment Hook\n\n// Create an environment object that will inherit everything from its parent\n// environment until written over with a local variable.\nfunction createChildEnv(parent) {\n  var env = Object.create(parent);\n  env.helpers = Object.create(parent.helpers);\n  return env;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createChildScope;\n// ### Create-Child-Scope Hook\n\n// Create a scope object that will inherit everything from its parent\n// scope until written over with a local variable.\nfunction createChildScope(parent) {\n  var scope = Object.create(parent);\n  scope.level = parent.level + 1;\n  scope.locals = Object.create(parent.locals);\n  scope.localPresent = Object.create(parent.localPresent);\n  scope.streams = Object.create(parent.streams);\n  scope.blocks = Object.create(parent.blocks);\n  return scope;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createFreshEnv;\n\nvar _domHelper = require(\"dom-helper\");\n\nvar _domHelper2 = _interopRequireDefault(_domHelper);\n\nvar _helpers = require(\"rebound-htmlbars/helpers\");\n\nvar _helpers2 = _interopRequireDefault(_helpers);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// ### Create-Fresh-Environment Hook\n\n// Rebound's default environment\n// The application environment is propagated down each render call and\n// augmented with helpers as it goes\n\nvar DOMHelper = _domHelper2.default.default || _domHelper2.default; // Fix for stupid Babel imports\n\nfunction createFreshEnv() {\n  return {\n    isReboundEnv: true,\n    cid: _.uniqueId('env'),\n    root: null,\n    helpers: _helpers2.default,\n    hooks: this,\n    dom: new DOMHelper(),\n    revalidateQueue: {},\n    observers: {}\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createFreshScope;\n// ### Create-Fresh-Scope Hook\n\n// Rebound's default scope object.\n// The scope object is propagated down each block expression or render call and\n// augmented with local variables as it goes. LazyValues are cached as streams\n// here as well. Because `in` checks have unpredictable performance, keep a\n// separate dictionary to track whether a local was bound.\nfunction createFreshScope() {\n  return {\n    level: 1,\n    self: null,\n    locals: {},\n    localPresent: {},\n    streams: {},\n    blocks: {}\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = destroyRenderNode;\n// ### Destroy-Render-Node Hook\n\n// Called when destroying a render node\nfunction destroyRenderNode(morph) {}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = didCleanupTree;\n// ### Did-Cleanup-Tree Hook\n\n// Called after destroying any node tree\nfunction didCleanupTree(env, morph, destroySelf) {}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = get;\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _reboundUtils2 = _interopRequireDefault(_reboundUtils);\n\nvar _lazyValue = require(\"rebound-htmlbars/lazy-value\");\n\nvar _lazyValue2 = _interopRequireDefault(_lazyValue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// ### Get Hook\n\n// The get hook streams a property at a named path from a given scope. It returns\n// a `LazyValue` that other code can subscribe to and be alerted when values change.\nfunction get(env, scope, path) {\n  var context = scope.self;\n\n  // The special word `this` should referance empty string\n  if (path === 'this') {\n    path = '';\n  }\n\n  // If this path referances a block param, use that as the context instead.\n  var rest = _reboundUtils2.default.splitPath(path);\n  var key = rest.shift();\n  if (scope.localPresent[key]) {\n    context = scope.locals[key];\n    path = rest.join('.');\n  }\n\n  // If this value is not a local value, and there is a stream present\n  // If this value is a local, but not at this scope layer, and there is\n  if (scope.streams[path] && (!scope.streams[path].layer && !scope.localPresent[key] || scope.streams[path].layer === scope.localPresent[key])) {\n    return scope.streams[path];\n  }\n\n  // Given a context and a path, create a LazyValue object that returns\n  // the value of object at path and add an observer to the context at path.\n  return scope.streams[path] = new _lazyValue2.default(function () {\n    return this.context.get(this.path, { isPath: true });\n  }, {\n    context: context,\n    path: path,\n    layer: scope.localPresent[key]\n  }).addObserver(path, context, env);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getValue;\n// ### Get Value Hook\n\n// The getValue hook retreives the value of the passed in referance.\n// It will return the propper value regardless of if the referance passed is the\n// value itself, or a LazyValue.\nfunction getValue(referance) {\n  return referance && referance.isLazyValue ? referance.value : referance;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = invokeHelper;\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _reboundUtils2 = _interopRequireDefault(_reboundUtils);\n\nvar _lazyValue = require(\"rebound-htmlbars/lazy-value\");\n\nvar _lazyValue2 = _interopRequireDefault(_lazyValue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// ### Invoke-Helper Hook\n\n// The `invokeHelper` hook streams a the result of a helper function. It returns\n// a `LazyValue` that other code can subscribe to and be alerted when values change.\nfunction invokeHelper(morph, env, scope, visitor, params, hash, helper, templates, context) {\n\n  // If this is not a valid helper, log an error and return an empty string value.\n  if (!_.isFunction(helper)) {\n    console.error('Invalid helper!', helper);\n    return { value: '' };\n  }\n\n  // Each helper LazyValue is unique to its inputs. Compute it's unique name.\n  var name = helper.name + \":\";\n  _.each(params, function (param, index) {\n    name += \" \" + (param && param.isLazyValue ? param.cid : param);\n  });\n  _.each(hash, function (hash, key) {\n    name += \" \" + key + \"=\" + hash.cid;\n  });\n\n  // Check the stream cache for this LazyValue, return it if it exists.\n  if (scope.streams[name]) {\n    return scope.streams[name];\n  }\n\n  // Create a LazyValue that returns the value of our evaluated helper.\n  var lazyValue = new _lazyValue2.default(function (params, hash) {\n    return helper.call(context || {}, params, hash, templates, env);\n  }, {\n    path: name,\n    params: params,\n    hash: hash\n  });\n\n  // If this is not a block or element helper, cache the new lazyValue.\n  // Only block helpers will have a context set passed. Non-element helpers will\n  // have the morph set. Block and morph helpers have re-rendered dom that must\n  // be fresh in the LazyValue's closure each run.\n  if (!context && morph) {\n    scope.streams[name] = lazyValue;\n  }\n\n  // Seed the cache and return the new LazyValue\n  lazyValue.value;\n  return lazyValue;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = linkRenderNode;\n// ### Link-Render-Node Hook\n\n// Called on first creation of any expressions that interact directly with the DOM.\n// Whenever it is notified of any changes to it's dependant values, mark the node\n// as dirty and add it to the environment's revalidation queue to be rerendered\n// during the next animation frame.\nfunction linkRenderNode(renderNode, env, scope, path, params, hash) {\n\n  function rerender(path, node, lazyValue, env) {\n    lazyValue.onNotify(function () {\n      node.isDirty = true;\n      env.template && (env.revalidateQueue[env.template.uid] = env.template);\n    });\n  }\n\n  // Save the path on our render node for easier debugging\n  renderNode.path = path;\n\n  // For every parameter or hash value passed to this render node, if it is a data\n  // stream, subscribe to notifications from it and when notified of a change,\n  // mark the node as dirty and queue it up for revalidation.\n  if (params && params.length) {\n    for (var i = 0; i < params.length; i++) {\n      if (params[i].isLazyValue) {\n        rerender(path, renderNode, params[i], env);\n      }\n    }\n  }\n  if (hash) {\n    for (var key in hash) {\n      if (hash.hasOwnProperty(key) && hash[key].isLazyValue) {\n        rerender(path, renderNode, hash[key], env);\n      }\n    }\n  }\n  return 1;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.registerPartial = registerPartial;\nexports.default = partial;\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _reboundUtils2 = _interopRequireDefault(_reboundUtils);\n\nvar _loader = require(\"rebound-router/loader\");\n\nvar _loader2 = _interopRequireDefault(_loader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar PARTIALS = {};\n\nfunction registerPartial(name, template) {\n  if (template && _.isString(name)) {\n\n    // If this partial has a callback list associated with its name, call all of\n    // the callbacks before registering the partial.\n    if (Array.isArray(PARTIALS[name])) {\n      PARTIALS[name].forEach(function (cb) {\n        cb(template);\n      });\n    }\n\n    // Save the partial template in our cache and return it\n    _loader2.default.register('/' + name + '.js');\n    return PARTIALS[name] = template;\n  }\n}\n\nfunction partial(renderNode, env, scope, path) {\n\n  // If no path is passed, yell\n  if (!path) {\n    console.error('Partial hook must be passed path!');\n  }\n\n  // Resolve the value of path\n  path = path.isLazyValue ? path.value : path;\n\n  // Create new child scope for partial\n  scope = this.createChildScope(scope);\n\n  var render = this.buildRenderResult;\n\n  // If a partial is registered with this path name, render it\n  if (PARTIALS[path] && !Array.isArray(PARTIALS[path])) {\n    return render(PARTIALS[path], env, scope, { contextualElement: renderNode }).fragment;\n  }\n\n  // If this partial is not yet registered, add it to a callback list to be called\n  // when registered. When registered, replace the dummy node we created with the\n  // rendered partial template.\n  var node = document.createTextNode('');\n  PARTIALS[path] || (PARTIALS[path] = []);\n  PARTIALS[path].push(function partialCallback(template) {\n    if (!node.parentNode) {\n      return void 0;\n    }\n    node.parentNode.replaceChild(render(template, env, scope, { contextualElement: renderNode }).fragment, node);\n  });\n  return node;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = subexpr;\n// ### Subexpr Hook\n\n// The `subexpr` hook creates a LazyValue for a nexted expression so it may be\n// used as a single data point in its parent expression. For example:\n// ```\n// {{#if (equal (add 1 2) 3)}}True!{{/if}}\n// ```\n// The `if` block expression contains a subexpression that is the evalued value\n// of the `equal` helper, which in turn contains a subexpression that is the\n// evalued value of the `add` helper. Each subexpression is represented internally\n// by a single LazyValue that notifies its subscribers when it changes.\nfunction subexpr(env, scope, helperName, params, hash) {\n  var helper = this.lookupHelper(helperName, env);\n\n  // Return the apropreate LazyValue for this subexpression type.\n  if (helper) {\n    return this.invokeHelper(null, env, scope, null, params, hash, helper, {}, undefined);\n  }\n\n  return this.get(env, scope, helperName);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = willCleanupTree;\n// ### Will-Cleanup-Tree Hook\n\n// Called before destroying any node tree\nfunction willCleanupTree(env, morph, destroySelf) {}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _reboundUtils = require('rebound-utils/rebound-utils');\n\nvar _reboundUtils2 = _interopRequireDefault(_reboundUtils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar NIL = function NIL() {},\n    EMPTY_ARRAY = []; // Rebound Lazy Value\n// ----------------\n\nvar LAZYVALUE_COUNT = 0;\n\nfunction LazyValue(fn) {\n  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  this.cid = _reboundUtils2.default.uniqueId('lazyValue');\n  this.valueFn = fn;\n  this.cache = NIL;\n  this.context = options.context || null;\n  this.children = [];\n  this.hash = {};\n  this.subscribers = [];\n  this.observers = [];\n  this.referance = 0;\n  _.extend(this, options);\n\n  // For each param or hash value passed to our helper's LazyValue, add it to the\n  // dependant list. The helper's LazyValue will re-evaluate when one changes.\n  _.each(options.params, function (param, index) {\n    param || (param = '');\n    this.children.push(param);\n    param.isLazyValue && param.onNotify(this);\n  }, this);\n\n  _.each(options.hash, function (value, key) {\n    value || (value = '');\n    value.isLazyValue && value.onNotify(this);\n    this.hash[key] = value;\n  }, this);\n}\n\nLazyValue.prototype = {\n\n  isLazyValue: true,\n\n  get value() {\n\n    // If cache is already computed, return it\n    if (this.cache !== NIL) {\n      return this.cache;\n    }\n\n    // Assemble our args and hash variables for the helper. For each LazyValue\n    // param or hash, insert the evaluated value so helpers don't need to have any\n    // concept of lazyvalues.\n    var params = new Array(this.children.length),\n        hash = {};\n\n    for (var i = 0, l = this.children.length; i < l; i++) {\n      var child = this.children[i];\n      params[i] = child && child.isLazyValue ? child.value : child;\n    }\n\n    for (var key in this.hash) {\n      if (!this.hash.hasOwnProperty(key)) {\n        continue;\n      }\n      var child = this.hash[key];\n      hash[key] = child && child.isLazyValue ? child.value : child;\n    }\n\n    return this.cache = this.valueFn(params, hash);\n  },\n\n  set: function set(key, value, options) {\n    return this.context && this.context.set(key, value, options) || null;\n  },\n\n  addObserver: function addObserver(path, context, env) {\n\n    if (!_.isObject(context) || !_.isString(path)) {\n      return console.error('Error adding observer for', context, path);\n    }\n    path = path.trim();\n    var origin = context.__path().replace(/\\[[^\\]]+\\]/g, \".@each\").trim();\n    var cache = env.observers[origin] || (env.observers[origin] = {});\n    cache[path] || (cache[path] = []);\n    var position = cache[path].push(this) - 1;\n\n    this.observers.push({ env: env, origin: origin, path: path, index: position });\n\n    return this;\n  },\n\n  // Mark this LazyValue, and all who depend on it, as dirty by setting its cache\n  // to NIL. This will force a full re-compute of its value when next requests rather\n  // than just returning the cache object.\n  makeDirty: function makeDirty() {\n    if (this.cache === NIL) {\n      return void 0;\n    }\n    this.cache = NIL;\n    for (var i = 0, l = this.subscribers.length; i < l; i++) {\n      this.subscribers[i].isLazyValue && this.subscribers[i].makeDirty();\n    }\n  },\n\n  // Ensure that this node and all of its dependants are dirty, then call each\n  // of its dependants. If a dependant is a LazyValue, and marked as destroyed,\n  // remove it fromt the array\n  notify: function notify() {\n    this.makeDirty();\n    for (var i = 0, l = this.subscribers.length; i < l; i++) {\n      if (!this.subscribers[i]) {\n        continue;\n      } else if (this.subscribers[i].isLazyValue) {\n        this.subscribers[i].destroyed ? this.subscribers[i] = void 0 : this.subscribers[i].notify();\n      } else {\n        this.subscribers[i](this);\n      }\n    }\n  },\n\n  onNotify: function onNotify(callback) {\n    this.subscribers.push(callback);\n    this.referance++;\n    return this;\n  },\n\n  destroy: function destroyLazyValue() {\n    this.destroyed = true;\n\n    _.each(this.children, function (child) {\n      if (!child || !child.isLazyValue) {\n        return void 0;\n      }\n      if (--child.referance === 0) {\n        child.destroy();\n      }\n    });\n    _.each(this.hash, function (child) {\n      if (!child || !child.isLazyValue) {\n        return void 0;\n      }\n      if (--child.referance === 0) {\n        child.destroy();\n      }\n    });\n\n    this.subscribers = [];\n    this.valueFn = NIL;\n    this.cache = NIL;\n    this.children = [];\n    this.cache = {};\n\n    _.each(this.observers, function (observer) {\n      if (observer.env.observers[observer.origin] && observer.env.observers[observer.origin][observer.path]) {\n        delete observer.env.observers[observer.origin][observer.path][observer.index];\n      }\n      delete observer.env;\n    });\n\n    this.observers = null;\n  }\n};\n\nexports.default = LazyValue;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.registerPartial = exports.registerHelper = undefined;\n\nvar _hooks = require(\"rebound-htmlbars/hooks\");\n\nvar _hooks2 = _interopRequireDefault(_hooks);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar registerHelper = exports.registerHelper = _hooks2.default.registerHelper;\nvar registerPartial = exports.registerPartial = _hooks2.default.registerPartial;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = render;\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _hooks2 = require(\"rebound-htmlbars/hooks\");\n\nvar _hooks3 = _interopRequireDefault(_hooks2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar RENDER_TIMEOUT;\nvar TO_RENDER = [];\nvar ENV_QUEUE = [];\n\n// A convenience method to push only unique eleents in an array of objects to\n// the TO_RENDER queue. If the element is a Lazy Value, it marks it as dirty in\n// the process\nvar push = function push(arr) {\n  var _this = this;\n\n  var i,\n      len = arr.length;\n  this.added || (this.added = {});\n  arr.forEach(function (item) {\n    if (_this.added[item.cid]) {\n      return;\n    }\n    _this.added[item.cid] = 1;\n    if (item.isLazyValue) {\n      item.makeDirty();\n    }\n    _this.push(item);\n  });\n};\n\nfunction reslot(env) {\n\n  // Fix for stupid Babel module importer\n  // TODO: Fix this. This is dumb. Modules don't resolve in by time of this file's\n  // execution because of the dependancy tree so babel doesn't get a chance to\n  // interop the default value of these imports. We need to do this at runtime instead.\n  var hooks = _hooks3.default.default || _hooks3.default;\n\n  var outlet,\n      slots = env.root.options && env.root.options[_reboundUtils.REBOUND_SYMBOL];\n\n  if (!env.root || !slots) {\n    return;\n  }\n\n  // Walk the dom, without traversing into other custom elements, and search for\n  // `<content>` outlets to render templates into.\n  (0, _reboundUtils.$)(env.root.el).walkTheDOM(function (el) {\n    if (env.root.el === el) {\n      return true;\n    }\n    if (el.tagName === 'CONTENT') {\n      outlet = el;\n    }\n    if (el.tagName.indexOf('-') > -1) {\n      return false;\n    }\n    return true;\n  });\n\n  // If a `<content>` outlet is present in component's template, and a template\n  // is provided, render it into the outlet\n  if (slots.templates.default && _.isElement(outlet) && !outlet.slotted) {\n    outlet.slotted = true;\n    (0, _reboundUtils.$)(outlet).empty();\n    outlet.appendChild(hooks.buildRenderResult(slots.templates.default, slots.env, slots.scope, {}).fragment);\n  }\n}\n\n// Called on animation frame. TO_RENDER is a list of lazy-values to notify.\n// When notified, they mark themselves as dirty. Then, call revalidate on all\n// dirty expressions for each environment we need to re-render. Use `while(queue.length)`\n// to accomodate synchronous renders where the render queue callbacks may trigger\n// nested calls of `renderCallback`.\nfunction renderCallback() {\n\n  while (TO_RENDER.length) {\n    TO_RENDER.shift().notify();\n  }\n\n  TO_RENDER.added = {};\n\n  while (ENV_QUEUE.length) {\n    var env = ENV_QUEUE.shift();\n    for (var key in env.revalidateQueue) {\n      env.revalidateQueue[key].revalidate();\n    }\n    reslot(env);\n  }\n  ENV_QUEUE.added = {};\n}\n\n// Listens for `change` events and calls `trigger` with the correct values\nfunction onChange(model, options) {\n  trigger.call(this, 'change', model, model.changedAttributes());\n}\n\n// Listens for `reset` events and calls `trigger` with the correct values\nfunction onReset(data, options) {\n  trigger.call(this, 'reset', data, data.isModel ? data.changedAttributes() : { '@each': data }, options);\n}\n\n// Listens for `update` events and calls `trigger` with the correct values\nfunction onUpdate(collection, options) {\n  trigger.call(this, 'update', collection, { '@each': collection }, options);\n}\n\nfunction trigger(type, data, changed) {\n  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n  // If nothing has changed, exit.\n  if (!data || !changed) {\n    return void 0;\n  }\n\n  var basePath = data.__path();\n\n  // If this event came from within a service, include the service key in the base path\n  if (options.service) {\n    basePath = options.service + '.' + basePath;\n  }\n\n  // For each changed key, walk down the data tree from the root to the data\n  // element that triggered the event and add all relevent callbacks to this\n  // object's TO_RENDER queue.\n  basePath = basePath.replace(/\\[[^\\]]+\\]/g, \".@each\");\n  var parts = _reboundUtils.$.splitPath(basePath);\n  var context = [];\n\n  while (1) {\n    var pre = context.join('.').trim();\n    var post = parts.join('.').trim();\n\n    for (var key in changed) {\n      var path = (post + (post && key && '.') + key).trim();\n      for (var testPath in this.env.observers[pre]) {\n        if (_reboundUtils.$.startsWith(testPath, path)) {\n          push.call(TO_RENDER, this.env.observers[pre][testPath]);\n          push.call(ENV_QUEUE, [this.env]);\n        }\n      }\n    }\n    if (parts.length === 0) {\n      break;\n    }\n    context.push(parts.shift());\n  }\n\n  // If Rebound is loaded in a testing environment, call renderCallback syncronously\n  // so that changes to the data reflect in the DOM immediately.\n  // TODO: Make tests async so this is not required\n  if (window.Rebound && window.Rebound.testing) {\n    return renderCallback();\n  }\n\n  // Otherwise, queue our render callback to be called on the next animation frame,\n  // after the current call stack has been exhausted.\n  window.cancelAnimationFrame(RENDER_TIMEOUT);\n  RENDER_TIMEOUT = window.requestAnimationFrame(renderCallback);\n}\n\n// A render function that will merge user provided helpers and hooks with our defaults\n// and bind a method that re-renders dirty expressions on data change and executes\n// other delegated listeners added by our hooks.\nfunction render(el, template, data) {\n  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n  // Fix for stupid Babel module importer\n  // TODO: Fix this. This is dumb. Modules don't resolve in by time of this file's\n  // execution because of the dependancy tree so babel doesn't get a chance to\n  // interop the default value of these imports. We need to do this at runtime instead.\n  var hooks = _hooks3.default.default || _hooks3.default;\n\n  // If no data is passed to render, exit with an error\n  if (!data) {\n    return console.error('No data passed to render function.');\n  }\n\n  // Every component's template is rendered using a unique Environment and Scope\n  // If this component already has them, re-use the same objects they contain\n  // important state information. Otherwise, create fresh ones for it.\n  var env = data.env || hooks.createFreshEnv();\n  var scope = data.scope || hooks.createFreshScope();\n\n  // Bind the component as the scope's main data object\n  hooks.bindSelf(env, scope, data);\n\n  // Add template specific hepers to env\n  _.extend(env.helpers, options.helpers);\n\n  // Save env and scope on component data to trigger lazy-value streams on data change\n  data.env = env;\n  data.scope = scope;\n\n  // Save data on env to allow helpers / hooks access to component methods\n  env.root = data;\n\n  // Ensure we have a contextual element to pass to render\n  options.contextualElement || (options.contextualElement = data.el || document.body);\n  options.self = data;\n\n  // If data is an eventable object, run the onChange helper on any change\n  if (data.listenTo) {\n    data.stopListening(null, null, onChange).stopListening(null, null, onReset).stopListening(null, null, onUpdate);\n    data.listenTo(data, 'change', onChange).listenTo(data, 'reset', onReset).listenTo(data, 'update', onUpdate);\n  }\n\n  // If this is a real template, run it with our merged helpers and hooks\n  // If there is no template, just return an empty fragment\n  env.template = template ? hooks.buildRenderResult(template, env, scope, options) : { fragment: document.createDocumentFragment() };\n  (0, _reboundUtils.$)(el).empty();\n  el.appendChild(env.template.fragment);\n  reslot(env);\n  return el;\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _reboundUtils = require('rebound-utils/rebound-utils');\n\nvar _reboundUtils2 = _interopRequireDefault(_reboundUtils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar MODULE_CACHE = {};\n\nvar loader = {\n\n  // If this JS element is not on the page already, it hasn't been loaded before -\n  // create the element and load the JS resource.\n  // Else if the JS resource has been loaded before, resolve with the element\n\n  loadJS: function loadJS(url, id) {\n\n    // Always return a promise for a load request\n    return new Promise(function (resolve, reject) {\n\n      // If we have already tried to load this js module, resolve or reject appropreately\n      if (MODULE_CACHE[url]) {\n        if (_.isElement(MODULE_CACHE[url]) && MODULE_CACHE[url].hasAttribute('data-error')) {\n          return reject();\n        }\n        return resolve(MODULE_CACHE[url]);\n      }\n\n      // Construct the script element and save it in the `MODULE_CACHE`\n      var e = document.createElement('script');\n      e.setAttribute('type', 'text/javascript');\n      e.setAttribute('src', url);\n      e.setAttribute('id', id || _.uniqueId('module'));\n      MODULE_CACHE[url] = e;\n\n      // All browsers support loading events on `<script>` elements, bind to these\n      // events and resolve our promise appropreately\n      (0, _reboundUtils2.default)(e).on('load', function () {\n        resolve(this);\n      });\n      (0, _reboundUtils2.default)(e).on('error', function (err) {\n        reject(err);\n      });\n\n      // And add it do to the dom\n      document.head.appendChild(e);\n    });\n  },\n\n  // If this CSS element is not on the page already, it hasn't been loaded before -\n  // create the element and load the CSS resource.\n  // Else if the CSS resource has been loaded before, resolve with the element\n  loadCSS: function loadCSS(url, id) {\n\n    // Always return a promise for a load request\n    return new Promise(function (resolve, reject) {\n\n      // If we have already tried to load this js module, resolve or reject appropreately\n      if (MODULE_CACHE[url]) {\n        if (_.isElement(MODULE_CACHE[url]) && MODULE_CACHE[url].hasAttribute('data-error')) {\n          return reject();\n        }\n        return resolve(MODULE_CACHE[url]);\n      }\n\n      // Construct our `<link>` element.\n      var e = document.createElement('link');\n      e.setAttribute('type', 'text/css');\n      e.setAttribute('rel', 'stylesheet');\n      e.setAttribute('href', url);\n      e.setAttribute('id', id);\n      MODULE_CACHE[url] = e;\n\n      // Older browsers and phantomJS < 2.0 don't support the onLoad event for\n      // `<link>` tags. Poll stylesheets array as a fallback. Timeout at 5s.\n      var count = 0,\n          ti = setInterval(function () {\n        for (var i = 0; i < document.styleSheets.length; i++) {\n          count = count + 50;\n          if ((document.styleSheets[i].href || '').indexOf(url) > -1) {\n            successCallback();\n          } else if (count >= 5000) {\n            errorCallback('CSS Timeout');\n          }\n        }\n      }, 50);\n\n      // On successful load, clearInterval and resolve.\n      // On failed load, clearInterval and reject.\n      var successCallback = function successCallback() {\n        clearInterval(ti);\n        resolve(e);\n      };\n      var errorCallback = function errorCallback(err) {\n        clearInterval(ti);\n        e.setAttribute('data-error', '');\n        reject(err);\n      };\n\n      // Modern browsers support loading events on `<link>` elements, bind these\n      // events. These will be callsed before our interval is called and they will\n      // clearInterval so the resolve/reject handlers aren't called twice.\n      (0, _reboundUtils2.default)(e).on('load', successCallback);\n      (0, _reboundUtils2.default)(e).on('error', errorCallback);\n      (0, _reboundUtils2.default)(e).on('readystatechange', function () {\n        clearInterval(ti);\n      });\n\n      // Add our `<link>` element to the page.\n      document.head.appendChild(e);\n    });\n  },\n\n  // Load multiple dependancies\n  // Given an array of dependancy urls, add them all to the head in their own script tags\n  load: function load(deps) {\n    if (!deps) {\n      return void 0;\n    }\n    deps = _.isArray(deps) ? deps : [deps];\n\n    // For each dependancy passed, call loadJS\n    deps.forEach(function (url) {\n      url = url.trim();\n      url = '/' + url + '.js';\n      loader.loadJS(url);\n    });\n  },\n  register: function register(url) {\n    MODULE_CACHE[url] = true;\n  }\n};\n\nexports.default = loader;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.services = exports.Router = undefined;\n\nvar _backbone = require(\"backbone\");\n\nvar _backbone2 = _interopRequireDefault(_backbone);\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _reboundUtils2 = _interopRequireDefault(_reboundUtils);\n\nvar _service = require(\"rebound-router/service\");\n\nvar _component = require(\"rebound-component/component\");\n\nvar _component2 = _interopRequireDefault(_component);\n\nvar _factory = require(\"rebound-component/factory\");\n\nvar _factory2 = _interopRequireDefault(_factory);\n\nvar _loader = require(\"rebound-router/loader\");\n\nvar _loader2 = _interopRequireDefault(_loader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// If no error page is defined for an app, this is the default 404 page\n// Rebound Router\n// ----------------\n\nvar DEFAULT_404_PAGE = \"<div style=\\\"display: block;text-align: center;font-size: 22px;\\\">\\n  <h1 style=\\\"margin-top: 60px;\\\">\\n    Oops! We couldn't find this page.\\n  </h1>\\n  <a href=\\\"#\\\" onclick=\\\"window.history.back();return false;\\\" style=\\\"display: block;text-decoration: none;margin-top: 30px;\\\">\\n    Take me back\\n  </a>\\n</div>\";\n\nvar ERROR_ROUTE_NAME = 'error';\nvar SUCCESS = 'success';\nvar ERROR = 'error';\nvar LOADING = 'loading';\n\n// Regexp to validate remote URLs\nvar IS_REMOTE_URL = /^([a-z]+:)|^(\\/\\/)|^([^\\/]+\\.)/;\nvar STRIP_SLASHES = /(^\\/+|\\/+$)/mg;\n\nfunction normalizeUrl() {\n  var url = '';\n  var args = Array.prototype.slice.call(arguments);\n  args.forEach(function (val) {\n    if (!val || val === '/') {\n      return void 0;\n    }\n    url += '/' + val.replace(STRIP_SLASHES, '');\n  });\n  return url || '/';\n}\n\n// Overload Backbone's loadUrl so it returns the value of the routed callback\n// Only ever compare the current path (excludes the query params) to the route regexp\n_backbone2.default.history.loadUrl = function (fragment) {\n  var key,\n      resp = false;\n  this.fragment = this.getFragment(fragment).split('?')[0];\n  for (key in this.handlers) {\n    if (this.handlers[key].route.test(this.fragment)) {\n      return this.handlers[key].callback(this.fragment);\n    }\n  }\n};\n\n// Remove the hash up to a `?` character. In IE9, which does not support the\n// History API, we need to allow query params to be set both on the URL itself\n// and in the hash, giving precedence to the query params in the URL.\n_backbone2.default.history.getSearch = function () {\n  var match = this.location.href.replace(/#[^\\?]*/, '').match(/\\?.+/);\n  return match ? match[0] : '';\n};\n\n// Router Constructor\nvar Router = _backbone2.default.Router.extend({\n\n  status: SUCCESS, // loading, success or error\n  _currentRoute: '', // The route path that triggered the current page\n  _previousRoute: '',\n\n  // By default there is one route. The wildcard route fetches the required\n  // page assets based on user-defined naming convention.\n  routes: {\n    '*route': 'wildcardRoute'\n  },\n\n  _loadDeps: _loader2.default.load,\n\n  // Called when no matching routes are found. Extracts root route and fetches it's resources\n  wildcardRoute: function wildcardRoute(route) {\n\n    // Save the previous route value\n    this._previousRoute = this._currentRoute;\n\n    // Fetch Resources\n    document.body.classList.add(\"loading\");\n    return this._fetchResource(route, this.config.container).then(function (res) {\n      document.body.classList.remove('loading');\n      return res;\n    });\n  },\n\n  // Modify navigate to default to `trigger=true` and to return the value of\n  // `Backbone.history.navigate` inside of a promise.\n  navigate: function navigate(fragment) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    // Default trigger to true unless otherwise specified\n    options.trigger === undefined && (options.trigger = true);\n\n    // Stringify any data passed in the options hash\n    var query = options.data ? (~fragment.indexOf('?') ? '&' : '?') + _reboundUtils2.default.url.query.stringify(options.data) : '';\n\n    // Un-Mark any `active` links in the page container\n    var $container = (0, _reboundUtils2.default)(this.config.containers).unMarkLinks();\n\n    // Navigate to the specified path. Return value is the value from the router\n    // callback specified on the component\n    var resp = _backbone2.default.history.navigate(fragment + query, options);\n\n    // Always return a promise. If the response of `Backbone.histroy.navigate`\n    // was a promise, wait for it to resolve before resolving. Once resolved,\n    // mark relevent links on the page as `active`.\n    return new Promise(function (resolve, reject) {\n      if (resp && resp.constructor === Promise) resp.then(resolve, resolve);\n      resolve(resp);\n    }).then(function (resp) {\n      $container.markLinks();\n      return resp;\n    });\n  },\n\n  // Modify `router.execute` to return the value of our route callback\n  execute: function execute(callback, args, name) {\n    if (callback) {\n      return callback.apply(this, args);\n    }\n  },\n\n  // Override routeToRegExp so:\n  //  - If key is a stringified regexp literal, convert to a regexp object\n  //  - Else If route is a string, proxy right through\n  _routeToRegExp: function _routeToRegExp(route) {\n    var res;\n\n    if (route[0] === '/' && route[route.length - 1] === '/') {\n      res = new RegExp(route.slice(1, route.length - 1), '');\n      res._isRegexp = true;\n    } else if (typeof route == 'string') {\n      res = _backbone2.default.Router.prototype._routeToRegExp.call(this, route);\n      res._isString = true;\n    }\n\n    return res;\n  },\n\n  // Override route so if callback returns false, the route event is not triggered\n  // Every route also looks for query params, parses with QS, and passes the extra\n  // variable as a POJO to callbacks\n  route: function route(_route, name, callback) {\n    var _this = this;\n\n    if (_.isFunction(name)) {\n      callback = name;\n      name = '';\n    }\n\n    if (!_.isRegExp(_route)) {\n      _route = this._routeToRegExp(_route);\n    }\n\n    if (!callback) {\n      callback = this[name];\n    }\n    _backbone2.default.history.route(_route, function (fragment) {\n\n      // If this route was defined as a regular expression, we don't capture\n      // query params. Only parse the actual path.\n      fragment = fragment.split('?')[0];\n\n      // Extract the arguments we care about from the fragment\n      var args = _this._extractParameters(_route, fragment);\n\n      // Get the query params string\n      var search = (_backbone2.default.history.getSearch() || '').slice(1);\n\n      // If this route was created from a string (not a regexp), remove the auto-captured\n      // search params.\n      if (_route._isString) {\n        args.pop();\n      }\n\n      // If the route is not user prodided, if the history object has search params\n      // then our args have the params as its last agrument as of Backbone 1.2.0\n      // If the route is a user provided regex, add in parsed search params from\n      // the history object before passing to the callback.\n      args.push(search ? _reboundUtils2.default.url.query.parse(search) : {});\n\n      var resp = _this.execute(callback, args, name);\n      if (resp !== false) {\n        _this.trigger.apply(_this, ['route:' + name].concat(args));\n        _this.trigger('route', name, args);\n        _backbone2.default.history.trigger('route', _this, name, args);\n      }\n      return resp;\n    });\n    return this;\n  },\n\n  // On startup, save our config object and start the router\n  initialize: function initialize() {\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n    var callback = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];\n\n    // Let all of our components always have referance to our router\n    _component2.default.prototype.router = this;\n\n    // Save our config referance\n    this.config = options;\n    this.config.handlers = [];\n    this.config.containers = [];\n\n    // Normalize our url configs\n    this.config.root = normalizeUrl(this.config.root);\n    this.config.assetRoot = this.config.assetRoot ? normalizeUrl(this.config.assetRoot) : this.config.root;\n    this.config.jsPath = normalizeUrl(this.config.assetRoot, this.config.jsPath);\n    this.config.cssPath = normalizeUrl(this.config.assetRoot, this.config.cssPath);\n\n    // Get a unique instance id for this router\n    this.uid = _reboundUtils2.default.uniqueId('router');\n\n    // Allow user to override error route\n    this.config.errorRoute && (ERROR_ROUTE_NAME = this.config.errorRoute);\n\n    // Convert our routeMappings to regexps and push to our handlers\n    _.each(this.config.routeMapping, function (value, route) {\n      var regex = this._routeToRegExp(route);\n      this.config.handlers.unshift({ route: route, regex: regex, app: value });\n    }, this);\n\n    // Use the user provided container, or default to the closest `<main>` tag\n    this.config.container = (0, _reboundUtils2.default)(this.config.container || 'main')[0];\n    this.config.containers.push(this.config.container);\n    _service.SERVICES.page = new _service.ServiceLoader('page');\n\n    // Install our global components\n    _.each(this.config.services, function (selector, route) {\n      var container = (0, _reboundUtils2.default)(selector)[0] || document.createElement('span');\n      this.config.containers.push(container);\n      _service.SERVICES[route] = new _service.ServiceLoader(route);\n      this._fetchResource(route, container).catch(function () {});\n    }, this);\n\n    // Watch click events on links in all out containers\n    this._watchLinks(this.config.containers);\n\n    // Start the history and call the provided callback\n    _backbone2.default.history.start({\n      pushState: this.config.pushState === undefined ? true : this.config.pushState,\n      root: this.config.root || ''\n    }).then(callback);\n\n    return this;\n  },\n\n  stop: function stop() {\n    (0, _reboundUtils2.default)(this.config.container).off('click');\n    _backbone2.default.history.stop();\n    this._uninstallResource();\n    _backbone2.default.history.handlers = [];\n  },\n\n  // Given a dom element, watch for all click events on anchor tags.\n  // If the clicked anchor has a relative url, attempt to route to that path.\n  // Give all links on the page that match this path the class `active`.\n  _watchLinks: function _watchLinks(container) {\n    var _this2 = this;\n\n    // Navigate to route for any link with a relative href\n    (0, _reboundUtils2.default)(container).on('click', 'a', function (e) {\n      var path = e.target.getAttribute('href');\n\n      // If the path is a remote URL, allow the browser to navigate normally.\n      // Otherwise, prevent default so we can handle the route event.\n      if (IS_REMOTE_URL.test(path) || path === '#') {\n        return void 0;\n      }\n      e.preventDefault();\n\n      // If this is not our current route, navigate to the new route\n      if (path !== '/' + _backbone2.default.history.fragment) {\n        _this2.navigate(path, { trigger: true });\n      }\n    });\n  },\n\n  // De-initializes the previous app before rendering a new app\n  // This way we can ensure that every new page starts with a clean slate\n  // This is crucial for scalability of a single page app.\n  _uninstallResource: function _uninstallResource() {\n    var _this3 = this;\n\n    var routes = this.current ? this.current.data.routes || {} : {};\n    routes[this._previousRoute] = '';\n\n    // Unset Previous Application's Routes. For each route in the page app, remove\n    // the handler from our route object and delete our referance to the route's callback\n    _.each(routes, function (value, key) {\n      var regExp = _this3._routeToRegExp(key).toString();\n      _backbone2.default.history.handlers = _.filter(_backbone2.default.history.handlers, function (obj) {\n        return obj.route.toString() !== regExp;\n      });\n    });\n\n    if (!this.current) {\n      return void 0;\n    }\n\n    var oldPageName = this.current.__pageId;\n\n    // Un-hook Event Bindings, Delete Objects\n    this.current.data.deinitialize();\n\n    // Now we no longer have a page installed.\n    this.current = undefined;\n\n    // Disable old css if it exists\n    setTimeout(function () {\n      if (_this3.status === ERROR) {\n        return void 0;\n      }\n      document.getElementById(oldPageName + '-css').setAttribute('disabled', true);\n    }, 500);\n  },\n\n  // Give our new page component, load routes and render a new instance of the\n  // page component in the top level outlet.\n  _installResource: function _installResource(PageApp, appName, container) {\n    var _this4 = this;\n\n    var oldPageName,\n        pageInstance,\n        routes = [];\n    var isService = container !== this.config.container;\n    var name = isService ? appName : 'page';\n\n    // If no container exists, throw an error\n    if (!container) throw 'No container found on the page! Please specify a container that exists in your Rebound config.';\n\n    // Add page level loading class\n    container.classList.remove('error', 'loading');\n\n    // Uninstall any old resource we have loaded\n    if (!isService && this.current) {\n      this._uninstallResource();\n    }\n\n    // Load New PageApp, give it it's name so we know what css to remove when it deinitializes\n    pageInstance = (0, _factory2.default)(PageApp).el;\n    if (_service.SERVICES[name].isLazyComponent) {\n      _service.SERVICES[name].hydrate(pageInstance.data);\n    } else {\n      _service.SERVICES[name] = pageInstance.data;\n    }\n    pageInstance.__pageId = this.uid + '-' + appName;\n\n    // Add to our page\n    (0, _reboundUtils2.default)(container).empty();\n    container.appendChild(pageInstance);\n\n    // Make sure we're back at the top of the page\n    document.body.scrollTop = 0;\n\n    // Add a default route handler for the route that got us here so if the component\n    // does not define a route that handles it, we don't get a redirect loop\n    if (!isService) {\n      this.route(this._currentRoute, 'default', function () {\n        return void 0;\n      });\n    }\n\n    // Augment ApplicationRouter with new routes from PageApp added in reverse order to preserve order higherarchy\n    _.each(pageInstance.data.routes, function (value, key) {\n      // Add the new callback referance on to our router and add the route handler\n      _this4.route(key, value, function () {\n        return pageInstance.data[value].apply(pageInstance.data, arguments);\n      });\n    });\n\n    // If this is the main page component, set it as current\n    if (!isService) {\n      this.current = pageInstance;\n    }\n\n    // Always return a promise\n    return new Promise(function (resolve, reject) {\n\n      // Re-trigger route so the newly added route may execute if there's a route match.\n      // If no routes are matched, app will hit wildCard route which will then trigger 404\n      if (!isService) {\n        var res = _backbone2.default.history.loadUrl(_backbone2.default.history.fragment);\n        if (res && typeof res.then === 'function') return res.then(resolve);\n        return resolve(res);\n      }\n      // Return our newly installed app\n      return resolve(pageInstance);\n    });\n  },\n\n  _fetchJavascript: function _fetchJavascript(routeName, appName) {\n    var jsID = this.uid + '-' + appName + '-route',\n        jsUrl = this.config.jsPath.replace(/:route/g, routeName).replace(/:app/g, appName);\n\n    // Load the JavaScript.\n    return _loader2.default.loadJS(jsUrl, jsID);\n  },\n\n  _fetchCSS: function _fetchCSS(routeName, appName) {\n\n    var cssID = this.uid + '-' + appName + '-css',\n        cssUrl = this.config.cssPath.replace(/:route/g, routeName).replace(/:app/g, appName);\n\n    // Load the CSS\n    return _loader2.default.loadCSS(cssUrl, cssID);\n  },\n\n  // Fetches HTML and CSS\n  _fetchResource: function _fetchResource(route, container) {\n    var _this5 = this;\n\n    var appName,\n        routeName,\n        isService = container !== this.config.container,\n        isError = route === ERROR_ROUTE_NAME;\n\n    // Normalize Route\n    route || (route = '');\n\n    // Get the app name from this route\n    appName = routeName = route.split('/')[0] || 'index';\n\n    // If this isn't the error route, Find Any Custom Route Mappings\n    if (!isService && !isError) {\n      this._currentRoute = route.split('/')[0];\n      _.any(this.config.handlers, function (handler) {\n        if (handler.regex.test(route)) {\n          appName = handler.app;\n          _this5._currentRoute = handler.route;\n          return true;\n        }\n      });\n    }\n\n    // Wrap these async resource fetches in a promise and return it.\n    // This promise resolves when both css and js resources are loaded\n    // It rejects if either of the css or js resources fails to load.\n    return new Promise(function (resolve, reject) {\n\n      var throwError = function throwError(err) {\n        // If we are already in an error state, this means we were unable to load\n        // a custom error page. Uninstall anything we have and insert our default 404 page.\n        if (_this5.status === ERROR) {\n          if (isService) return resolve(err);\n          _this5._uninstallResource();\n          container.innerHTML = DEFAULT_404_PAGE;\n          return resolve(err);\n        }\n\n        // Set our status to error and attempt to load a custom error page.\n        console.error('Could not ' + (isService ? 'load the ' + appName + ' service:' : 'find the ' + (appName || 'index') + ' app.'), 'at', '/' + route);\n        _this5.status = ERROR;\n        _this5._currentRoute = route;\n        resolve(_this5._fetchResource(ERROR_ROUTE_NAME, container));\n      };\n\n      // If the values we got from installing our resources are unexpected, 404\n      // Otherwise, set status, activate the css, and install the page component\n      var install = function install(response) {\n        var cssElement = response[0],\n            jsElement = response[1];\n        if (!(cssElement instanceof Element) || !(jsElement instanceof Element)) return throwError();\n        !isService && !isError && (_this5.status = SUCCESS);\n        cssElement && cssElement.removeAttribute('disabled');\n        _this5._installResource(jsElement.getAttribute('data-name'), appName, container).then(resolve, resolve);\n      };\n\n      // If loading a page, set status to loading\n      !isService && !isError && (_this5.status = LOADING);\n\n      // If Page Is Already Loaded Then The Route Does Not Exist. 404 and Exit.\n      if (_this5.current && _this5.current.__pageId === _this5.uid + '-' + appName) {\n        return throwError();\n      }\n\n      // Fetch our css and js in paralell, install or throw when both complete\n      Promise.all([_this5._fetchCSS(routeName, appName), _this5._fetchJavascript(routeName, appName)]).then(install, throwError);\n    });\n  }\n});\n\nexports.default = Router;\nexports.Router = Router;\nexports.services = _service.SERVICES;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SERVICES = exports.ServiceLoader = undefined;\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\n// Services cache of all installed services\nvar SERVICES = {};\n\n// Services keep track of their consumers. LazyComponent are placeholders\n// for services that haven't loaded yet. A LazyComponent mimics the api of a\n// real service/component (they are the same), and when the service finally\n// loads, its ```hydrate``` method is called. All consumers of the service will\n// have the now fully loaded service set, the LazyService will transfer all of\n// its consumers over to the fully loaded service, and then commit seppiku,\n// destroying itself.\nfunction ServiceLoader(type, options) {\n  var loadCallbacks = [];\n  this.name = type;\n  this.cid = _reboundUtils.$.uniqueId('ServiceLoader');\n  this.isHydrated = false;\n  this.isComponent = true;\n  this.isModel = true;\n  this.isLazyComponent = true;\n  this.attributes = {};\n  this.consumers = [];\n  this.set = this.on = this.off = function () {\n    return 1;\n  };\n  this.get = function (path) {\n    return path ? undefined : this;\n  };\n  this.hydrate = function (service) {\n    SERVICES[this.name] = service;\n    this._component = service;\n    _.each(this.consumers, function (consumer) {\n      var component = consumer.component,\n          key = consumer.key;\n      if (component.attributes && component.set) {\n        component.set(key, service);\n      }\n      if (component.services) {\n        component.services[key] = service;\n      }\n      if (component.defaults) {\n        component.defaults[key] = service;\n      }\n    });\n    service.consumers = this.consumers;\n\n    // Call all of our onLoad callbacks\n    _.each(loadCallbacks, function (cb) {\n      cb(service);\n    });\n    delete this.loadCallbacks;\n  };\n  this.onLoad = function (cb) {\n    loadCallbacks.push(cb);\n  };\n}\n\nexports.ServiceLoader = ServiceLoader;\nexports.SERVICES = SERVICES;","'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }; // Rebound AJAX\n// ----------------\n\n// Rebound includes its own ajax method so that it not dependant on a largeer library\n// like jQuery. Here we expose the `ajax` method which mirrors jQuery's ajax API.\n// This methods is added to Rebound's internal utility library and used throughout the framework.\n// Inspiration: http://krasimirtsonev.com/blog/article/Cross-browser-handling-of-Ajax-requests-in-absurdjs\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = ajax;\n\nvar _urls = require('rebound-utils/urls');\n\nfunction ajax(ops) {\n    if (typeof ops == 'string') ops = { url: ops };\n    ops.url = ops.url || '';\n    ops.json = ops.json || true;\n    ops.method = ops.method || 'get';\n    ops.data = ops.data || {};\n    var api = {\n        host: {},\n        process: function process(ops) {\n            var self = this;\n            this.xhr = null;\n            if (window.ActiveXObject) {\n                this.xhr = new ActiveXObject('Microsoft.XMLHTTP');\n            } else if (window.XMLHttpRequest) {\n                this.xhr = new XMLHttpRequest();\n            }\n            if (this.xhr) {\n                this.xhr.onreadystatechange = function () {\n                    if (self.xhr.readyState == 4 && self.xhr.status == 200) {\n                        var result = self.xhr.responseText;\n                        if (ops.json === true && typeof JSON != 'undefined') {\n                            result = JSON.parse(result);\n                        }\n                        self.doneCallback && self.doneCallback.apply(self.host, [result, self.xhr]);\n                        ops.success && ops.success.apply(self.host, [result, self.xhr]);\n                    } else if (self.xhr.readyState == 4) {\n                        self.failCallback && self.failCallback.apply(self.host, [self.xhr]);\n                        ops.error && ops.error.apply(self.host, [self.xhr]);\n                    }\n                    self.alwaysCallback && self.alwaysCallback.apply(self.host, [self.xhr]);\n                    ops.complete && ops.complete.apply(self.host, [self.xhr]);\n                };\n            }\n            if (ops.method == 'get') {\n                this.xhr.open(\"GET\", ops.url + _urls.query.stringify(ops.data), true);\n                this.setHeaders({\n                    'X-Requested-With': 'XMLHttpRequest'\n                });\n            } else {\n                this.xhr.open(ops.method, ops.url, true);\n                this.setHeaders({\n                    'X-Requested-With': 'XMLHttpRequest',\n                    'Content-type': 'application/x-www-form-urlencoded'\n                });\n            }\n            if (ops.headers && _typeof(ops.headers) == 'object') {\n                this.setHeaders(ops.headers);\n            }\n            setTimeout(function () {\n                ops.method == 'get' ? self.xhr.send() : self.xhr.send(_urls.query.stringify(ops.data));\n            }, 20);\n            return this.xhr;\n        },\n        done: function done(callback) {\n            this.doneCallback = callback;\n            return this;\n        },\n        fail: function fail(callback) {\n            this.failCallback = callback;\n            return this;\n        },\n        always: function always(callback) {\n            this.alwaysCallback = callback;\n            return this;\n        },\n        setHeaders: function setHeaders(headers) {\n            for (var name in headers) {\n                this.xhr && this.xhr.setRequestHeader(name, headers[name]);\n            }\n        }\n    };\n    return api.process(ops);\n}","\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.trigger = trigger;\nexports.off = off;\nexports.on = on;\n// Rebound DOM Events\n// ----------------\n\n// Rebound includes its own event binding and delegation helpers so the framework\n// is not dependant on a large DOM library like jQuery. Here we expose `on`,\n// `off` and `trigger` methods that mirror jQuery's events API for both native and\n// custom event types. These methods are added to Rebound's internal utility library\n// and used throughout the framework. AddEventListener supports IE9+\n\n// Events registry. An object containing all events bound through this util shared among all instances.\nvar EVENT_CACHE = {};\n\n// Make only single copies of these functions so they aren't creted repeatedly.\nfunction returnFalse() {\n\treturn false;\n}\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction Event(src, props) {\n\t// Allow instantiation without the 'new' keyword\n\tif (!(this instanceof Event)) {\n\t\treturn new Event(src, props);\n\t}\n\n\t// If src is an Event object, save the original event object and event type\n\tif (src && src.type) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\t// Support: Android<4.0\n\t\tthis.isDefaultPrevented = src.defaultPrevented || src.returnValue === false ? returnTrue : returnFalse;\n\t}\n\n\t// Else if src is an Event type\n\telse {\n\t\t\tthis.type = src;\n\t\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif (props) {\n\t\t_.extend(this, props);\n\t}\n\n\t// Copy over all original event properties\n\t_.extend(this, _.pick(this.originalEvent, [\"altKey\", \"bubbles\", \"cancelable\", \"ctrlKey\", \"currentTarget\", \"eventPhase\", \"metaKey\", \"relatedTarget\", \"shiftKey\", \"target\", \"timeStamp\", \"view\", \"which\", \"char\", \"charCode\", \"key\", \"keyCode\", \"button\", \"buttons\", \"clientX\", \"clientY\", \"defaultPrevented\", \"offsetX\", \"offsetY\", \"pageX\", \"pageY\", \"screenX\", \"screenY\", \"toElement\"]));\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || new Date().getTime();\n\n\t// Mark it as fixed\n\tthis.isEvent = true;\n}\n\nEvent.prototype = {\n\tconstructor: Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\t// Call preventDefault on original event object.\n\tpreventDefault: function preventDefault() {\n\t\tvar e = this.originalEvent;\n\t\tthis.defaultPrevented = true;\n\t\tthis.isDefaultPrevented = returnTrue;\n\t\tif (e && e.preventDefault) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\n\t// Call stopPropagation on original event object.\n\tstopPropagation: function stopPropagation() {\n\t\tvar e = this.originalEvent;\n\t\tthis.isPropagationStopped = returnTrue;\n\t\tif (e && e.stopPropagation) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\n\t// Call stopImmediatePropagation on original event object and call stopPropagation.\n\tstopImmediatePropagation: function stopImmediatePropagation() {\n\t\tvar e = this.originalEvent;\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\tif (e && e.stopImmediatePropagation) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Given a delegate element, an event type, and a test element, test every delegate ID.\n// If it is the same as our test element's delegate ID, or if the test element matches\n// the delegate ID when it is used as a CSS selector, add the callback to the list of\n// callbacks to call.\nfunction getCallbacks(target, delegate, eventType) {\n\tvar callbacks = [];\n\tif (target.delegateGroup && EVENT_CACHE[target.delegateGroup][eventType]) {\n\t\t_.each(EVENT_CACHE[target.delegateGroup][eventType], function (callbacksList, delegateId) {\n\t\t\tif (_.isArray(callbacksList) && (delegateId === delegate.delegateId || delegate.matchesSelector && delegate.matchesSelector(delegateId))) {\n\t\t\t\tcallbacks = callbacks.concat(callbacksList);\n\t\t\t}\n\t\t});\n\t}\n\treturn callbacks;\n}\n\nfunction callback(event) {\n\tvar target = event.target,\n\t    falsy = false,\n\t    i,\n\t    len,\n\t    callbacks;\n\n\t// Convert native Event to mutable Event\n\tevent = new Event(event || window.event);\n\n\t// Travel from target up to parent firing event on delegate when it exists\n\twhile (target) {\n\n\t\t// Attach this level's target\n\t\tevent.target = event.srcElement = target;\n\n\t\t// Get all specified callbacks (element specific and selector specified)\n\t\tcallbacks = getCallbacks(this, target, event.type);\n\t\tlen = callbacks.length;\n\n\t\t// For each callback,\n\t\tfor (i = 0; i < len; i++) {\n\n\t\t\t// Call the callback\n\t\t\tevent.data = callbacks[i].data || {};\n\t\t\tevent.result = callbacks[i].handler.call(callbacks[i].el, event);\n\n\t\t\t// If any of the callbacks returned false, prevent default and stop propagation\n\t\t\tif (event.result === false) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\t\t}\n\n\t\t\t// If stopImmediatePropagation has been called, stop immediately\n\t\t\tif (event.isImmediatePropagationStopped()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// If stopPropagation has been called, stop immediately\n\t\tif (event.isPropagationStopped()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Bubble up to the next parent node and repeat\n\t\ttarget = target.parentNode;\n\t}\n}\n\n// Triggers an event on a given dom node\nfunction trigger(eventName, options) {\n\tvar el,\n\t    len = this.length;\n\twhile (len--) {\n\t\tel = this[len];\n\t\tif (document.createEvent) {\n\t\t\tvar event = document.createEvent('HTMLEvents');\n\t\t\tevent.initEvent(eventName, true, false);\n\t\t\tel.dispatchEvent(event);\n\t\t} else {\n\t\t\tel.fireEvent('on' + eventName);\n\t\t}\n\t}\n}\n\nfunction off(eventTypes, handler) {\n\tvar el,\n\t    len = this.length,\n\t    events;\n\teventTypes = eventTypes ? eventTypes.split(' ') : [];\n\n\t// For each selected element\n\twhile (len--) {\n\t\tel = this[len];\n\n\t\t// If this element is given a delegate ID has events directly bound to it\n\t\tif (el.delegateGroup && EVENT_CACHE[el.delegateGroup]) {\n\n\t\t\t// For each event type specified (if no event types are passed, iterate over all events)\n\t\t\tevents = eventTypes.length ? eventTypes : Object.keys(EVENT_CACHE[el.delegateGroup]);\n\t\t\t_.each(events, function (eventName) {\n\t\t\t\tvar newCallbacks,\n\t\t\t\t    delegate,\n\t\t\t\t    eventCount = 0,\n\t\t\t\t    eventsList = EVENT_CACHE[el.delegateGroup][eventName];\n\n\t\t\t\tfor (delegate in eventsList) {\n\t\t\t\t\tif (!eventsList.hasOwnProperty(delegate) || !_.isArray(eventsList[delegate])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnewCallbacks = [];\n\t\t\t\t\teventsList[delegate].forEach(function (callback, index) {\n\t\t\t\t\t\tif (callback.handler === handler || !handler) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewCallbacks.push(callback);\n\t\t\t\t\t});\n\t\t\t\t\teventsList[delegate] = newCallbacks;\n\t\t\t\t\teventCount = eventsList[delegate].length;\n\t\t\t\t}\n\n\t\t\t\t// If there are no more of this event type delegated for this group, remove the listener\n\t\t\t\tif (eventCount === 0) {\n\t\t\t\t\tel.removeEventListener(eventName, callback, eventName === 'focus' || eventName === 'blur');\n\t\t\t\t\tdelete EVENT_CACHE[el.delegateGroup][eventName];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\nfunction on(eventName, delegate, data, handler) {\n\tvar _this = this;\n\n\tvar len = this.length,\n\t    eventNames = eventName.split(' '),\n\t    delegateId,\n\t    delegateGroup;\n\n\t// The `on` method takes one of three forms: `on(eventName, [delegate, data,] handler)`\n\t//  - If second param is a function, use that as our handler.\n\t//  - If third param is a function, use that as our handler and the second param as the delegate selector\n\t//  - If fourth param is a function, use that as our handler, the second param as the delegate selector, and the third params as the data object.\n\tif (_.isFunction(delegate)) {\n\t\thandler = delegate;data = {};delegate = void 0;\n\t} else if (_.isFunction(data)) {\n\t\thandler = data;data = {};delegate || (delegate = void 0);\n\t} else if (_.isFunction(handler)) {\n\t\tdata || (data = {});delegate || (delegate = void 0);\n\t} else {\n\t\treturn console.error(\"No handler passed to Rebound's $.on\");\n\t}\n\n\tvar _loop = function _loop() {\n\t\tvar el = _this[len];\n\t\tdelegate = delegate || _this.selector || el;\n\n\t\t// If our delegate selector is not a string or element, show an error.\n\t\tif (!_.isString(delegate) && !_.isElement(delegate)) {\n\t\t\treturn {\n\t\t\t\tv: console.error(\"Delegate value passed to Rebound's $.on is neither an element or css selector\")\n\t\t\t};\n\t\t}\n\n\t\tdelegateId = _.isString(delegate) ? delegate : delegate.delegateId = delegate.delegateId || _this.uniqueId('event');\n\t\tdelegateGroup = el.delegateGroup = el.delegateGroup || _this.uniqueId('delegateGroup');\n\n\t\t_.each(eventNames, function (eventName) {\n\n\t\t\t// Ensure event obj existance\n\t\t\tEVENT_CACHE[delegateGroup] = EVENT_CACHE[delegateGroup] || {};\n\n\t\t\t// If this is the first event of its type, add an event handler.\n\t\t\t// Because we're only ever attaching one listener per event type, this is okay.\n\t\t\t// This also allows our trigger method to actually fire delegated events\n\t\t\t// If event is focus or blur, use capture to allow for event delegation.\n\t\t\tif (!EVENT_CACHE[delegateGroup][eventName]) {\n\t\t\t\tel.addEventListener(eventName, callback, eventName === 'focus' || eventName === 'blur');\n\t\t\t}\n\n\t\t\t// Add our listener\n\t\t\tEVENT_CACHE[delegateGroup][eventName] = EVENT_CACHE[delegateGroup][eventName] || {};\n\t\t\tEVENT_CACHE[delegateGroup][eventName][delegateId] = EVENT_CACHE[delegateGroup][eventName][delegateId] || [];\n\t\t\tEVENT_CACHE[delegateGroup][eventName][delegateId].push({\n\t\t\t\tel: el,\n\t\t\t\thandler: handler,\n\t\t\t\tdata: data\n\t\t\t});\n\t\t}, _this);\n\t};\n\n\twhile (len--) {\n\t\tvar _ret = _loop();\n\n\t\tif ((typeof _ret === \"undefined\" ? \"undefined\" : _typeof(_ret)) === \"object\") return _ret.v;\n\t}\n}\n\nexports.default = { on: on, off: off, trigger: trigger };","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$ = exports.REBOUND_SYMBOL = undefined;\n\nvar _backbone = require(\"backbone\");\n\nvar _backbone2 = _interopRequireDefault(_backbone);\n\nvar _urls = require(\"rebound-utils/urls\");\n\nvar _ajax = require(\"rebound-utils/ajax\");\n\nvar _ajax2 = _interopRequireDefault(_ajax);\n\nvar _events = require(\"rebound-utils/events\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Rebound Utils\n// ----------------\n\nvar ID_COUNTERS = {};\n\nvar REBOUND_SYMBOL = exports.REBOUND_SYMBOL = '__REBOUND_SYMBOL_PROPERTY_NAME__';\n\nvar $ = exports.$ = function $(query) {\n\n  var i,\n      selector = [];\n\n  // Allow instantiation without the 'new' keyword\n  if (!(this instanceof $)) {\n    return new $(query);\n  }\n\n  // Ensure query is an array\n  query = _.isArray(query) ? query : [query];\n\n  // For each query in query array: If it is an element, push it to the selectors\n  // array. If it is a string, push all elements that match to selectors array.\n  _.each(query, function (item, index) {\n    if (_.isElement(item) || item === document || item === window || item instanceof DocumentFragment) {\n      selector.push(item);\n    }\n    // Call slice to convert node list to array for push. Save selector used.\n    else if (_.isString(item)) {\n        this.selector = item;\n        Array.prototype.push.apply(selector, Array.prototype.slice.call(document.querySelectorAll(item)));\n      }\n  }, this);\n\n  // Cache the length of our matched elements\n  this.length = selector.length;\n\n  // Add selector to object for method chaining\n  for (i = 0; i < this.length; i++) {\n    this[i] = selector[i];\n  }\n};\n\n// Add url utils\n$.url = { query: _urls.query };\n\n// Add ajax util\n$.ajax = _ajax2.default;\n\n// Add event utils\n$.prototype.trigger = _events2.default.trigger;\n$.prototype.on = _events2.default.on;\n$.prototype.off = _events2.default.off;\n\n// Generate a unique integer id (unique within the entire client session).\n$.uniqueId = $.prototype.uniqueId = function uniqueId() {\n  var prefix = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n  ID_COUNTERS.hasOwnProperty(prefix) || (ID_COUNTERS[prefix] = 0);\n  return prefix + ++ID_COUNTERS[prefix];\n};\n\n// Applies function `func` depth first to every node in the subtree starting from `root`\n// If the callback returns `false`, short circuit that tree.\n$.prototype.walkTheDOM = function walkTheDOM(func) {\n  var el,\n      root,\n      len = this.length,\n      result;\n  while (len--) {\n    root = this[len];\n    result = func(root);\n    if (result === false) {\n      return void 0;\n    }\n    root = root.firstChild;\n    while (root) {\n      $(root).walkTheDOM(func);\n      root = root.nextSibling;\n    }\n  }\n};\n\n$.prototype.unMarkLinks = function unMarkLinks() {\n  var len = this.length;\n  while (len--) {\n    var links = this[len].querySelectorAll('a');\n    for (var i = 0; i < links.length; i++) {\n      links.item(i).classList.remove('active');\n      links.item(i).active = false;\n    }\n  }\n  return this;\n};\n\n$.prototype.markLinks = function markLinks() {\n  var len = this.length;\n  while (len--) {\n    var links = this[len].querySelectorAll('a[href=\"/' + _backbone2.default.history.fragment + '\"]');\n    for (var i = 0; i < links.length; i++) {\n      links.item(i).classList.add('active');\n      links.item(i).active = true;\n    }\n  }\n  return this;\n};\n\n// Empty all selected nodes\n$.prototype.empty = function empty() {\n  var len = this.length;\n  while (len--) {\n    while (this[len].hasChildNodes()) {\n      this[len].removeChild(this[len].firstChild);\n    }\n  }\n  return this;\n};\n\n// Given a valid data path, split it into an array of its parts.\n// ex: foo.bar[0].baz --> ['foo', 'var', '0', 'baz']\n$.splitPath = function splitPath(path) {\n  path = ('.' + path + '.').split(/(?:\\.|\\[|\\])+/);\n  path.pop();\n  path.shift();\n  return path;\n};\n\n// Searches each key in an object and tests if the property has a lookupGetter or\n// lookupSetter. If either are preset convert the property into a computed property.\n$.extractComputedProps = function extractComputedProps(obj) {\n  for (var key in obj) {\n    var get = undefined,\n        set = undefined;\n    if (!obj.hasOwnProperty(key)) continue;\n    var desc = Object.getOwnPropertyDescriptor(obj, key);\n    get = desc.hasOwnProperty('get') && desc.get;\n    set = desc.hasOwnProperty('set') && desc.set;\n    if (get || set) {\n      delete obj[key];\n      obj[key] = { get: get, set: set, isComputedProto: true };\n    }\n  }\n};\n\n// Returns true if the data path `str` starts with `test`\n$.startsWith = function startsWith(str, test) {\n  if (str === test) return true;\n  str = $.splitPath(str);\n  test = $.splitPath(test);\n  while (test[0] && str[0]) {\n    if (str[0] !== test[0] && str[0] !== '@each' && test[0] !== '@each') return false;\n    test.shift();\n    str.shift();\n  }\n  return true;\n};\n\nexports.default = $;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.query = undefined;\n\nvar _qs = require(\"qs\");\n\nvar _qs2 = _interopRequireDefault(_qs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar QS_STRINGIFY_OPTS = {\n  allowDots: true,\n  encode: false,\n  delimiter: '&'\n};\n\nvar QS_PARSE_OPTS = {\n  allowDots: true,\n  delimiter: /[;,&]/\n};\n\nvar query = {\n  stringify: function stringify(str) {\n    return _qs2.default.stringify(str, QS_STRINGIFY_OPTS);\n  },\n  parse: function parse(obj) {\n    return _qs2.default.parse(obj, QS_PARSE_OPTS);\n  }\n};\n\nexports.query = query;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _backbone = require(\"backbone\");\n\nvar _backbone2 = _interopRequireDefault(_backbone);\n\nvar _reboundUtils = require(\"rebound-utils/rebound-utils\");\n\nvar _reboundUtils2 = _interopRequireDefault(_reboundUtils);\n\nvar _reboundData = require(\"rebound-data/rebound-data\");\n\nvar _reboundRouter = require(\"rebound-router/rebound-router\");\n\nvar _reboundHtmlbars = require(\"rebound-htmlbars/rebound-htmlbars\");\n\nvar _factory = require(\"rebound-component/factory\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Because of our bundle and how it plays with Backbone's UMD header, we need to\n// be a little more explicit with out DOM library search.\n//     Rebound.js v0.3.0\n\n//     (c) 2015 Adam Miller\n//     Rebound may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://reboundjs.com\n\n// Rebound Runtime\n// ----------------\n\n// Import Backbone\n_backbone2.default.$ = window.$;\n\n// If Backbone doesn't have an ajax method from an external DOM library, use ours\n\n// Load our **Utils**, helper environment, **Rebound Data**,\n// **Rebound Components** and the **Rebound Router**\n_backbone2.default.ajax = _backbone2.default.$ && _backbone2.default.$.ajax && _backbone2.default.ajax || _reboundUtils2.default.ajax;\n\n// Fetch Rebound's Config Object from Rebound's `script` tag\nvar Config = document.getElementById('Rebound');\nConfig = Config ? JSON.parse(Config.innerHTML) : false;\n\nvar Rebound = window.Rebound = {\n  version: '0.3.0',\n  testing: window.Rebound && window.Rebound.testing || Config && Config.testing || false,\n\n  registerHelper: _reboundHtmlbars.registerHelper,\n  registerPartial: _reboundHtmlbars.registerPartial,\n  registerComponent: _factory.registerComponent,\n\n  Component: _factory.ComponentFactory,\n  Model: _reboundData.Model,\n  Collection: _reboundData.Collection,\n  ComputedProperty: _reboundData.ComputedProperty,\n\n  history: _backbone2.default.history,\n  services: _reboundRouter.services,\n  start: function start(options) {\n    var R = this;\n    return new Promise(function (resolve, reject) {\n      var run = function run() {\n        if (!document.body) {\n          return setTimeout(run.bind(R), 1);\n        }\n        delete R.router;\n        R.router = new _reboundRouter.Router(options, resolve);\n      };\n      run();\n    });\n  },\n  stop: function stop() {\n    if (!this.router) return console.error('No running Rebound router found!');\n    this.router.stop();\n  }\n};\n\n// Start the router if a config object is preset\nif (Config) {\n  Rebound.start(Config);\n}\n\nexports.default = Rebound;","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts  that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n\"use strict\";\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nvar _state = _dereq_(\"./state\");\n\nvar pp = _state.Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp.checkPropClash = function (prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;\n  var key = prop.key;var name = undefined;\n  switch (key.type) {\n    case \"Identifier\":\n      name = key.name;break;\n    case \"Literal\":\n      name = String(key.value);break;\n    default:\n      return;\n  }\n  var kind = prop.kind;\n\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) this.raise(key.start, \"Redefinition of __proto__ property\");\n      propHash.proto = true;\n    }\n    return;\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var isGetSet = kind !== \"init\";\n    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raise(key.start, \"Redefinition of property\");\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp.parseExpression = function (noIn, refDestructuringErrors) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === _tokentype.types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));\n    return this.finishNode(node, \"SequenceExpression\");\n  }\n  return expr;\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.type == _tokentype.types._yield && this.inGenerator) return this.parseYield();\n\n  var validateDestructuring = false;\n  if (!refDestructuringErrors) {\n    refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };\n    validateDestructuring = true;\n  }\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);\n  if (this.type.isAssign) {\n    if (validateDestructuring) this.checkPatternErrors(refDestructuringErrors, true);\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;\n    refDestructuringErrors.shorthandAssign = 0; // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\");\n  } else {\n    if (validateDestructuring) this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  return left;\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp.parseMaybeConditional = function (noIn, refDestructuringErrors) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;\n  if (this.eat(_tokentype.types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(_tokentype.types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n  return expr;\n};\n\n// Start the precedence parser.\n\npp.parseExprOps = function (noIn, refDestructuringErrors) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;\n  return this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {\n    if (prec > minPrec) {\n      var node = this.startNodeAt(leftStartPos, leftStartLoc);\n      node.left = left;\n      node.operator = this.value;\n      var op = this.type;\n      this.next();\n      var startPos = this.start,\n          startLoc = this.startLoc;\n      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);\n      this.finishNode(node, op === _tokentype.types.logicalOR || op === _tokentype.types.logicalAND ? \"LogicalExpression\" : \"BinaryExpression\");\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n    }\n  }\n  return left;\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp.parseMaybeUnary = function (refDestructuringErrors) {\n  if (this.type.prefix) {\n    var node = this.startNode(),\n        update = this.type === _tokentype.types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary();\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") this.raise(node.start, \"Deleting local variable in strict mode\");\n    return this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  }\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseExprSubscripts(refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;\n  while (this.type.postfix && !this.canInsertSemicolon()) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.prefix = false;\n    node.argument = expr;\n    this.checkLVal(expr);\n    this.next();\n    expr = this.finishNode(node, \"UpdateExpression\");\n  }\n  return expr;\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp.parseExprSubscripts = function (refDestructuringErrors) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;\n  return this.parseSubscripts(expr, startPos, startLoc);\n};\n\npp.parseSubscripts = function (base, startPos, startLoc, noCalls) {\n  for (;;) {\n    if (this.eat(_tokentype.types.dot)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = this.parseIdent(true);\n      node.computed = false;\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (this.eat(_tokentype.types.bracketL)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = this.parseExpression();\n      node.computed = true;\n      this.expect(_tokentype.types.bracketR);\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this.eat(_tokentype.types.parenL)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.arguments = this.parseExprList(_tokentype.types.parenR, false);\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (this.type === _tokentype.types.backQuote) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.tag = base;\n      node.quasi = this.parseTemplate();\n      base = this.finishNode(node, \"TaggedTemplateExpression\");\n    } else {\n      return base;\n    }\n  }\n};\n\n// Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp.parseExprAtom = function (refDestructuringErrors) {\n  var node = undefined,\n      canBeArrow = this.potentialArrowAt == this.start;\n  switch (this.type) {\n    case _tokentype.types._super:\n      if (!this.inFunction) this.raise(this.start, \"'super' outside of function or class\");\n    case _tokentype.types._this:\n      var type = this.type === _tokentype.types._this ? \"ThisExpression\" : \"Super\";\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, type);\n\n    case _tokentype.types._yield:\n      if (this.inGenerator) this.unexpected();\n\n    case _tokentype.types.name:\n      var startPos = this.start,\n          startLoc = this.startLoc;\n      var id = this.parseIdent(this.type !== _tokentype.types.name);\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);\n      return id;\n\n    case _tokentype.types.regexp:\n      var value = this.value;\n      node = this.parseLiteral(value.value);\n      node.regex = { pattern: value.pattern, flags: value.flags };\n      return node;\n\n    case _tokentype.types.num:case _tokentype.types.string:\n      return this.parseLiteral(this.value);\n\n    case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:\n      node = this.startNode();\n      node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;\n      node.raw = this.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\");\n\n    case _tokentype.types.parenL:\n      return this.parseParenAndDistinguishExpression(canBeArrow);\n\n    case _tokentype.types.bracketL:\n      node = this.startNode();\n      this.next();\n      // check whether this is array comprehension or regular array\n      if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {\n        return this.parseComprehension(node, false);\n      }\n      node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refDestructuringErrors);\n      return this.finishNode(node, \"ArrayExpression\");\n\n    case _tokentype.types.braceL:\n      return this.parseObj(false, refDestructuringErrors);\n\n    case _tokentype.types._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, false);\n\n    case _tokentype.types._class:\n      return this.parseClass(this.startNode(), false);\n\n    case _tokentype.types._new:\n      return this.parseNew();\n\n    case _tokentype.types.backQuote:\n      return this.parseTemplate();\n\n    default:\n      this.unexpected();\n  }\n};\n\npp.parseLiteral = function (value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  this.next();\n  return this.finishNode(node, \"Literal\");\n};\n\npp.parseParenExpression = function () {\n  this.expect(_tokentype.types.parenL);\n  var val = this.parseExpression();\n  this.expect(_tokentype.types.parenR);\n  return val;\n};\n\npp.parseParenAndDistinguishExpression = function (canBeArrow) {\n  var startPos = this.start,\n      startLoc = this.startLoc,\n      val = undefined;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {\n      return this.parseComprehension(this.startNodeAt(startPos, startLoc), true);\n    }\n\n    var innerStartPos = this.start,\n        innerStartLoc = this.startLoc;\n    var exprList = [],\n        first = true;\n    var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 },\n        spreadStart = undefined,\n        innerParenStart = undefined;\n    while (this.type !== _tokentype.types.parenR) {\n      first ? first = false : this.expect(_tokentype.types.comma);\n      if (this.type === _tokentype.types.ellipsis) {\n        spreadStart = this.start;\n        exprList.push(this.parseParenItem(this.parseRest()));\n        break;\n      } else {\n        if (this.type === _tokentype.types.parenL && !innerParenStart) {\n          innerParenStart = this.start;\n        }\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start,\n        innerEndLoc = this.startLoc;\n    this.expect(_tokentype.types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, true);\n      if (innerParenStart) this.unexpected(innerParenStart);\n      return this.parseParenArrowList(startPos, startLoc, exprList);\n    }\n\n    if (!exprList.length) this.unexpected(this.lastTokStart);\n    if (spreadStart) this.unexpected(spreadStart);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\");\n  } else {\n    return val;\n  }\n};\n\npp.parseParenItem = function (item) {\n  return item;\n};\n\npp.parseParenArrowList = function (startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call  at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty = [];\n\npp.parseNew = function () {\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {\n    node.meta = meta;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\") this.raise(node.property.start, \"The only valid meta property for new is new.target\");\n    if (!this.inFunction) this.raise(node.start, \"new.target can only be used in functions\");\n    return this.finishNode(node, \"MetaProperty\");\n  }\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty;\n  return this.finishNode(node, \"NewExpression\");\n};\n\n// Parse template expression.\n\npp.parseTemplateElement = function () {\n  var elem = this.startNode();\n  elem.value = {\n    raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, '\\n'),\n    cooked: this.value\n  };\n  this.next();\n  elem.tail = this.type === _tokentype.types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\");\n};\n\npp.parseTemplate = function () {\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement();\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    this.expect(_tokentype.types.dollarBraceL);\n    node.expressions.push(this.parseExpression());\n    this.expect(_tokentype.types.braceR);\n    node.quasis.push(curElt = this.parseTemplateElement());\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\");\n};\n\n// Parse an object literal or binding pattern.\n\npp.parseObj = function (isPattern, refDestructuringErrors) {\n  var node = this.startNode(),\n      first = true,\n      propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(_tokentype.types.braceR)) {\n    if (!first) {\n      this.expect(_tokentype.types.comma);\n      if (this.afterTrailingComma(_tokentype.types.braceR)) break;\n    } else first = false;\n\n    var prop = this.startNode(),\n        isGenerator = undefined,\n        startPos = undefined,\n        startLoc = undefined;\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false;\n      prop.shorthand = false;\n      if (isPattern || refDestructuringErrors) {\n        startPos = this.start;\n        startLoc = this.startLoc;\n      }\n      if (!isPattern) isGenerator = this.eat(_tokentype.types.star);\n    }\n    this.parsePropertyName(prop);\n    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);\n    this.checkPropClash(prop, propHash);\n    node.properties.push(this.finishNode(prop, \"Property\"));\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n};\n\npp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {\n  if (this.eat(_tokentype.types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {\n    if (isPattern) this.unexpected();\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator);\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) {\n    if (isGenerator || isPattern) this.unexpected();\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\") this.raise(start, \"getter should have no params\");else this.raise(start, \"setter should have exactly one param\");\n    }\n    if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") this.raise(prop.value.params[0].start, \"Setter cannot use rest params\");\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    prop.kind = \"init\";\n    if (isPattern) {\n      if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name)) this.raise(prop.key.start, \"Binding \" + prop.key.name);\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === _tokentype.types.eq && refDestructuringErrors) {\n      if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start;\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else this.unexpected();\n};\n\npp.parsePropertyName = function (prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(_tokentype.types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(_tokentype.types.bracketR);\n      return prop.key;\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);\n};\n\n// Initialize empty function node.\n\npp.initFunction = function (node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n};\n\n// Parse object or class method.\n\npp.parseMethod = function (isGenerator) {\n  var node = this.startNode();\n  this.initFunction(node);\n  this.expect(_tokentype.types.parenL);\n  node.params = this.parseBindingList(_tokentype.types.parenR, false, false);\n  if (this.options.ecmaVersion >= 6) node.generator = isGenerator;\n  this.parseFunctionBody(node, false);\n  return this.finishNode(node, \"FunctionExpression\");\n};\n\n// Parse arrow function expression with given parameters.\n\npp.parseArrowExpression = function (node, params) {\n  this.initFunction(node);\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true);\n  return this.finishNode(node, \"ArrowFunctionExpression\");\n};\n\n// Parse function body and check parameters.\n\npp.parseFunctionBody = function (node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n  } else {\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldInFunc = this.inFunction,\n        oldInGen = this.inGenerator,\n        oldLabels = this.labels;\n    this.inFunction = true;this.inGenerator = node.generator;this.labels = [];\n    node.body = this.parseBlock(true);\n    node.expression = false;\n    this.inFunction = oldInFunc;this.inGenerator = oldInGen;this.labels = oldLabels;\n  }\n\n  // If this is a strict mode function, verify that argument names\n  // are not repeated, and it does not try to bind the words `eval`\n  // or `arguments`.\n  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {\n    var oldStrict = this.strict;\n    this.strict = true;\n    if (node.id) this.checkLVal(node.id, true);\n    this.checkParams(node);\n    this.strict = oldStrict;\n  } else if (isArrowFunction) {\n    this.checkParams(node);\n  }\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp.checkParams = function (node) {\n  var nameHash = {};\n  for (var i = 0; i < node.params.length; i++) {\n    this.checkLVal(node.params[i], true, nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var elts = [],\n      first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(_tokentype.types.comma);\n      if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) {\n        refDestructuringErrors.trailingComma = this.lastTokStart;\n      }\n      if (allowTrailingComma && this.afterTrailingComma(close)) break;\n    } else first = false;\n\n    var elt = undefined;\n    if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refDestructuringErrors);else elt = this.parseMaybeAssign(false, refDestructuringErrors);\n    elts.push(elt);\n  }\n  return elts;\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp.parseIdent = function (liberal) {\n  var node = this.startNode();\n  if (liberal && this.options.allowReserved == \"never\") liberal = false;\n  if (this.type === _tokentype.types.name) {\n    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1)) this.raise(this.start, \"The keyword '\" + this.value + \"' is reserved\");\n    node.name = this.value;\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword;\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  return this.finishNode(node, \"Identifier\");\n};\n\n// Parses yield expression inside generator.\n\npp.parseYield = function () {\n  var node = this.startNode();\n  this.next();\n  if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(_tokentype.types.star);\n    node.argument = this.parseMaybeAssign();\n  }\n  return this.finishNode(node, \"YieldExpression\");\n};\n\n// Parses array and generator comprehensions.\n\npp.parseComprehension = function (node, isGenerator) {\n  node.blocks = [];\n  while (this.type === _tokentype.types._for) {\n    var block = this.startNode();\n    this.next();\n    this.expect(_tokentype.types.parenL);\n    block.left = this.parseBindingAtom();\n    this.checkLVal(block.left, true);\n    this.expectContextual(\"of\");\n    block.right = this.parseExpression();\n    this.expect(_tokentype.types.parenR);\n    node.blocks.push(this.finishNode(block, \"ComprehensionBlock\"));\n  }\n  node.filter = this.eat(_tokentype.types._if) ? this.parseParenExpression() : null;\n  node.body = this.parseExpression();\n  this.expect(isGenerator ? _tokentype.types.parenR : _tokentype.types.bracketR);\n  node.generator = isGenerator;\n  return this.finishNode(node, \"ComprehensionExpression\");\n};\n\n},{\"./state\":10,\"./tokentype\":14}],2:[function(_dereq_,module,exports){\n// This is a trick taken from Esprima. It turns out that, on\n// non-Chrome browsers, to check whether a string is in a set, a\n// predicate containing a big ugly `switch` statement is faster than\n// a regular expression, and on Chrome the two are about on par.\n// This function uses `eval` (non-lexical) to produce such a\n// predicate from a space-separated string of words.\n//\n// It starts by sorting the words by length.\n\n// Reserved word lists for various dialects of the language\n\n\"use strict\";\n\nexports.__esModule = true;\nexports.isIdentifierStart = isIdentifierStart;\nexports.isIdentifierChar = isIdentifierChar;\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\nexports.reservedWords = reservedWords;\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" let const class extends export import yield super\"\n};\n\nexports.keywords = keywords;\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\";\nvar nonASCIIidentifierChars = \"-------------------------------------------------------------------------------------------------------------------------------------------------\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by tools/generate-identifier-regex.js\nvar astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541];\nvar astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) return code === 36;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  if (astral === false) return false;\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  if (astral === false) return false;\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\n},{}],3:[function(_dereq_,module,exports){\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/ternjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/ternjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\n\"use strict\";\n\nexports.__esModule = true;\nexports.parse = parse;\nexports.parseExpressionAt = parseExpressionAt;\nexports.tokenizer = tokenizer;\n\nvar _state = _dereq_(\"./state\");\n\n_dereq_(\"./parseutil\");\n\n_dereq_(\"./statement\");\n\n_dereq_(\"./lval\");\n\n_dereq_(\"./expression\");\n\n_dereq_(\"./location\");\n\nexports.Parser = _state.Parser;\nexports.plugins = _state.plugins;\n\nvar _options = _dereq_(\"./options\");\n\nexports.defaultOptions = _options.defaultOptions;\n\nvar _locutil = _dereq_(\"./locutil\");\n\nexports.Position = _locutil.Position;\nexports.SourceLocation = _locutil.SourceLocation;\nexports.getLineInfo = _locutil.getLineInfo;\n\nvar _node = _dereq_(\"./node\");\n\nexports.Node = _node.Node;\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nexports.TokenType = _tokentype.TokenType;\nexports.tokTypes = _tokentype.types;\n\nvar _tokencontext = _dereq_(\"./tokencontext\");\n\nexports.TokContext = _tokencontext.TokContext;\nexports.tokContexts = _tokencontext.types;\n\nvar _identifier = _dereq_(\"./identifier\");\n\nexports.isIdentifierChar = _identifier.isIdentifierChar;\nexports.isIdentifierStart = _identifier.isIdentifierStart;\n\nvar _tokenize = _dereq_(\"./tokenize\");\n\nexports.Token = _tokenize.Token;\n\nvar _whitespace = _dereq_(\"./whitespace\");\n\nexports.isNewLine = _whitespace.isNewLine;\nexports.lineBreak = _whitespace.lineBreak;\nexports.lineBreakG = _whitespace.lineBreakG;\nvar version = \"2.7.0\";\n\nexports.version = version;\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new _state.Parser(options, input).parse();\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new _state.Parser(options, input, pos);\n  p.nextToken();\n  return p.parseExpression();\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new _state.Parser(options, input);\n}\n\n},{\"./expression\":1,\"./identifier\":2,\"./location\":4,\"./locutil\":5,\"./lval\":6,\"./node\":7,\"./options\":8,\"./parseutil\":9,\"./state\":10,\"./statement\":11,\"./tokencontext\":12,\"./tokenize\":13,\"./tokentype\":14,\"./whitespace\":16}],4:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _state = _dereq_(\"./state\");\n\nvar _locutil = _dereq_(\"./locutil\");\n\nvar pp = _state.Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp.raise = function (pos, message) {\n  var loc = _locutil.getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;\n  throw err;\n};\n\npp.curPosition = function () {\n  if (this.options.locations) {\n    return new _locutil.Position(this.curLine, this.pos - this.lineStart);\n  }\n};\n\n},{\"./locutil\":5,\"./state\":10}],5:[function(_dereq_,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.getLineInfo = getLineInfo;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _whitespace = _dereq_(\"./whitespace\");\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = (function () {\n  function Position(line, col) {\n    _classCallCheck(this, Position);\n\n    this.line = line;\n    this.column = col;\n  }\n\n  Position.prototype.offset = function offset(n) {\n    return new Position(this.line, this.column + n);\n  };\n\n  return Position;\n})();\n\nexports.Position = Position;\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  _classCallCheck(this, SourceLocation);\n\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) this.source = p.sourceFile;\n}\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\n;\n\nexports.SourceLocation = SourceLocation;\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    _whitespace.lineBreakG.lastIndex = cur;\n    var match = _whitespace.lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur);\n    }\n  }\n}\n\n},{\"./whitespace\":16}],6:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nvar _state = _dereq_(\"./state\");\n\nvar _util = _dereq_(\"./util\");\n\nvar pp = _state.Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp.toAssignable = function (node, isBinding) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (var i = 0; i < node.properties.length; i++) {\n          var prop = node.properties[i];\n          if (prop.kind !== \"init\") this.raise(prop.key.start, \"Object pattern can't contain getter or setter\");\n          this.toAssignable(prop.value, isBinding);\n        }\n        break;\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, isBinding);\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator === \"=\") {\n          node.type = \"AssignmentPattern\";\n          delete node.operator;\n          // falls through to AssignmentPattern\n        } else {\n            this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n            break;\n          }\n\n      case \"AssignmentPattern\":\n        if (node.right.type === \"YieldExpression\") this.raise(node.right.start, \"Yield expression cannot be a default value\");\n        break;\n\n      case \"ParenthesizedExpression\":\n        node.expression = this.toAssignable(node.expression, isBinding);\n        break;\n\n      case \"MemberExpression\":\n        if (!isBinding) break;\n\n      default:\n        this.raise(node.start, \"Assigning to rvalue\");\n    }\n  }\n  return node;\n};\n\n// Convert list of expression atoms to binding list.\n\npp.toAssignableList = function (exprList, isBinding) {\n  var end = exprList.length;\n  if (end) {\n    var last = exprList[end - 1];\n    if (last && last.type == \"RestElement\") {\n      --end;\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\";\n      var arg = last.argument;\n      this.toAssignable(arg, isBinding);\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\") this.unexpected(arg.start);\n      --end;\n    }\n\n    if (isBinding && last.type === \"RestElement\" && last.argument.type !== \"Identifier\") this.unexpected(last.argument.start);\n  }\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) this.toAssignable(elt, isBinding);\n  }\n  return exprList;\n};\n\n// Parses spread element.\n\npp.parseSpread = function (refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\");\n};\n\npp.parseRest = function (allowNonIdent) {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (allowNonIdent) node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();\n\n  return this.finishNode(node, \"RestElement\");\n};\n\n// Parses lvalue (assignable) atom.\n\npp.parseBindingAtom = function () {\n  if (this.options.ecmaVersion < 6) return this.parseIdent();\n  switch (this.type) {\n    case _tokentype.types.name:\n      return this.parseIdent();\n\n    case _tokentype.types.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\");\n\n    case _tokentype.types.braceL:\n      return this.parseObj(true);\n\n    default:\n      this.unexpected();\n  }\n};\n\npp.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {\n  var elts = [],\n      first = true;\n  while (!this.eat(close)) {\n    if (first) first = false;else this.expect(_tokentype.types.comma);\n    if (allowEmpty && this.type === _tokentype.types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break;\n    } else if (this.type === _tokentype.types.ellipsis) {\n      var rest = this.parseRest(allowNonIdent);\n      this.parseBindingListItem(rest);\n      elts.push(rest);\n      this.expect(close);\n      break;\n    } else {\n      var elem = this.parseMaybeDefault(this.start, this.startLoc);\n      this.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts;\n};\n\npp.parseBindingListItem = function (param) {\n  return param;\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp.parseMaybeDefault = function (startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\");\n};\n\n// Verify that a node is an lval  something that can be assigned\n// to.\n\npp.checkLVal = function (expr, isBinding, checkClashes) {\n  switch (expr.type) {\n    case \"Identifier\":\n      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raise(expr.start, (isBinding ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n      if (checkClashes) {\n        if (_util.has(checkClashes, expr.name)) this.raise(expr.start, \"Argument name clash\");\n        checkClashes[expr.name] = true;\n      }\n      break;\n\n    case \"MemberExpression\":\n      if (isBinding) this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\");\n      break;\n\n    case \"ObjectPattern\":\n      for (var i = 0; i < expr.properties.length; i++) {\n        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);\n      }break;\n\n    case \"ArrayPattern\":\n      for (var i = 0; i < expr.elements.length; i++) {\n        var elem = expr.elements[i];\n        if (elem) this.checkLVal(elem, isBinding, checkClashes);\n      }\n      break;\n\n    case \"AssignmentPattern\":\n      this.checkLVal(expr.left, isBinding, checkClashes);\n      break;\n\n    case \"RestElement\":\n      this.checkLVal(expr.argument, isBinding, checkClashes);\n      break;\n\n    case \"ParenthesizedExpression\":\n      this.checkLVal(expr.expression, isBinding, checkClashes);\n      break;\n\n    default:\n      this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n},{\"./state\":10,\"./tokentype\":14,\"./util\":15}],7:[function(_dereq_,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _state = _dereq_(\"./state\");\n\nvar _locutil = _dereq_(\"./locutil\");\n\nvar Node = function Node(parser, pos, loc) {\n  _classCallCheck(this, Node);\n\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);\n  if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;\n  if (parser.options.ranges) this.range = [pos, 0];\n}\n\n// Start an AST node, attaching a start offset.\n\n;\n\nexports.Node = Node;\nvar pp = _state.Parser.prototype;\n\npp.startNode = function () {\n  return new Node(this, this.start, this.startLoc);\n};\n\npp.startNodeAt = function (pos, loc) {\n  return new Node(this, pos, loc);\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations) node.loc.end = loc;\n  if (this.options.ranges) node.range[1] = pos;\n  return node;\n}\n\npp.finishNode = function (node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n};\n\n// Finish node at given position\n\npp.finishNodeAt = function (node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc);\n};\n\n},{\"./locutil\":5,\"./state\":10}],8:[function(_dereq_,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.getOptions = getOptions;\n\nvar _util = _dereq_(\"./util\");\n\nvar _locutil = _dereq_(\"./locutil\");\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, or 5, or 6. This influences support for strict\n  // mode, the set of reserved words, support for getters and\n  // setters and other features.\n  ecmaVersion: 5,\n  // Source type (\"script\" or \"module\") for different semantics\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callbackthat will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callbackthat will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n};\n\nexports.defaultOptions = defaultOptions;\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n  for (var opt in defaultOptions) {\n    options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];\n  }if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;\n\n  if (_util.isArray(options.onToken)) {\n    (function () {\n      var tokens = options.onToken;\n      options.onToken = function (token) {\n        return tokens.push(token);\n      };\n    })();\n  }\n  if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);\n\n  return options;\n}\n\nfunction pushComment(options, array) {\n  return function (block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? 'Block' : 'Line',\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);\n    if (options.ranges) comment.range = [start, end];\n    array.push(comment);\n  };\n}\n\n},{\"./locutil\":5,\"./util\":15}],9:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nvar _state = _dereq_(\"./state\");\n\nvar _whitespace = _dereq_(\"./whitespace\");\n\nvar pp = _state.Parser.prototype;\n\n// ## Parser utilities\n\n// Test whether a statement node is the string literal `\"use strict\"`.\n\npp.isUseStrict = function (stmt) {\n  return this.options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && stmt.expression.raw.slice(1, -1) === \"use strict\";\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function (type) {\n  if (this.type === type) {\n    this.next();\n    return true;\n  } else {\n    return false;\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function (name) {\n  return this.type === _tokentype.types.name && this.value === name;\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function (name) {\n  return this.value === name && this.eat(_tokentype.types.name);\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function (name) {\n  if (!this.eatContextual(name)) this.unexpected();\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function () {\n  return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n};\n\npp.insertSemicolon = function () {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n    return true;\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function () {\n  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();\n};\n\npp.afterTrailingComma = function (tokType) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n    this.next();\n    return true;\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function (type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function (pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\npp.checkPatternErrors = function (refDestructuringErrors, andThrow) {\n  var pos = refDestructuringErrors && refDestructuringErrors.trailingComma;\n  if (!andThrow) return !!pos;\n  if (pos) this.raise(pos, \"Trailing comma is not permitted in destructuring patterns\");\n};\n\npp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {\n  var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign;\n  if (!andThrow) return !!pos;\n  if (pos) this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\");\n};\n\n},{\"./state\":10,\"./tokentype\":14,\"./whitespace\":16}],10:[function(_dereq_,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _identifier = _dereq_(\"./identifier\");\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nvar _whitespace = _dereq_(\"./whitespace\");\n\nvar _options = _dereq_(\"./options\");\n\n// Registered plugins\nvar plugins = {};\n\nexports.plugins = plugins;\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(\" + words.replace(/ /g, \"|\") + \")$\");\n}\n\nvar Parser = (function () {\n  function Parser(options, input, startPos) {\n    _classCallCheck(this, Parser);\n\n    this.options = options = _options.getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n    var reserved = options.allowReserved ? \"\" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == \"module\" ? \" await\" : \"\");\n    this.reservedWords = keywordRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + _identifier.reservedWords.strict;\n    this.reservedWordsStrict = keywordRegexp(reservedStrict);\n    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + _identifier.reservedWords.strictBind);\n    this.input = String(input);\n\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false;\n\n    // Load plugins\n    this.loadPlugins(options.plugins);\n\n    // Set up token state\n\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n      this.pos = startPos;\n      this.lineStart = Math.max(0, this.input.lastIndexOf(\"\\n\", startPos));\n      this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;\n    } else {\n      this.pos = this.lineStart = 0;\n      this.curLine = 1;\n    }\n\n    // Properties of the current token:\n    // Its type\n    this.type = _tokentype.types.eof;\n    // For tokens that include more information than their type, the value\n    this.value = null;\n    // Its start and end offset\n    this.start = this.end = this.pos;\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition();\n\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext();\n    this.exprAllowed = true;\n\n    // Figure out if it's a module code.\n    this.strict = this.inModule = options.sourceType === \"module\";\n\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1;\n\n    // Flags to track whether we are in a function, a generator.\n    this.inFunction = this.inGenerator = false;\n    // Labels in scope.\n    this.labels = [];\n\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!') this.skipLineComment(2);\n  }\n\n  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\n\n  Parser.prototype.isKeyword = function isKeyword(word) {\n    return this.keywords.test(word);\n  };\n\n  Parser.prototype.isReservedWord = function isReservedWord(word) {\n    return this.reservedWords.test(word);\n  };\n\n  Parser.prototype.extend = function extend(name, f) {\n    this[name] = f(this[name]);\n  };\n\n  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {\n    for (var _name in pluginConfigs) {\n      var plugin = plugins[_name];\n      if (!plugin) throw new Error(\"Plugin '\" + _name + \"' not found\");\n      plugin(this, pluginConfigs[_name]);\n    }\n  };\n\n  Parser.prototype.parse = function parse() {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node);\n  };\n\n  return Parser;\n})();\n\nexports.Parser = Parser;\n\n},{\"./identifier\":2,\"./options\":8,\"./tokentype\":14,\"./whitespace\":16}],11:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nvar _state = _dereq_(\"./state\");\n\nvar _whitespace = _dereq_(\"./whitespace\");\n\nvar pp = _state.Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp.parseTopLevel = function (node) {\n  var first = true;\n  if (!node.body) node.body = [];\n  while (this.type !== _tokentype.types.eof) {\n    var stmt = this.parseStatement(true, true);\n    node.body.push(stmt);\n    if (first) {\n      if (this.isUseStrict(stmt)) this.setStrict(true);\n      first = false;\n    }\n  }\n  this.next();\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType;\n  }\n  return this.finishNode(node, \"Program\");\n};\n\nvar loopLabel = { kind: \"loop\" },\n    switchLabel = { kind: \"switch\" };\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp.parseStatement = function (declaration, topLevel) {\n  var starttype = this.type,\n      node = this.startNode();\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n    case _tokentype.types._break:case _tokentype.types._continue:\n      return this.parseBreakContinueStatement(node, starttype.keyword);\n    case _tokentype.types._debugger:\n      return this.parseDebuggerStatement(node);\n    case _tokentype.types._do:\n      return this.parseDoStatement(node);\n    case _tokentype.types._for:\n      return this.parseForStatement(node);\n    case _tokentype.types._function:\n      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();\n      return this.parseFunctionStatement(node);\n    case _tokentype.types._class:\n      if (!declaration) this.unexpected();\n      return this.parseClass(node, true);\n    case _tokentype.types._if:\n      return this.parseIfStatement(node);\n    case _tokentype.types._return:\n      return this.parseReturnStatement(node);\n    case _tokentype.types._switch:\n      return this.parseSwitchStatement(node);\n    case _tokentype.types._throw:\n      return this.parseThrowStatement(node);\n    case _tokentype.types._try:\n      return this.parseTryStatement(node);\n    case _tokentype.types._let:case _tokentype.types._const:\n      if (!declaration) this.unexpected(); // NOTE: falls through to _var\n    case _tokentype.types._var:\n      return this.parseVarStatement(node, starttype);\n    case _tokentype.types._while:\n      return this.parseWhileStatement(node);\n    case _tokentype.types._with:\n      return this.parseWithStatement(node);\n    case _tokentype.types.braceL:\n      return this.parseBlock();\n    case _tokentype.types.semi:\n      return this.parseEmptyStatement(node);\n    case _tokentype.types._export:\n    case _tokentype.types._import:\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel) this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n        if (!this.inModule) this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n      }\n      return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n    default:\n      var maybeName = this.value,\n          expr = this.parseExpression();\n      if (starttype === _tokentype.types.name && expr.type === \"Identifier\" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);\n  }\n};\n\npp.parseBreakContinueStatement = function (node, keyword) {\n  var isBreak = keyword == \"break\";\n  this.next();\n  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  for (var i = 0; i < this.labels.length; ++i) {\n    var lab = this.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n      if (node.label && isBreak) break;\n    }\n  }\n  if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword);\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n};\n\npp.parseDebuggerStatement = function (node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\");\n};\n\npp.parseDoStatement = function (node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  this.expect(_tokentype.types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();\n  return this.finishNode(node, \"DoWhileStatement\");\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp.parseForStatement = function (node) {\n  this.next();\n  this.labels.push(loopLabel);\n  this.expect(_tokentype.types.parenL);\n  if (this.type === _tokentype.types.semi) return this.parseFor(node, null);\n  if (this.type === _tokentype.types._var || this.type === _tokentype.types._let || this.type === _tokentype.types._const) {\n    var _init = this.startNode(),\n        varKind = this.type;\n    this.next();\n    this.parseVar(_init, true, varKind);\n    this.finishNode(_init, \"VariableDeclaration\");\n    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && _init.declarations.length === 1 && !(varKind !== _tokentype.types._var && _init.declarations[0].init)) return this.parseForIn(node, _init);\n    return this.parseFor(node, _init);\n  }\n  var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) {\n    this.checkPatternErrors(refDestructuringErrors, true);\n    this.toAssignable(init);\n    this.checkLVal(init);\n    return this.parseForIn(node, init);\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  return this.parseFor(node, init);\n};\n\npp.parseFunctionStatement = function (node) {\n  this.next();\n  return this.parseFunction(node, true);\n};\n\npp.parseIfStatement = function (node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  node.consequent = this.parseStatement(false);\n  node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;\n  return this.finishNode(node, \"IfStatement\");\n};\n\npp.parseReturnStatement = function (node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, \"'return' outside of function\");\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {\n    node.argument = this.parseExpression();this.semicolon();\n  }\n  return this.finishNode(node, \"ReturnStatement\");\n};\n\npp.parseSwitchStatement = function (node) {\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(_tokentype.types.braceL);\n  this.labels.push(switchLabel);\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) {\n    if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {\n      var isCase = this.type === _tokentype.types._case;\n      if (cur) this.finishNode(cur, \"SwitchCase\");\n      node.cases.push(cur = this.startNode());\n      cur.consequent = [];\n      this.next();\n      if (isCase) {\n        cur.test = this.parseExpression();\n      } else {\n        if (sawDefault) this.raise(this.lastTokStart, \"Multiple default clauses\");\n        sawDefault = true;\n        cur.test = null;\n      }\n      this.expect(_tokentype.types.colon);\n    } else {\n      if (!cur) this.unexpected();\n      cur.consequent.push(this.parseStatement(true));\n    }\n  }\n  if (cur) this.finishNode(cur, \"SwitchCase\");\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\");\n};\n\npp.parseThrowStatement = function (node) {\n  this.next();\n  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\");\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp.parseTryStatement = function (node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === _tokentype.types._catch) {\n    var clause = this.startNode();\n    this.next();\n    this.expect(_tokentype.types.parenL);\n    clause.param = this.parseBindingAtom();\n    this.checkLVal(clause.param, true);\n    this.expect(_tokentype.types.parenR);\n    clause.body = this.parseBlock();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer) this.raise(node.start, \"Missing catch or finally clause\");\n  return this.finishNode(node, \"TryStatement\");\n};\n\npp.parseVarStatement = function (node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\");\n};\n\npp.parseWhileStatement = function (node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\");\n};\n\npp.parseWithStatement = function (node) {\n  if (this.strict) this.raise(this.start, \"'with' in strict mode\");\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(false);\n  return this.finishNode(node, \"WithStatement\");\n};\n\npp.parseEmptyStatement = function (node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\");\n};\n\npp.parseLabeledStatement = function (node, maybeName, expr) {\n  for (var i = 0; i < this.labels.length; ++i) {\n    if (this.labels[i].name === maybeName) this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  }var kind = this.type.isLoop ? \"loop\" : this.type === _tokentype.types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label = this.labels[i];\n    if (label.statementStart == node.start) {\n      label.statementStart = this.start;\n      label.kind = kind;\n    } else break;\n  }\n  this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });\n  node.body = this.parseStatement(true);\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\");\n};\n\npp.parseExpressionStatement = function (node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\");\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp.parseBlock = function (allowStrict) {\n  var node = this.startNode(),\n      first = true,\n      oldStrict = undefined;\n  node.body = [];\n  this.expect(_tokentype.types.braceL);\n  while (!this.eat(_tokentype.types.braceR)) {\n    var stmt = this.parseStatement(true);\n    node.body.push(stmt);\n    if (first && allowStrict && this.isUseStrict(stmt)) {\n      oldStrict = this.strict;\n      this.setStrict(this.strict = true);\n    }\n    first = false;\n  }\n  if (oldStrict === false) this.setStrict(false);\n  return this.finishNode(node, \"BlockStatement\");\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp.parseFor = function (node, init) {\n  node.init = init;\n  this.expect(_tokentype.types.semi);\n  node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();\n  this.expect(_tokentype.types.semi);\n  node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();\n  this.expect(_tokentype.types.parenR);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\");\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp.parseForIn = function (node, init) {\n  var type = this.type === _tokentype.types._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n  node.left = init;\n  node.right = this.parseExpression();\n  this.expect(_tokentype.types.parenR);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, type);\n};\n\n// Parse a list of variable declarations.\n\npp.parseVar = function (node, isFor, kind) {\n  node.declarations = [];\n  node.kind = kind.keyword;\n  for (;;) {\n    var decl = this.startNode();\n    this.parseVarId(decl);\n    if (this.eat(_tokentype.types.eq)) {\n      decl.init = this.parseMaybeAssign(isFor);\n    } else if (kind === _tokentype.types._const && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n      this.unexpected();\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this.type === _tokentype.types._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    if (!this.eat(_tokentype.types.comma)) break;\n  }\n  return node;\n};\n\npp.parseVarId = function (decl) {\n  decl.id = this.parseBindingAtom();\n  this.checkLVal(decl.id, true);\n};\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp.parseFunction = function (node, isStatement, allowExpressionBody) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);\n  if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody);\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n};\n\npp.parseFunctionParams = function (node) {\n  this.expect(_tokentype.types.parenL);\n  node.params = this.parseBindingList(_tokentype.types.parenR, false, false, true);\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp.parseClass = function (node, isStatement) {\n  this.next();\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(_tokentype.types.braceL);\n  while (!this.eat(_tokentype.types.braceR)) {\n    if (this.eat(_tokentype.types.semi)) continue;\n    var method = this.startNode();\n    var isGenerator = this.eat(_tokentype.types.star);\n    var isMaybeStatic = this.type === _tokentype.types.name && this.value === \"static\";\n    this.parsePropertyName(method);\n    method[\"static\"] = isMaybeStatic && this.type !== _tokentype.types.parenL;\n    if (method[\"static\"]) {\n      if (isGenerator) this.unexpected();\n      isGenerator = this.eat(_tokentype.types.star);\n      this.parsePropertyName(method);\n    }\n    method.kind = \"method\";\n    var isGetSet = false;\n    if (!method.computed) {\n      var key = method.key;\n\n      if (!isGenerator && key.type === \"Identifier\" && this.type !== _tokentype.types.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true;\n        method.kind = key.name;\n        key = this.parsePropertyName(method);\n      }\n      if (!method[\"static\"] && (key.type === \"Identifier\" && key.name === \"constructor\" || key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) this.raise(key.start, \"Duplicate constructor in the same class\");\n        if (isGetSet) this.raise(key.start, \"Constructor can't have get/set modifier\");\n        if (isGenerator) this.raise(key.start, \"Constructor can't be a generator\");\n        method.kind = \"constructor\";\n        hadConstructor = true;\n      }\n    }\n    this.parseClassMethod(classBody, method, isGenerator);\n    if (isGetSet) {\n      var paramCount = method.kind === \"get\" ? 0 : 1;\n      if (method.value.params.length !== paramCount) {\n        var start = method.value.start;\n        if (method.kind === \"get\") this.raise(start, \"getter should have no params\");else this.raise(start, \"setter should have exactly one param\");\n      }\n      if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\") this.raise(method.value.params[0].start, \"Setter cannot use rest params\");\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n};\n\npp.parseClassMethod = function (classBody, method, isGenerator) {\n  method.value = this.parseMethod(isGenerator);\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n};\n\npp.parseClassId = function (node, isStatement) {\n  node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;\n};\n\npp.parseClassSuper = function (node) {\n  node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp.parseExport = function (node) {\n  this.next();\n  // export * from '...'\n  if (this.eat(_tokentype.types.star)) {\n    this.expectContextual(\"from\");\n    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\");\n  }\n  if (this.eat(_tokentype.types._default)) {\n    // export default ...\n    var expr = this.parseMaybeAssign();\n    var needsSemi = true;\n    if (expr.type == \"FunctionExpression\" || expr.type == \"ClassExpression\") {\n      needsSemi = false;\n      if (expr.id) {\n        expr.type = expr.type == \"FunctionExpression\" ? \"FunctionDeclaration\" : \"ClassDeclaration\";\n      }\n    }\n    node.declaration = expr;\n    if (needsSemi) this.semicolon();\n    return this.finishNode(node, \"ExportDefaultDeclaration\");\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true);\n    node.specifiers = [];\n    node.source = null;\n  } else {\n    // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers();\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();\n    } else {\n      // check for keywords used as local names\n      for (var i = 0; i < node.specifiers.length; i++) {\n        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {\n          this.unexpected(node.specifiers[i].local.start);\n        }\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\");\n};\n\npp.shouldParseExportStatement = function () {\n  return this.type.keyword;\n};\n\n// Parses a comma-separated list of module exports.\n\npp.parseExportSpecifiers = function () {\n  var nodes = [],\n      first = true;\n  // export { x, y as z } [from '...']\n  this.expect(_tokentype.types.braceL);\n  while (!this.eat(_tokentype.types.braceR)) {\n    if (!first) {\n      this.expect(_tokentype.types.comma);\n      if (this.afterTrailingComma(_tokentype.types.braceR)) break;\n    } else first = false;\n\n    var node = this.startNode();\n    node.local = this.parseIdent(this.type === _tokentype.types._default);\n    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes;\n};\n\n// Parses import declaration.\n\npp.parseImport = function (node) {\n  this.next();\n  // import '...'\n  if (this.type === _tokentype.types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\");\n};\n\n// Parses a comma-separated list of module imports.\n\npp.parseImportSpecifiers = function () {\n  var nodes = [],\n      first = true;\n  if (this.type === _tokentype.types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, true);\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(_tokentype.types.comma)) return nodes;\n  }\n  if (this.type === _tokentype.types.star) {\n    var node = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, true);\n    nodes.push(this.finishNode(node, \"ImportNamespaceSpecifier\"));\n    return nodes;\n  }\n  this.expect(_tokentype.types.braceL);\n  while (!this.eat(_tokentype.types.braceR)) {\n    if (!first) {\n      this.expect(_tokentype.types.comma);\n      if (this.afterTrailingComma(_tokentype.types.braceR)) break;\n    } else first = false;\n\n    var node = this.startNode();\n    node.imported = this.parseIdent(true);\n    if (this.eatContextual(\"as\")) {\n      node.local = this.parseIdent();\n    } else {\n      node.local = node.imported;\n      if (this.isKeyword(node.local.name)) this.unexpected(node.local.start);\n      if (this.reservedWordsStrict.test(node.local.name)) this.raise(node.local.start, \"The keyword '\" + node.local.name + \"' is reserved\");\n    }\n    this.checkLVal(node.local, true);\n    nodes.push(this.finishNode(node, \"ImportSpecifier\"));\n  }\n  return nodes;\n};\n\n},{\"./state\":10,\"./tokentype\":14,\"./whitespace\":16}],12:[function(_dereq_,module,exports){\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\n\"use strict\";\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _state = _dereq_(\"./state\");\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nvar _whitespace = _dereq_(\"./whitespace\");\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override) {\n  _classCallCheck(this, TokContext);\n\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n};\n\nexports.TokContext = TokContext;\nvar types = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", true),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) {\n    return p.readTmplToken();\n  }),\n  f_expr: new TokContext(\"function\", true)\n};\n\nexports.types = types;\nvar pp = _state.Parser.prototype;\n\npp.initialContext = function () {\n  return [types.b_stat];\n};\n\npp.braceIsBlock = function (prevType) {\n  if (prevType === _tokentype.types.colon) {\n    var _parent = this.curContext();\n    if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;\n  }\n  if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;\n  if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;\n  return !this.exprAllowed;\n};\n\npp.updateContext = function (prevType) {\n  var update = undefined,\n      type = this.type;\n  if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;\n};\n\n// Token-specific context update code\n\n_tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {\n  if (this.context.length == 1) {\n    this.exprAllowed = true;\n    return;\n  }\n  var out = this.context.pop();\n  if (out === types.b_stat && this.curContext() === types.f_expr) {\n    this.context.pop();\n    this.exprAllowed = false;\n  } else if (out === types.b_tmpl) {\n    this.exprAllowed = true;\n  } else {\n    this.exprAllowed = !out.isExpr;\n  }\n};\n\n_tokentype.types.braceL.updateContext = function (prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n  this.exprAllowed = true;\n};\n\n_tokentype.types.dollarBraceL.updateContext = function () {\n  this.context.push(types.b_tmpl);\n  this.exprAllowed = true;\n};\n\n_tokentype.types.parenL.updateContext = function (prevType) {\n  var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;\n  this.context.push(statementParens ? types.p_stat : types.p_expr);\n  this.exprAllowed = true;\n};\n\n_tokentype.types.incDec.updateContext = function () {\n  // tokExprAllowed stays unchanged\n};\n\n_tokentype.types._function.updateContext = function () {\n  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);\n  this.exprAllowed = false;\n};\n\n_tokentype.types.backQuote.updateContext = function () {\n  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);\n  this.exprAllowed = false;\n};\n\n},{\"./state\":10,\"./tokentype\":14,\"./whitespace\":16}],13:[function(_dereq_,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _identifier = _dereq_(\"./identifier\");\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nvar _state = _dereq_(\"./state\");\n\nvar _locutil = _dereq_(\"./locutil\");\n\nvar _whitespace = _dereq_(\"./whitespace\");\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  _classCallCheck(this, Token);\n\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);\n  if (p.options.ranges) this.range = [p.start, p.end];\n}\n\n// ## Tokenizer\n\n;\n\nexports.Token = Token;\nvar pp = _state.Parser.prototype;\n\n// Are we running under Rhino?\nvar isRhino = typeof Packages == \"object\" && Object.prototype.toString.call(Packages) == \"[object JavaPackage]\";\n\n// Move to the next token\n\npp.next = function () {\n  if (this.options.onToken) this.options.onToken(new Token(this));\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp.getToken = function () {\n  this.next();\n  return new Token(this);\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\") pp[Symbol.iterator] = function () {\n  var self = this;\n  return { next: function next() {\n      var token = self.getToken();\n      return {\n        done: token.type === _tokentype.types.eof,\n        value: token\n      };\n    } };\n};\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp.setStrict = function (strict) {\n  this.strict = strict;\n  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;\n  this.pos = this.start;\n  if (this.options.locations) {\n    while (this.pos < this.lineStart) {\n      this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n      --this.curLine;\n    }\n  }\n  this.nextToken();\n};\n\npp.curContext = function () {\n  return this.context[this.context.length - 1];\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp.nextToken = function () {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) this.skipSpace();\n\n  this.start = this.pos;\n  if (this.options.locations) this.startLoc = this.curPosition();\n  if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);\n\n  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());\n};\n\npp.readToken = function (code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */) return this.readWord();\n\n  return this.getTokenFromCode(code);\n};\n\npp.fullCharCodeAtPos = function () {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) return code;\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00;\n};\n\npp.skipBlockComment = function () {\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos,\n      end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) this.raise(this.pos - 2, \"Unterminated comment\");\n  this.pos = end + 2;\n  if (this.options.locations) {\n    _whitespace.lineBreakG.lastIndex = start;\n    var match = undefined;\n    while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this.curLine;\n      this.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n};\n\npp.skipLineComment = function (startSkip) {\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n    ++this.pos;\n    ch = this.input.charCodeAt(this.pos);\n  }\n  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp.skipSpace = function () {\n  loop: while (this.pos < this.input.length) {\n    var ch = this.input.charCodeAt(this.pos);\n    switch (ch) {\n      case 32:case 160:\n        // ' '\n        ++this.pos;\n        break;\n      case 13:\n        if (this.input.charCodeAt(this.pos + 1) === 10) {\n          ++this.pos;\n        }\n      case 10:case 8232:case 8233:\n        ++this.pos;\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        break;\n      case 47:\n        // '/'\n        switch (this.input.charCodeAt(this.pos + 1)) {\n          case 42:\n            // '*'\n            this.skipBlockComment();\n            break;\n          case 47:\n            this.skipLineComment(2);\n            break;\n          default:\n            break loop;\n        }\n        break;\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this.pos;\n        } else {\n          break loop;\n        }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp.finishToken = function (type, val) {\n  this.end = this.pos;\n  if (this.options.locations) this.endLoc = this.curPosition();\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp.readToken_dot = function () {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) return this.readNumber(true);\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n    // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(_tokentype.types.ellipsis);\n  } else {\n    ++this.pos;\n    return this.finishToken(_tokentype.types.dot);\n  }\n};\n\npp.readToken_slash = function () {\n  // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) {\n    ++this.pos;return this.readRegexp();\n  }\n  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);\n  return this.finishOp(_tokentype.types.slash, 1);\n};\n\npp.readToken_mult_modulo = function (code) {\n  // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);\n  return this.finishOp(code === 42 ? _tokentype.types.star : _tokentype.types.modulo, 1);\n};\n\npp.readToken_pipe_amp = function (code) {\n  // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);\n  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);\n  return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);\n};\n\npp.readToken_caret = function () {\n  // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);\n  return this.finishOp(_tokentype.types.bitwiseXOR, 1);\n};\n\npp.readToken_plus_min = function (code) {\n  // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken();\n    }\n    return this.finishOp(_tokentype.types.incDec, 2);\n  }\n  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);\n  return this.finishOp(_tokentype.types.plusMin, 1);\n};\n\npp.readToken_lt_gt = function (code) {\n  // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);\n    return this.finishOp(_tokentype.types.bitShift, size);\n  }\n  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {\n    if (this.inModule) this.unexpected();\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken();\n  }\n  if (next === 61) size = this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2;\n  return this.finishOp(_tokentype.types.relational, size);\n};\n\npp.readToken_eq_excl = function (code) {\n  // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n    // '=>'\n    this.pos += 2;\n    return this.finishToken(_tokentype.types.arrow);\n  }\n  return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);\n};\n\npp.getTokenFromCode = function (code) {\n  switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n    case 46:\n      // '.'\n      return this.readToken_dot();\n\n    // Punctuation tokens.\n    case 40:\n      ++this.pos;return this.finishToken(_tokentype.types.parenL);\n    case 41:\n      ++this.pos;return this.finishToken(_tokentype.types.parenR);\n    case 59:\n      ++this.pos;return this.finishToken(_tokentype.types.semi);\n    case 44:\n      ++this.pos;return this.finishToken(_tokentype.types.comma);\n    case 91:\n      ++this.pos;return this.finishToken(_tokentype.types.bracketL);\n    case 93:\n      ++this.pos;return this.finishToken(_tokentype.types.bracketR);\n    case 123:\n      ++this.pos;return this.finishToken(_tokentype.types.braceL);\n    case 125:\n      ++this.pos;return this.finishToken(_tokentype.types.braceR);\n    case 58:\n      ++this.pos;return this.finishToken(_tokentype.types.colon);\n    case 63:\n      ++this.pos;return this.finishToken(_tokentype.types.question);\n\n    case 96:\n      // '`'\n      if (this.options.ecmaVersion < 6) break;\n      ++this.pos;\n      return this.finishToken(_tokentype.types.backQuote);\n\n    case 48:\n      // '0'\n      var next = this.input.charCodeAt(this.pos + 1);\n      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number\n      if (this.options.ecmaVersion >= 6) {\n        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number\n        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number\n      }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:\n      // 1-9\n      return this.readNumber(false);\n\n    // Quotes produce strings.\n    case 34:case 39:\n      // '\"', \"'\"\n      return this.readString(code);\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case 47:\n      // '/'\n      return this.readToken_slash();\n\n    case 37:case 42:\n      // '%*'\n      return this.readToken_mult_modulo(code);\n\n    case 124:case 38:\n      // '|&'\n      return this.readToken_pipe_amp(code);\n\n    case 94:\n      // '^'\n      return this.readToken_caret();\n\n    case 43:case 45:\n      // '+-'\n      return this.readToken_plus_min(code);\n\n    case 60:case 62:\n      // '<>'\n      return this.readToken_lt_gt(code);\n\n    case 61:case 33:\n      // '=!'\n      return this.readToken_eq_excl(code);\n\n    case 126:\n      // '~'\n      return this.finishOp(_tokentype.types.prefix, 1);\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp.finishOp = function (type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str);\n};\n\n// Parse a regular expression. Some context-awareness is necessary,\n// since a '/' inside a '[]' set does not end the expression.\n\nfunction tryCreateRegexp(src, flags, throwErrorAt, parser) {\n  try {\n    return new RegExp(src, flags);\n  } catch (e) {\n    if (throwErrorAt !== undefined) {\n      if (e instanceof SyntaxError) parser.raise(throwErrorAt, \"Error parsing regular expression: \" + e.message);\n      throw e;\n    }\n  }\n}\n\nvar regexpUnicodeSupport = !!tryCreateRegexp(\"\", \"u\");\n\npp.readRegexp = function () {\n  var _this = this;\n\n  var escaped = undefined,\n      inClass = undefined,\n      start = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) this.raise(start, \"Unterminated regular expression\");\n    var ch = this.input.charAt(this.pos);\n    if (_whitespace.lineBreak.test(ch)) this.raise(start, \"Unterminated regular expression\");\n    if (!escaped) {\n      if (ch === \"[\") inClass = true;else if (ch === \"]\" && inClass) inClass = false;else if (ch === \"/\" && !inClass) break;\n      escaped = ch === \"\\\\\";\n    } else escaped = false;\n    ++this.pos;\n  }\n  var content = this.input.slice(start, this.pos);\n  ++this.pos;\n  // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n  // here (don't ask).\n  var mods = this.readWord1();\n  var tmp = content;\n  if (mods) {\n    var validFlags = /^[gim]*$/;\n    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/;\n    if (!validFlags.test(mods)) this.raise(start, \"Invalid regular expression flag\");\n    if (mods.indexOf('u') >= 0 && !regexpUnicodeSupport) {\n      // Replace each astral symbol and every Unicode escape sequence that\n      // possibly represents an astral symbol or a paired surrogate with a\n      // single ASCII symbol to avoid throwing on regular expressions that\n      // are only valid in combination with the `/u` flag.\n      // Note: replacing with the ASCII symbol `x` might cause false\n      // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n      // perfectly valid pattern that is equivalent to `[a-b]`, but it would\n      // be replaced by `[x-b]` which throws an error.\n      tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function (_match, code, offset) {\n        code = Number(\"0x\" + code);\n        if (code > 0x10FFFF) _this.raise(start + offset + 3, \"Code point out of bounds\");\n        return \"x\";\n      });\n      tmp = tmp.replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"x\");\n    }\n  }\n  // Detect invalid regular expressions.\n  var value = null;\n  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,\n  // so don't do detection if we are running under Rhino\n  if (!isRhino) {\n    tryCreateRegexp(tmp, undefined, start, this);\n    // Get a regular expression object for this pattern-flag pair, or `null` in\n    // case the current environment doesn't support the flags it uses.\n    value = tryCreateRegexp(content, mods);\n  }\n  return this.finishToken(_tokentype.types.regexp, { pattern: content, flags: mods, value: value });\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp.readInt = function (radix, len) {\n  var start = this.pos,\n      total = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this.input.charCodeAt(this.pos),\n        val = undefined;\n    if (code >= 97) val = code - 97 + 10; // a\n    else if (code >= 65) val = code - 65 + 10; // A\n      else if (code >= 48 && code <= 57) val = code - 48; // 0-9\n        else val = Infinity;\n    if (val >= radix) break;\n    ++this.pos;\n    total = total * radix + val;\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) return null;\n\n  return total;\n};\n\npp.readRadixNumber = function (radix) {\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) this.raise(this.start + 2, \"Expected number in radix \" + radix);\n  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\");\n  return this.finishToken(_tokentype.types.num, val);\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp.readNumber = function (startsWithDot) {\n  var start = this.pos,\n      isFloat = false,\n      octal = this.input.charCodeAt(this.pos) === 48;\n  if (!startsWithDot && this.readInt(10) === null) this.raise(start, \"Invalid number\");\n  var next = this.input.charCodeAt(this.pos);\n  if (next === 46) {\n    // '.'\n    ++this.pos;\n    this.readInt(10);\n    isFloat = true;\n    next = this.input.charCodeAt(this.pos);\n  }\n  if (next === 69 || next === 101) {\n    // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) ++this.pos; // '+-'\n    if (this.readInt(10) === null) this.raise(start, \"Invalid number\");\n    isFloat = true;\n  }\n  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\");\n\n  var str = this.input.slice(start, this.pos),\n      val = undefined;\n  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, \"Invalid number\");else val = parseInt(str, 8);\n  return this.finishToken(_tokentype.types.num, val);\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp.readCodePoint = function () {\n  var ch = this.input.charCodeAt(this.pos),\n      code = undefined;\n\n  if (ch === 123) {\n    if (this.options.ecmaVersion < 6) this.unexpected();\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) this.raise(codePos, \"Code point out of bounds\");\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code;\n};\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) return String.fromCharCode(code);\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n}\n\npp.readString = function (quote) {\n  var out = \"\",\n      chunkStart = ++this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) this.raise(this.start, \"Unterminated string constant\");\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === quote) break;\n    if (ch === 92) {\n      // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(false);\n      chunkStart = this.pos;\n    } else {\n      if (_whitespace.isNewLine(ch)) this.raise(this.start, \"Unterminated string constant\");\n      ++this.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(_tokentype.types.string, out);\n};\n\n// Reads template string tokens.\n\npp.readTmplToken = function () {\n  var out = \"\",\n      chunkStart = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) this.raise(this.start, \"Unterminated template\");\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {\n      // '`', '${'\n      if (this.pos === this.start && this.type === _tokentype.types.template) {\n        if (ch === 36) {\n          this.pos += 2;\n          return this.finishToken(_tokentype.types.dollarBraceL);\n        } else {\n          ++this.pos;\n          return this.finishToken(_tokentype.types.backQuote);\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos);\n      return this.finishToken(_tokentype.types.template, out);\n    }\n    if (ch === 92) {\n      // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(true);\n      chunkStart = this.pos;\n    } else if (_whitespace.isNewLine(ch)) {\n      out += this.input.slice(chunkStart, this.pos);\n      ++this.pos;\n      switch (ch) {\n        case 13:\n          if (this.input.charCodeAt(this.pos) === 10) ++this.pos;\n        case 10:\n          out += \"\\n\";\n          break;\n        default:\n          out += String.fromCharCode(ch);\n          break;\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      chunkStart = this.pos;\n    } else {\n      ++this.pos;\n    }\n  }\n};\n\n// Used to read escaped characters\n\npp.readEscapedChar = function (inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n    case 110:\n      return \"\\n\"; // 'n' -> '\\n'\n    case 114:\n      return \"\\r\"; // 'r' -> '\\r'\n    case 120:\n      return String.fromCharCode(this.readHexChar(2)); // 'x'\n    case 117:\n      return codePointToString(this.readCodePoint()); // 'u'\n    case 116:\n      return \"\\t\"; // 't' -> '\\t'\n    case 98:\n      return \"\\b\"; // 'b' -> '\\b'\n    case 118:\n      return \"\\u000b\"; // 'v' -> '\\u000b'\n    case 102:\n      return \"\\f\"; // 'f' -> '\\f'\n    case 13:\n      if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\\r\\n'\n    case 10:\n      // ' \\n'\n      if (this.options.locations) {\n        this.lineStart = this.pos;++this.curLine;\n      }\n      return \"\";\n    default:\n      if (ch >= 48 && ch <= 55) {\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n        var octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        if (octalStr !== \"0\" && (this.strict || inTemplate)) {\n          this.raise(this.pos - 2, \"Octal literal in strict mode\");\n        }\n        this.pos += octalStr.length - 1;\n        return String.fromCharCode(octal);\n      }\n      return String.fromCharCode(ch);\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp.readHexChar = function (len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) this.raise(codePos, \"Bad character escape sequence\");\n  return n;\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp.readWord1 = function () {\n  this.containsEsc = false;\n  var word = \"\",\n      first = true,\n      chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this.fullCharCodeAtPos();\n    if (_identifier.isIdentifierChar(ch, astral)) {\n      this.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) {\n      // \"\\\"\n      this.containsEsc = true;\n      word += this.input.slice(chunkStart, this.pos);\n      var escStart = this.pos;\n      if (this.input.charCodeAt(++this.pos) != 117) // \"u\"\n        this.raise(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n      ++this.pos;\n      var esc = this.readCodePoint();\n      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, \"Invalid Unicode escape\");\n      word += codePointToString(esc);\n      chunkStart = this.pos;\n    } else {\n      break;\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos);\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp.readWord = function () {\n  var word = this.readWord1();\n  var type = _tokentype.types.name;\n  if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = _tokentype.keywords[word];\n  return this.finishToken(type, word);\n};\n\n},{\"./identifier\":2,\"./locutil\":5,\"./state\":10,\"./tokentype\":14,\"./whitespace\":16}],14:[function(_dereq_,module,exports){\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\n\"use strict\";\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TokenType = function TokenType(label) {\n  var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  _classCallCheck(this, TokenType);\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nexports.TokenType = TokenType;\n\nfunction binop(name, prec) {\n  return new TokenType(name, { beforeExpr: true, binop: prec });\n}\nvar beforeExpr = { beforeExpr: true },\n    startsExpr = { startsExpr: true };\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", { beforeExpr: true, startsExpr: true }),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", { beforeExpr: true, startsExpr: true }),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", { beforeExpr: true, startsExpr: true }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", { beforeExpr: true, startsExpr: true }),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", { beforeExpr: true, isAssign: true }),\n  assign: new TokenType(\"_=\", { beforeExpr: true, isAssign: true }),\n  incDec: new TokenType(\"++/--\", { prefix: true, postfix: true, startsExpr: true }),\n  prefix: new TokenType(\"prefix\", { beforeExpr: true, prefix: true, startsExpr: true }),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=\", 6),\n  relational: binop(\"</>\", 7),\n  bitShift: binop(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10)\n};\n\nexports.types = types;\n// Map keyword names to token types.\n\nvar keywords = {};\n\nexports.keywords = keywords;\n// Succinct definitions of keyword token types\nfunction kw(name) {\n  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  options.keyword = name;\n  keywords[name] = types[\"_\" + name] = new TokenType(name, options);\n}\n\nkw(\"break\");\nkw(\"case\", beforeExpr);\nkw(\"catch\");\nkw(\"continue\");\nkw(\"debugger\");\nkw(\"default\", beforeExpr);\nkw(\"do\", { isLoop: true, beforeExpr: true });\nkw(\"else\", beforeExpr);\nkw(\"finally\");\nkw(\"for\", { isLoop: true });\nkw(\"function\", startsExpr);\nkw(\"if\");\nkw(\"return\", beforeExpr);\nkw(\"switch\");\nkw(\"throw\", beforeExpr);\nkw(\"try\");\nkw(\"var\");\nkw(\"let\");\nkw(\"const\");\nkw(\"while\", { isLoop: true });\nkw(\"with\");\nkw(\"new\", { beforeExpr: true, startsExpr: true });\nkw(\"this\", startsExpr);\nkw(\"super\", startsExpr);\nkw(\"class\");\nkw(\"extends\", beforeExpr);\nkw(\"export\");\nkw(\"import\");\nkw(\"yield\", { beforeExpr: true, startsExpr: true });\nkw(\"null\", startsExpr);\nkw(\"true\", startsExpr);\nkw(\"false\", startsExpr);\nkw(\"in\", { beforeExpr: true, binop: 7 });\nkw(\"instanceof\", { beforeExpr: true, binop: 7 });\nkw(\"typeof\", { beforeExpr: true, prefix: true, startsExpr: true });\nkw(\"void\", { beforeExpr: true, prefix: true, startsExpr: true });\nkw(\"delete\", { beforeExpr: true, prefix: true, startsExpr: true });\n\n},{}],15:[function(_dereq_,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.isArray = isArray;\nexports.has = has;\n\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === \"[object Array]\";\n}\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return Object.prototype.hasOwnProperty.call(obj, propName);\n}\n\n},{}],16:[function(_dereq_,module,exports){\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\n\"use strict\";\n\nexports.__esModule = true;\nexports.isNewLine = isNewLine;\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nexports.lineBreak = lineBreak;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nexports.lineBreakG = lineBreakG;\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\nexports.nonASCIIwhitespace = nonASCIIwhitespace;\n\n},{}]},{},[3])(3)\n});","//     Backbone.js 1.2.3\n\n//     (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\n\n(function(factory) {\n\n  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.\n  // We use `self` instead of `window` for `WebWorker` support.\n  var root = (typeof self == 'object' && self.self == self && self) ||\n            (typeof global == 'object' && global.global == global && global);\n\n  // Set up Backbone appropriately for the environment. Start with AMD.\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {\n      // Export global even in AMD case in case this script is loaded with\n      // others that may still expect a global Backbone.\n      root.Backbone = factory(root, exports, _, $);\n    });\n\n  // Next for Node.js or CommonJS. jQuery may not be needed as a module.\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore'), $;\n    try { $ = require('jquery'); } catch(e) {}\n    factory(root, exports, _, $);\n\n  // Finally, as a browser global.\n  } else {\n    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));\n  }\n\n}(function(root, Backbone, _, $) {\n\n  // Initial Setup\n  // -------------\n\n  // Save the previous value of the `Backbone` variable, so that it can be\n  // restored later on, if `noConflict` is used.\n  var previousBackbone = root.Backbone;\n\n  // Create a local reference to a common array method we'll want to use later.\n  var slice = Array.prototype.slice;\n\n  // Current version of the library. Keep in sync with `package.json`.\n  Backbone.VERSION = '1.2.3';\n\n  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\n  // the `$` variable.\n  Backbone.$ = $;\n\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n  // to its previous owner. Returns a reference to this Backbone object.\n  Backbone.noConflict = function() {\n    root.Backbone = previousBackbone;\n    return this;\n  };\n\n  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n  // will fake `\"PATCH\"`, `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n  // set a `X-Http-Method-Override` header.\n  Backbone.emulateHTTP = false;\n\n  // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n  // `application/json` requests ... this will encode the body as\n  // `application/x-www-form-urlencoded` instead and will send the model in a\n  // form param named `model`.\n  Backbone.emulateJSON = false;\n\n  // Proxy Backbone class methods to Underscore functions, wrapping the model's\n  // `attributes` object or collection's `models` array behind the scenes.\n  //\n  // collection.filter(function(model) { return model.get('age') > 10 });\n  // collection.each(this.addView);\n  //\n  // `Function#apply` can be slow so we use the method's arg count, if we know it.\n  var addMethod = function(length, method, attribute) {\n    switch (length) {\n      case 1: return function() {\n        return _[method](this[attribute]);\n      };\n      case 2: return function(value) {\n        return _[method](this[attribute], value);\n      };\n      case 3: return function(iteratee, context) {\n        return _[method](this[attribute], cb(iteratee, this), context);\n      };\n      case 4: return function(iteratee, defaultVal, context) {\n        return _[method](this[attribute], cb(iteratee, this), defaultVal, context);\n      };\n      default: return function() {\n        var args = slice.call(arguments);\n        args.unshift(this[attribute]);\n        return _[method].apply(_, args);\n      };\n    }\n  };\n  var addUnderscoreMethods = function(Class, methods, attribute) {\n    _.each(methods, function(length, method) {\n      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);\n    });\n  };\n\n  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.\n  var cb = function(iteratee, instance) {\n    if (_.isFunction(iteratee)) return iteratee;\n    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);\n    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };\n    return iteratee;\n  };\n  var modelMatcher = function(attrs) {\n    var matcher = _.matches(attrs);\n    return function(model) {\n      return matcher(model.attributes);\n    };\n  };\n\n  // Backbone.Events\n  // ---------------\n\n  // A module that can be mixed in to *any object* in order to provide it with\n  // a custom event channel. You may bind a callback to an event with `on` or\n  // remove with `off`; `trigger`-ing an event fires all callbacks in\n  // succession.\n  //\n  //     var object = {};\n  //     _.extend(object, Backbone.Events);\n  //     object.on('expand', function(){ alert('expanded'); });\n  //     object.trigger('expand');\n  //\n  var Events = Backbone.Events = {};\n\n  // Regular expression used to split event strings.\n  var eventSplitter = /\\s+/;\n\n  // Iterates over the standard `event, callback` (as well as the fancy multiple\n  // space-separated events `\"change blur\", callback` and jQuery-style event\n  // maps `{event: callback}`).\n  var eventsApi = function(iteratee, events, name, callback, opts) {\n    var i = 0, names;\n    if (name && typeof name === 'object') {\n      // Handle event maps.\n      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;\n      for (names = _.keys(name); i < names.length ; i++) {\n        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n      }\n    } else if (name && eventSplitter.test(name)) {\n      // Handle space separated event names by delegating them individually.\n      for (names = name.split(eventSplitter); i < names.length; i++) {\n        events = iteratee(events, names[i], callback, opts);\n      }\n    } else {\n      // Finally, standard events.\n      events = iteratee(events, name, callback, opts);\n    }\n    return events;\n  };\n\n  // Bind an event to a `callback` function. Passing `\"all\"` will bind\n  // the callback to all events fired.\n  Events.on = function(name, callback, context) {\n    return internalOn(this, name, callback, context);\n  };\n\n  // Guard the `listening` argument from the public API.\n  var internalOn = function(obj, name, callback, context, listening) {\n    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {\n        context: context,\n        ctx: obj,\n        listening: listening\n    });\n\n    if (listening) {\n      var listeners = obj._listeners || (obj._listeners = {});\n      listeners[listening.id] = listening;\n    }\n\n    return obj;\n  };\n\n  // Inversion-of-control versions of `on`. Tell *this* object to listen to\n  // an event in another object... keeping track of what it's listening to\n  // for easier unbinding later.\n  Events.listenTo =  function(obj, name, callback) {\n    if (!obj) return this;\n    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var listening = listeningTo[id];\n\n    // This object is not listening to any other events on `obj` yet.\n    // Setup the necessary references to track the listening callbacks.\n    if (!listening) {\n      var thisId = this._listenId || (this._listenId = _.uniqueId('l'));\n      listening = listeningTo[id] = {obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0};\n    }\n\n    // Bind callbacks on obj, and keep track of them on listening.\n    internalOn(obj, name, callback, this, listening);\n    return this;\n  };\n\n  // The reducing API that adds a callback to the `events` object.\n  var onApi = function(events, name, callback, options) {\n    if (callback) {\n      var handlers = events[name] || (events[name] = []);\n      var context = options.context, ctx = options.ctx, listening = options.listening;\n      if (listening) listening.count++;\n\n      handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });\n    }\n    return events;\n  };\n\n  // Remove one or many callbacks. If `context` is null, removes all\n  // callbacks with that function. If `callback` is null, removes all\n  // callbacks for the event. If `name` is null, removes all bound\n  // callbacks for all events.\n  Events.off =  function(name, callback, context) {\n    if (!this._events) return this;\n    this._events = eventsApi(offApi, this._events, name, callback, {\n        context: context,\n        listeners: this._listeners\n    });\n    return this;\n  };\n\n  // Tell this object to stop listening to either specific events ... or\n  // to every object it's currently listening to.\n  Events.stopListening =  function(obj, name, callback) {\n    var listeningTo = this._listeningTo;\n    if (!listeningTo) return this;\n\n    var ids = obj ? [obj._listenId] : _.keys(listeningTo);\n\n    for (var i = 0; i < ids.length; i++) {\n      var listening = listeningTo[ids[i]];\n\n      // If listening doesn't exist, this object is not currently\n      // listening to obj. Break out early.\n      if (!listening) break;\n\n      listening.obj.off(name, callback, this);\n    }\n    if (_.isEmpty(listeningTo)) this._listeningTo = void 0;\n\n    return this;\n  };\n\n  // The reducing API that removes a callback from the `events` object.\n  var offApi = function(events, name, callback, options) {\n    if (!events) return;\n\n    var i = 0, listening;\n    var context = options.context, listeners = options.listeners;\n\n    // Delete all events listeners and \"drop\" events.\n    if (!name && !callback && !context) {\n      var ids = _.keys(listeners);\n      for (; i < ids.length; i++) {\n        listening = listeners[ids[i]];\n        delete listeners[listening.id];\n        delete listening.listeningTo[listening.objId];\n      }\n      return;\n    }\n\n    var names = name ? [name] : _.keys(events);\n    for (; i < names.length; i++) {\n      name = names[i];\n      var handlers = events[name];\n\n      // Bail out if there are no events stored.\n      if (!handlers) break;\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      var remaining = [];\n      for (var j = 0; j < handlers.length; j++) {\n        var handler = handlers[j];\n        if (\n          callback && callback !== handler.callback &&\n            callback !== handler.callback._callback ||\n              context && context !== handler.context\n        ) {\n          remaining.push(handler);\n        } else {\n          listening = handler.listening;\n          if (listening && --listening.count === 0) {\n            delete listeners[listening.id];\n            delete listening.listeningTo[listening.objId];\n          }\n        }\n      }\n\n      // Update tail event if the list has any events.  Otherwise, clean up.\n      if (remaining.length) {\n        events[name] = remaining;\n      } else {\n        delete events[name];\n      }\n    }\n    if (_.size(events)) return events;\n  };\n\n  // Bind an event to only be triggered a single time. After the first time\n  // the callback is invoked, its listener will be removed. If multiple events\n  // are passed in using the space-separated syntax, the handler will fire\n  // once for each event, not once for a combination of all events.\n  Events.once =  function(name, callback, context) {\n    // Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));\n    return this.on(events, void 0, context);\n  };\n\n  // Inversion-of-control versions of `once`.\n  Events.listenToOnce =  function(obj, name, callback) {\n    // Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));\n    return this.listenTo(obj, events);\n  };\n\n  // Reduces the event callbacks into a map of `{event: onceWrapper}`.\n  // `offer` unbinds the `onceWrapper` after it has been called.\n  var onceMap = function(map, name, callback, offer) {\n    if (callback) {\n      var once = map[name] = _.once(function() {\n        offer(name, once);\n        callback.apply(this, arguments);\n      });\n      once._callback = callback;\n    }\n    return map;\n  };\n\n  // Trigger one or many events, firing all bound callbacks. Callbacks are\n  // passed the same arguments as `trigger` is, apart from the event name\n  // (unless you're listening on `\"all\"`, which will cause your callback to\n  // receive the true name of the event as the first argument).\n  Events.trigger =  function(name) {\n    if (!this._events) return this;\n\n    var length = Math.max(0, arguments.length - 1);\n    var args = Array(length);\n    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];\n\n    eventsApi(triggerApi, this._events, name, void 0, args);\n    return this;\n  };\n\n  // Handles triggering the appropriate event callbacks.\n  var triggerApi = function(objEvents, name, cb, args) {\n    if (objEvents) {\n      var events = objEvents[name];\n      var allEvents = objEvents.all;\n      if (events && allEvents) allEvents = allEvents.slice();\n      if (events) triggerEvents(events, args);\n      if (allEvents) triggerEvents(allEvents, [name].concat(args));\n    }\n    return objEvents;\n  };\n\n  // A difficult-to-believe, but optimized internal dispatch function for\n  // triggering events. Tries to keep the usual cases speedy (most internal\n  // Backbone events have 3 arguments).\n  var triggerEvents = function(events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;\n    }\n  };\n\n  // Aliases for backwards compatibility.\n  Events.bind   = Events.on;\n  Events.unbind = Events.off;\n\n  // Allow the `Backbone` object to serve as a global event bus, for folks who\n  // want global \"pubsub\" in a convenient place.\n  _.extend(Backbone, Events);\n\n  // Backbone.Model\n  // --------------\n\n  // Backbone **Models** are the basic data object in the framework --\n  // frequently representing a row in a table in a database on your server.\n  // A discrete chunk of data and a bunch of useful, related methods for\n  // performing computations and transformations on that data.\n\n  // Create a new model with the specified attributes. A client id (`cid`)\n  // is automatically generated and assigned for you.\n  var Model = Backbone.Model = function(attributes, options) {\n    var attrs = attributes || {};\n    options || (options = {});\n    this.cid = _.uniqueId(this.cidPrefix);\n    this.attributes = {};\n    if (options.collection) this.collection = options.collection;\n    if (options.parse) attrs = this.parse(attrs, options) || {};\n    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n  };\n\n  // Attach all inheritable methods to the Model prototype.\n  _.extend(Model.prototype, Events, {\n\n    // A hash of attributes whose current and previous value differ.\n    changed: null,\n\n    // The value returned during the last failed validation.\n    validationError: null,\n\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n    // CouchDB users may want to set this to `\"_id\"`.\n    idAttribute: 'id',\n\n    // The prefix is used to create the client id which is used to identify models locally.\n    // You may want to override this if you're experiencing name clashes with model ids.\n    cidPrefix: 'c',\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Return a copy of the model's `attributes` object.\n    toJSON: function(options) {\n      return _.clone(this.attributes);\n    },\n\n    // Proxy `Backbone.sync` by default -- but override this if you need\n    // custom syncing semantics for *this* particular model.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Get the value of an attribute.\n    get: function(attr) {\n      return this.attributes[attr];\n    },\n\n    // Get the HTML-escaped value of an attribute.\n    escape: function(attr) {\n      return _.escape(this.get(attr));\n    },\n\n    // Returns `true` if the attribute contains a value that is not null\n    // or undefined.\n    has: function(attr) {\n      return this.get(attr) != null;\n    },\n\n    // Special-cased proxy to underscore's `_.matches` method.\n    matches: function(attrs) {\n      return !!_.iteratee(attrs, this)(this.attributes);\n    },\n\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\n    // the core primitive operation of a model, updating the data and notifying\n    // anyone who needs to know about the change in state. The heart of the beast.\n    set: function(key, val, options) {\n      if (key == null) return this;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      var attrs;\n      if (typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options || (options = {});\n\n      // Run validation.\n      if (!this._validate(attrs, options)) return false;\n\n      // Extract attributes and options.\n      var unset      = options.unset;\n      var silent     = options.silent;\n      var changes    = [];\n      var changing   = this._changing;\n      this._changing = true;\n\n      if (!changing) {\n        this._previousAttributes = _.clone(this.attributes);\n        this.changed = {};\n      }\n\n      var current = this.attributes;\n      var changed = this.changed;\n      var prev    = this._previousAttributes;\n\n      // For each `set` attribute, update or delete the current value.\n      for (var attr in attrs) {\n        val = attrs[attr];\n        if (!_.isEqual(current[attr], val)) changes.push(attr);\n        if (!_.isEqual(prev[attr], val)) {\n          changed[attr] = val;\n        } else {\n          delete changed[attr];\n        }\n        unset ? delete current[attr] : current[attr] = val;\n      }\n\n      // Update the `id`.\n      this.id = this.get(this.idAttribute);\n\n      // Trigger all relevant attribute changes.\n      if (!silent) {\n        if (changes.length) this._pending = options;\n        for (var i = 0; i < changes.length; i++) {\n          this.trigger('change:' + changes[i], this, current[changes[i]], options);\n        }\n      }\n\n      // You might be wondering why there's a `while` loop here. Changes can\n      // be recursively nested within `\"change\"` events.\n      if (changing) return this;\n      if (!silent) {\n        while (this._pending) {\n          options = this._pending;\n          this._pending = false;\n          this.trigger('change', this, options);\n        }\n      }\n      this._pending = false;\n      this._changing = false;\n      return this;\n    },\n\n    // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n    // if the attribute doesn't exist.\n    unset: function(attr, options) {\n      return this.set(attr, void 0, _.extend({}, options, {unset: true}));\n    },\n\n    // Clear all attributes on the model, firing `\"change\"`.\n    clear: function(options) {\n      var attrs = {};\n      for (var key in this.attributes) attrs[key] = void 0;\n      return this.set(attrs, _.extend({}, options, {unset: true}));\n    },\n\n    // Determine if the model has changed since the last `\"change\"` event.\n    // If you specify an attribute name, determine if that attribute has changed.\n    hasChanged: function(attr) {\n      if (attr == null) return !_.isEmpty(this.changed);\n      return _.has(this.changed, attr);\n    },\n\n    // Return an object containing all the attributes that have changed, or\n    // false if there are no changed attributes. Useful for determining what\n    // parts of a view need to be updated and/or what attributes need to be\n    // persisted to the server. Unset attributes will be set to undefined.\n    // You can also pass an attributes object to diff against the model,\n    // determining if there *would be* a change.\n    changedAttributes: function(diff) {\n      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\n      var old = this._changing ? this._previousAttributes : this.attributes;\n      var changed = {};\n      for (var attr in diff) {\n        var val = diff[attr];\n        if (_.isEqual(old[attr], val)) continue;\n        changed[attr] = val;\n      }\n      return _.size(changed) ? changed : false;\n    },\n\n    // Get the previous value of an attribute, recorded at the time the last\n    // `\"change\"` event was fired.\n    previous: function(attr) {\n      if (attr == null || !this._previousAttributes) return null;\n      return this._previousAttributes[attr];\n    },\n\n    // Get all of the attributes of the model at the time of the previous\n    // `\"change\"` event.\n    previousAttributes: function() {\n      return _.clone(this._previousAttributes);\n    },\n\n    // Fetch the model from the server, merging the response with the model's\n    // local attributes. Any changed attributes will trigger a \"change\" event.\n    fetch: function(options) {\n      options = _.extend({parse: true}, options);\n      var model = this;\n      var success = options.success;\n      options.success = function(resp) {\n        var serverAttrs = options.parse ? model.parse(resp, options) : resp;\n        if (!model.set(serverAttrs, options)) return false;\n        if (success) success.call(options.context, model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Set a hash of model attributes, and sync the model to the server.\n    // If the server returns an attributes hash that differs, the model's\n    // state will be `set` again.\n    save: function(key, val, options) {\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      var attrs;\n      if (key == null || typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options = _.extend({validate: true, parse: true}, options);\n      var wait = options.wait;\n\n      // If we're not waiting and attributes exist, save acts as\n      // `set(attr).save(null, opts)` with validation. Otherwise, check if\n      // the model will be valid when the attributes, if any, are set.\n      if (attrs && !wait) {\n        if (!this.set(attrs, options)) return false;\n      } else {\n        if (!this._validate(attrs, options)) return false;\n      }\n\n      // After a successful server-side save, the client is (optionally)\n      // updated with the server-side state.\n      var model = this;\n      var success = options.success;\n      var attributes = this.attributes;\n      options.success = function(resp) {\n        // Ensure attributes are restored during synchronous saves.\n        model.attributes = attributes;\n        var serverAttrs = options.parse ? model.parse(resp, options) : resp;\n        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);\n        if (serverAttrs && !model.set(serverAttrs, options)) return false;\n        if (success) success.call(options.context, model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n\n      // Set temporary attributes if `{wait: true}` to properly find new ids.\n      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);\n\n      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n      if (method === 'patch' && !options.attrs) options.attrs = attrs;\n      var xhr = this.sync(method, this, options);\n\n      // Restore attributes.\n      this.attributes = attributes;\n\n      return xhr;\n    },\n\n    // Destroy this model on the server if it was already persisted.\n    // Optimistically removes the model from its collection, if it has one.\n    // If `wait: true` is passed, waits for the server to respond before removal.\n    destroy: function(options) {\n      options = options ? _.clone(options) : {};\n      var model = this;\n      var success = options.success;\n      var wait = options.wait;\n\n      var destroy = function() {\n        model.stopListening();\n        model.trigger('destroy', model, model.collection, options);\n      };\n\n      options.success = function(resp) {\n        if (wait) destroy();\n        if (success) success.call(options.context, model, resp, options);\n        if (!model.isNew()) model.trigger('sync', model, resp, options);\n      };\n\n      var xhr = false;\n      if (this.isNew()) {\n        _.defer(options.success);\n      } else {\n        wrapError(this, options);\n        xhr = this.sync('delete', this, options);\n      }\n      if (!wait) destroy();\n      return xhr;\n    },\n\n    // Default URL for the model's representation on the server -- if you're\n    // using Backbone's restful methods, override this to change the endpoint\n    // that will be called.\n    url: function() {\n      var base =\n        _.result(this, 'urlRoot') ||\n        _.result(this.collection, 'url') ||\n        urlError();\n      if (this.isNew()) return base;\n      var id = this.get(this.idAttribute);\n      return base.replace(/[^\\/]$/, '$&/') + encodeURIComponent(id);\n    },\n\n    // **parse** converts a response into the hash of attributes to be `set` on\n    // the model. The default implementation is just to pass the response along.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new model with identical attributes to this one.\n    clone: function() {\n      return new this.constructor(this.attributes);\n    },\n\n    // A model is new if it has never been saved to the server, and lacks an id.\n    isNew: function() {\n      return !this.has(this.idAttribute);\n    },\n\n    // Check if the model is currently in a valid state.\n    isValid: function(options) {\n      return this._validate({}, _.defaults({validate: true}, options));\n    },\n\n    // Run validation against the next complete set of model attributes,\n    // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n    _validate: function(attrs, options) {\n      if (!options.validate || !this.validate) return true;\n      attrs = _.extend({}, this.attributes, attrs);\n      var error = this.validationError = this.validate(attrs, options) || null;\n      if (!error) return true;\n      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));\n      return false;\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Model, mapped to the\n  // number of arguments they take.\n  var modelMethods = { keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,\n      omit: 0, chain: 1, isEmpty: 1 };\n\n  // Mix in each Underscore method as a proxy to `Model#attributes`.\n  addUnderscoreMethods(Model, modelMethods, 'attributes');\n\n  // Backbone.Collection\n  // -------------------\n\n  // If models tend to represent a single row of data, a Backbone Collection is\n  // more analogous to a table full of data ... or a small slice or page of that\n  // table, or a collection of rows that belong together for a particular reason\n  // -- all of the messages in this particular folder, all of the documents\n  // belonging to this particular author, and so on. Collections maintain\n  // indexes of their models, both in order, and for lookup by `id`.\n\n  // Create a new **Collection**, perhaps to contain a specific type of `model`.\n  // If a `comparator` is specified, the Collection will maintain\n  // its models in sort order, as they're added and removed.\n  var Collection = Backbone.Collection = function(models, options) {\n    options || (options = {});\n    if (options.model) this.model = options.model;\n    if (options.comparator !== void 0) this.comparator = options.comparator;\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) this.reset(models, _.extend({silent: true}, options));\n  };\n\n  // Default options for `Collection#set`.\n  var setOptions = {add: true, remove: true, merge: true};\n  var addOptions = {add: true, remove: false};\n\n  // Splices `insert` into `array` at index `at`.\n  var splice = function(array, insert, at) {\n    at = Math.min(Math.max(at, 0), array.length);\n    var tail = Array(array.length - at);\n    var length = insert.length;\n    for (var i = 0; i < tail.length; i++) tail[i] = array[i + at];\n    for (i = 0; i < length; i++) array[i + at] = insert[i];\n    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];\n  };\n\n  // Define the Collection's inheritable methods.\n  _.extend(Collection.prototype, Events, {\n\n    // The default model for a collection is just a **Backbone.Model**.\n    // This should be overridden in most cases.\n    model: Model,\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // The JSON representation of a Collection is an array of the\n    // models' attributes.\n    toJSON: function(options) {\n      return this.map(function(model) { return model.toJSON(options); });\n    },\n\n    // Proxy `Backbone.sync` by default.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Add a model, or list of models to the set. `models` may be Backbone\n    // Models or raw JavaScript objects to be converted to Models, or any\n    // combination of the two.\n    add: function(models, options) {\n      return this.set(models, _.extend({merge: false}, options, addOptions));\n    },\n\n    // Remove a model, or a list of models from the set.\n    remove: function(models, options) {\n      options = _.extend({}, options);\n      var singular = !_.isArray(models);\n      models = singular ? [models] : _.clone(models);\n      var removed = this._removeModels(models, options);\n      if (!options.silent && removed) this.trigger('update', this, options);\n      return singular ? removed[0] : removed;\n    },\n\n    // Update a collection by `set`-ing a new list of models, adding new ones,\n    // removing models that are no longer present, and merging models that\n    // already exist in the collection, as necessary. Similar to **Model#set**,\n    // the core operation for updating the data contained by the collection.\n    set: function(models, options) {\n      if (models == null) return;\n\n      options = _.defaults({}, options, setOptions);\n      if (options.parse && !this._isModel(models)) models = this.parse(models, options);\n\n      var singular = !_.isArray(models);\n      models = singular ? [models] : models.slice();\n\n      var at = options.at;\n      if (at != null) at = +at;\n      if (at < 0) at += this.length + 1;\n\n      var set = [];\n      var toAdd = [];\n      var toRemove = [];\n      var modelMap = {};\n\n      var add = options.add;\n      var merge = options.merge;\n      var remove = options.remove;\n\n      var sort = false;\n      var sortable = this.comparator && (at == null) && options.sort !== false;\n      var sortAttr = _.isString(this.comparator) ? this.comparator : null;\n\n      // Turn bare objects into model references, and prevent invalid models\n      // from being added.\n      var model;\n      for (var i = 0; i < models.length; i++) {\n        model = models[i];\n\n        // If a duplicate is found, prevent it from being added and\n        // optionally merge it into the existing model.\n        var existing = this.get(model);\n        if (existing) {\n          if (merge && model !== existing) {\n            var attrs = this._isModel(model) ? model.attributes : model;\n            if (options.parse) attrs = existing.parse(attrs, options);\n            existing.set(attrs, options);\n            if (sortable && !sort) sort = existing.hasChanged(sortAttr);\n          }\n          if (!modelMap[existing.cid]) {\n            modelMap[existing.cid] = true;\n            set.push(existing);\n          }\n          models[i] = existing;\n\n        // If this is a new, valid model, push it to the `toAdd` list.\n        } else if (add) {\n          model = models[i] = this._prepareModel(model, options);\n          if (model) {\n            toAdd.push(model);\n            this._addReference(model, options);\n            modelMap[model.cid] = true;\n            set.push(model);\n          }\n        }\n      }\n\n      // Remove stale models.\n      if (remove) {\n        for (i = 0; i < this.length; i++) {\n          model = this.models[i];\n          if (!modelMap[model.cid]) toRemove.push(model);\n        }\n        if (toRemove.length) this._removeModels(toRemove, options);\n      }\n\n      // See if sorting is needed, update `length` and splice in new models.\n      var orderChanged = false;\n      var replace = !sortable && add && remove;\n      if (set.length && replace) {\n        orderChanged = this.length != set.length || _.some(this.models, function(model, index) {\n          return model !== set[index];\n        });\n        this.models.length = 0;\n        splice(this.models, set, 0);\n        this.length = this.models.length;\n      } else if (toAdd.length) {\n        if (sortable) sort = true;\n        splice(this.models, toAdd, at == null ? this.length : at);\n        this.length = this.models.length;\n      }\n\n      // Silently sort the collection if appropriate.\n      if (sort) this.sort({silent: true});\n\n      // Unless silenced, it's time to fire all appropriate add/sort events.\n      if (!options.silent) {\n        for (i = 0; i < toAdd.length; i++) {\n          if (at != null) options.index = at + i;\n          model = toAdd[i];\n          model.trigger('add', model, this, options);\n        }\n        if (sort || orderChanged) this.trigger('sort', this, options);\n        if (toAdd.length || toRemove.length) this.trigger('update', this, options);\n      }\n\n      // Return the added (or merged) model (or models).\n      return singular ? models[0] : models;\n    },\n\n    // When you have more items than you want to add or remove individually,\n    // you can reset the entire set with a new list of models, without firing\n    // any granular `add` or `remove` events. Fires `reset` when finished.\n    // Useful for bulk operations and optimizations.\n    reset: function(models, options) {\n      options = options ? _.clone(options) : {};\n      for (var i = 0; i < this.models.length; i++) {\n        this._removeReference(this.models[i], options);\n      }\n      options.previousModels = this.models;\n      this._reset();\n      models = this.add(models, _.extend({silent: true}, options));\n      if (!options.silent) this.trigger('reset', this, options);\n      return models;\n    },\n\n    // Add a model to the end of the collection.\n    push: function(model, options) {\n      return this.add(model, _.extend({at: this.length}, options));\n    },\n\n    // Remove a model from the end of the collection.\n    pop: function(options) {\n      var model = this.at(this.length - 1);\n      return this.remove(model, options);\n    },\n\n    // Add a model to the beginning of the collection.\n    unshift: function(model, options) {\n      return this.add(model, _.extend({at: 0}, options));\n    },\n\n    // Remove a model from the beginning of the collection.\n    shift: function(options) {\n      var model = this.at(0);\n      return this.remove(model, options);\n    },\n\n    // Slice out a sub-array of models from the collection.\n    slice: function() {\n      return slice.apply(this.models, arguments);\n    },\n\n    // Get a model from the set by id.\n    get: function(obj) {\n      if (obj == null) return void 0;\n      var id = this.modelId(this._isModel(obj) ? obj.attributes : obj);\n      return this._byId[obj] || this._byId[id] || this._byId[obj.cid];\n    },\n\n    // Get the model at the given index.\n    at: function(index) {\n      if (index < 0) index += this.length;\n      return this.models[index];\n    },\n\n    // Return models with matching attributes. Useful for simple cases of\n    // `filter`.\n    where: function(attrs, first) {\n      return this[first ? 'find' : 'filter'](attrs);\n    },\n\n    // Return the first model with matching attributes. Useful for simple cases\n    // of `find`.\n    findWhere: function(attrs) {\n      return this.where(attrs, true);\n    },\n\n    // Force the collection to re-sort itself. You don't need to call this under\n    // normal circumstances, as the set will maintain sort order as each item\n    // is added.\n    sort: function(options) {\n      var comparator = this.comparator;\n      if (!comparator) throw new Error('Cannot sort a set without a comparator');\n      options || (options = {});\n\n      var length = comparator.length;\n      if (_.isFunction(comparator)) comparator = _.bind(comparator, this);\n\n      // Run sort based on type of `comparator`.\n      if (length === 1 || _.isString(comparator)) {\n        this.models = this.sortBy(comparator);\n      } else {\n        this.models.sort(comparator);\n      }\n      if (!options.silent) this.trigger('sort', this, options);\n      return this;\n    },\n\n    // Pluck an attribute from each model in the collection.\n    pluck: function(attr) {\n      return _.invoke(this.models, 'get', attr);\n    },\n\n    // Fetch the default set of models for this collection, resetting the\n    // collection when they arrive. If `reset: true` is passed, the response\n    // data will be passed through the `reset` method instead of `set`.\n    fetch: function(options) {\n      options = _.extend({parse: true}, options);\n      var success = options.success;\n      var collection = this;\n      options.success = function(resp) {\n        var method = options.reset ? 'reset' : 'set';\n        collection[method](resp, options);\n        if (success) success.call(options.context, collection, resp, options);\n        collection.trigger('sync', collection, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Create a new instance of a model in this collection. Add the model to the\n    // collection immediately, unless `wait: true` is passed, in which case we\n    // wait for the server to agree.\n    create: function(model, options) {\n      options = options ? _.clone(options) : {};\n      var wait = options.wait;\n      model = this._prepareModel(model, options);\n      if (!model) return false;\n      if (!wait) this.add(model, options);\n      var collection = this;\n      var success = options.success;\n      options.success = function(model, resp, callbackOpts) {\n        if (wait) collection.add(model, callbackOpts);\n        if (success) success.call(callbackOpts.context, model, resp, callbackOpts);\n      };\n      model.save(null, options);\n      return model;\n    },\n\n    // **parse** converts a response into a list of models to be added to the\n    // collection. The default implementation is just to pass it through.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new collection with an identical list of models as this one.\n    clone: function() {\n      return new this.constructor(this.models, {\n        model: this.model,\n        comparator: this.comparator\n      });\n    },\n\n    // Define how to uniquely identify models in the collection.\n    modelId: function (attrs) {\n      return attrs[this.model.prototype.idAttribute || 'id'];\n    },\n\n    // Private method to reset all internal state. Called when the collection\n    // is first initialized or reset.\n    _reset: function() {\n      this.length = 0;\n      this.models = [];\n      this._byId  = {};\n    },\n\n    // Prepare a hash of attributes (or other model) to be added to this\n    // collection.\n    _prepareModel: function(attrs, options) {\n      if (this._isModel(attrs)) {\n        if (!attrs.collection) attrs.collection = this;\n        return attrs;\n      }\n      options = options ? _.clone(options) : {};\n      options.collection = this;\n      var model = new this.model(attrs, options);\n      if (!model.validationError) return model;\n      this.trigger('invalid', this, model.validationError, options);\n      return false;\n    },\n\n    // Internal method called by both remove and set.\n    _removeModels: function(models, options) {\n      var removed = [];\n      for (var i = 0; i < models.length; i++) {\n        var model = this.get(models[i]);\n        if (!model) continue;\n\n        var index = this.indexOf(model);\n        this.models.splice(index, 1);\n        this.length--;\n\n        if (!options.silent) {\n          options.index = index;\n          model.trigger('remove', model, this, options);\n        }\n\n        removed.push(model);\n        this._removeReference(model, options);\n      }\n      return removed.length ? removed : false;\n    },\n\n    // Method for checking whether an object should be considered a model for\n    // the purposes of adding to the collection.\n    _isModel: function (model) {\n      return model instanceof Model;\n    },\n\n    // Internal method to create a model's ties to a collection.\n    _addReference: function(model, options) {\n      this._byId[model.cid] = model;\n      var id = this.modelId(model.attributes);\n      if (id != null) this._byId[id] = model;\n      model.on('all', this._onModelEvent, this);\n    },\n\n    // Internal method to sever a model's ties to a collection.\n    _removeReference: function(model, options) {\n      delete this._byId[model.cid];\n      var id = this.modelId(model.attributes);\n      if (id != null) delete this._byId[id];\n      if (this === model.collection) delete model.collection;\n      model.off('all', this._onModelEvent, this);\n    },\n\n    // Internal method called every time a model in the set fires an event.\n    // Sets need to update their indexes when models change ids. All other\n    // events simply proxy through. \"add\" and \"remove\" events that originate\n    // in other collections are ignored.\n    _onModelEvent: function(event, model, collection, options) {\n      if ((event === 'add' || event === 'remove') && collection !== this) return;\n      if (event === 'destroy') this.remove(model, options);\n      if (event === 'change') {\n        var prevId = this.modelId(model.previousAttributes());\n        var id = this.modelId(model.attributes);\n        if (prevId !== id) {\n          if (prevId != null) delete this._byId[prevId];\n          if (id != null) this._byId[id] = model;\n        }\n      }\n      this.trigger.apply(this, arguments);\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Collection.\n  // 90% of the core usefulness of Backbone Collections is actually implemented\n  // right here:\n  var collectionMethods = { forEach: 3, each: 3, map: 3, collect: 3, reduce: 4,\n      foldl: 4, inject: 4, reduceRight: 4, foldr: 4, find: 3, detect: 3, filter: 3,\n      select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,\n      contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,\n      head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,\n      without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,\n      isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,\n      sortBy: 3, indexBy: 3};\n\n  // Mix in each Underscore method as a proxy to `Collection#models`.\n  addUnderscoreMethods(Collection, collectionMethods, 'models');\n\n  // Backbone.View\n  // -------------\n\n  // Backbone Views are almost more convention than they are actual code. A View\n  // is simply a JavaScript object that represents a logical chunk of UI in the\n  // DOM. This might be a single item, an entire list, a sidebar or panel, or\n  // even the surrounding frame which wraps your whole app. Defining a chunk of\n  // UI as a **View** allows you to define your DOM events declaratively, without\n  // having to worry about render order ... and makes it easy for the view to\n  // react to specific changes in the state of your models.\n\n  // Creating a Backbone.View creates its initial element outside of the DOM,\n  // if an existing element is not provided...\n  var View = Backbone.View = function(options) {\n    this.cid = _.uniqueId('view');\n    _.extend(this, _.pick(options, viewOptions));\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regex to split keys for `delegate`.\n  var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n  // List of view options to be set as properties.\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\n\n  // Set up all inheritable **Backbone.View** properties and methods.\n  _.extend(View.prototype, Events, {\n\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n\n    // jQuery delegate for element lookup, scoped to DOM elements within the\n    // current view. This should be preferred to global lookups where possible.\n    $: function(selector) {\n      return this.$el.find(selector);\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // **render** is the core function that your view should override, in order\n    // to populate its element (`this.el`), with the appropriate HTML. The\n    // convention is for **render** to always return `this`.\n    render: function() {\n      return this;\n    },\n\n    // Remove this view by taking the element out of the DOM, and removing any\n    // applicable Backbone.Events listeners.\n    remove: function() {\n      this._removeElement();\n      this.stopListening();\n      return this;\n    },\n\n    // Remove this view's element from the document and all event listeners\n    // attached to it. Exposed for subclasses using an alternative DOM\n    // manipulation API.\n    _removeElement: function() {\n      this.$el.remove();\n    },\n\n    // Change the view's element (`this.el` property) and re-delegate the\n    // view's events on the new element.\n    setElement: function(element) {\n      this.undelegateEvents();\n      this._setElement(element);\n      this.delegateEvents();\n      return this;\n    },\n\n    // Creates the `this.el` and `this.$el` references for this view using the\n    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery\n    // context or an element. Subclasses can override this to utilize an\n    // alternative DOM manipulation API and are only required to set the\n    // `this.el` property.\n    _setElement: function(el) {\n      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);\n      this.el = this.$el[0];\n    },\n\n    // Set callbacks, where `this.events` is a hash of\n    //\n    // *{\"event selector\": \"callback\"}*\n    //\n    //     {\n    //       'mousedown .title':  'edit',\n    //       'click .button':     'save',\n    //       'click .open':       function(e) { ... }\n    //     }\n    //\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\n    // Uses event delegation for efficiency.\n    // Omitting the selector binds the event to `this.el`.\n    delegateEvents: function(events) {\n      events || (events = _.result(this, 'events'));\n      if (!events) return this;\n      this.undelegateEvents();\n      for (var key in events) {\n        var method = events[key];\n        if (!_.isFunction(method)) method = this[method];\n        if (!method) continue;\n        var match = key.match(delegateEventSplitter);\n        this.delegate(match[1], match[2], _.bind(method, this));\n      }\n      return this;\n    },\n\n    // Add a single event listener to the view's element (or a child element\n    // using `selector`). This only works for delegate-able events: not `focus`,\n    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.\n    delegate: function(eventName, selector, listener) {\n      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);\n      return this;\n    },\n\n    // Clears all callbacks previously bound to the view by `delegateEvents`.\n    // You usually don't need to use this, but may wish to if you have multiple\n    // Backbone views attached to the same DOM element.\n    undelegateEvents: function() {\n      if (this.$el) this.$el.off('.delegateEvents' + this.cid);\n      return this;\n    },\n\n    // A finer-grained `undelegateEvents` for removing a single delegated event.\n    // `selector` and `listener` are both optional.\n    undelegate: function(eventName, selector, listener) {\n      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);\n      return this;\n    },\n\n    // Produces a DOM element to be assigned to your view. Exposed for\n    // subclasses using an alternative DOM manipulation API.\n    _createElement: function(tagName) {\n      return document.createElement(tagName);\n    },\n\n    // Ensure that the View has a DOM element to render into.\n    // If `this.el` is a string, pass it through `$()`, take the first\n    // matching element, and re-assign it to `el`. Otherwise, create\n    // an element from the `id`, `className` and `tagName` properties.\n    _ensureElement: function() {\n      if (!this.el) {\n        var attrs = _.extend({}, _.result(this, 'attributes'));\n        if (this.id) attrs.id = _.result(this, 'id');\n        if (this.className) attrs['class'] = _.result(this, 'className');\n        this.setElement(this._createElement(_.result(this, 'tagName')));\n        this._setAttributes(attrs);\n      } else {\n        this.setElement(_.result(this, 'el'));\n      }\n    },\n\n    // Set attributes from a hash on this view's element.  Exposed for\n    // subclasses using an alternative DOM manipulation API.\n    _setAttributes: function(attributes) {\n      this.$el.attr(attributes);\n    }\n\n  });\n\n  // Backbone.sync\n  // -------------\n\n  // Override this function to change the manner in which Backbone persists\n  // models to the server. You will be passed the type of request, and the\n  // model in question. By default, makes a RESTful Ajax request\n  // to the model's `url()`. Some possible customizations could be:\n  //\n  // * Use `setTimeout` to batch rapid-fire updates into a single request.\n  // * Send up the models as XML instead of JSON.\n  // * Persist models via WebSockets instead of Ajax.\n  //\n  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n  // as `POST`, with a `_method` parameter containing the true HTTP method,\n  // as well as all requests with the body as `application/x-www-form-urlencoded`\n  // instead of `application/json` with the model in a param named `model`.\n  // Useful when interfacing with server-side languages like **PHP** that make\n  // it difficult to read the body of `PUT` requests.\n  Backbone.sync = function(method, model, options) {\n    var type = methodMap[method];\n\n    // Default options, unless specified.\n    _.defaults(options || (options = {}), {\n      emulateHTTP: Backbone.emulateHTTP,\n      emulateJSON: Backbone.emulateJSON\n    });\n\n    // Default JSON-request options.\n    var params = {type: type, dataType: 'json'};\n\n    // Ensure that we have a URL.\n    if (!options.url) {\n      params.url = _.result(model, 'url') || urlError();\n    }\n\n    // Ensure that we have the appropriate request data.\n    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\n      params.contentType = 'application/json';\n      params.data = JSON.stringify(options.attrs || model.toJSON(options));\n    }\n\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\n    if (options.emulateJSON) {\n      params.contentType = 'application/x-www-form-urlencoded';\n      params.data = params.data ? {model: params.data} : {};\n    }\n\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n    // And an `X-HTTP-Method-Override` header.\n    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\n      params.type = 'POST';\n      if (options.emulateJSON) params.data._method = type;\n      var beforeSend = options.beforeSend;\n      options.beforeSend = function(xhr) {\n        xhr.setRequestHeader('X-HTTP-Method-Override', type);\n        if (beforeSend) return beforeSend.apply(this, arguments);\n      };\n    }\n\n    // Don't process data on a non-GET request.\n    if (params.type !== 'GET' && !options.emulateJSON) {\n      params.processData = false;\n    }\n\n    // Pass along `textStatus` and `errorThrown` from jQuery.\n    var error = options.error;\n    options.error = function(xhr, textStatus, errorThrown) {\n      options.textStatus = textStatus;\n      options.errorThrown = errorThrown;\n      if (error) error.call(options.context, xhr, textStatus, errorThrown);\n    };\n\n    // Make the request, allowing the user to override any Ajax options.\n    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\n    model.trigger('request', model, xhr, options);\n    return xhr;\n  };\n\n  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\n  var methodMap = {\n    'create': 'POST',\n    'update': 'PUT',\n    'patch':  'PATCH',\n    'delete': 'DELETE',\n    'read':   'GET'\n  };\n\n  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\n  // Override this if you'd like to use a different library.\n  Backbone.ajax = function() {\n    return Backbone.$.ajax.apply(Backbone.$, arguments);\n  };\n\n  // Backbone.Router\n  // ---------------\n\n  // Routers map faux-URLs to actions, and fire events when routes are\n  // matched. Creating a new one sets its `routes` hash, if not set statically.\n  var Router = Backbone.Router = function(options) {\n    options || (options = {});\n    if (options.routes) this.routes = options.routes;\n    this._bindRoutes();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regular expressions for matching named param parts and splatted\n  // parts of route strings.\n  var optionalParam = /\\((.*?)\\)/g;\n  var namedParam    = /(\\(\\?)?:\\w+/g;\n  var splatParam    = /\\*\\w+/g;\n  var escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n  // Set up all inheritable **Backbone.Router** properties and methods.\n  _.extend(Router.prototype, Events, {\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Manually bind a single named route to a callback. For example:\n    //\n    //     this.route('search/:query/p:num', 'search', function(query, num) {\n    //       ...\n    //     });\n    //\n    route: function(route, name, callback) {\n      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\n      if (_.isFunction(name)) {\n        callback = name;\n        name = '';\n      }\n      if (!callback) callback = this[name];\n      var router = this;\n      Backbone.history.route(route, function(fragment) {\n        var args = router._extractParameters(route, fragment);\n        if (router.execute(callback, args, name) !== false) {\n          router.trigger.apply(router, ['route:' + name].concat(args));\n          router.trigger('route', name, args);\n          Backbone.history.trigger('route', router, name, args);\n        }\n      });\n      return this;\n    },\n\n    // Execute a route handler with the provided parameters.  This is an\n    // excellent place to do pre-route setup or post-route cleanup.\n    execute: function(callback, args, name) {\n      if (callback) callback.apply(this, args);\n    },\n\n    // Simple proxy to `Backbone.history` to save a fragment into the history.\n    navigate: function(fragment, options) {\n      Backbone.history.navigate(fragment, options);\n      return this;\n    },\n\n    // Bind all defined routes to `Backbone.history`. We have to reverse the\n    // order of the routes here to support behavior where the most general\n    // routes can be defined at the bottom of the route map.\n    _bindRoutes: function() {\n      if (!this.routes) return;\n      this.routes = _.result(this, 'routes');\n      var route, routes = _.keys(this.routes);\n      while ((route = routes.pop()) != null) {\n        this.route(route, this.routes[route]);\n      }\n    },\n\n    // Convert a route string into a regular expression, suitable for matching\n    // against the current location hash.\n    _routeToRegExp: function(route) {\n      route = route.replace(escapeRegExp, '\\\\$&')\n                   .replace(optionalParam, '(?:$1)?')\n                   .replace(namedParam, function(match, optional) {\n                     return optional ? match : '([^/?]+)';\n                   })\n                   .replace(splatParam, '([^?]*?)');\n      return new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$');\n    },\n\n    // Given a route, and a URL fragment that it matches, return the array of\n    // extracted decoded parameters. Empty or unmatched parameters will be\n    // treated as `null` to normalize cross-browser behavior.\n    _extractParameters: function(route, fragment) {\n      var params = route.exec(fragment).slice(1);\n      return _.map(params, function(param, i) {\n        // Don't decode the search params.\n        if (i === params.length - 1) return param || null;\n        return param ? decodeURIComponent(param) : null;\n      });\n    }\n\n  });\n\n  // Backbone.History\n  // ----------------\n\n  // Handles cross-browser history management, based on either\n  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n  // and URL fragments. If the browser supports neither (old IE, natch),\n  // falls back to polling.\n  var History = Backbone.History = function() {\n    this.handlers = [];\n    this.checkUrl = _.bind(this.checkUrl, this);\n\n    // Ensure that `History` can be used outside of the browser.\n    if (typeof window !== 'undefined') {\n      this.location = window.location;\n      this.history = window.history;\n    }\n  };\n\n  // Cached regex for stripping a leading hash/slash and trailing space.\n  var routeStripper = /^[#\\/]|\\s+$/g;\n\n  // Cached regex for stripping leading and trailing slashes.\n  var rootStripper = /^\\/+|\\/+$/g;\n\n  // Cached regex for stripping urls of hash.\n  var pathStripper = /#.*$/;\n\n  // Has the history handling already been started?\n  History.started = false;\n\n  // Set up all inheritable **Backbone.History** properties and methods.\n  _.extend(History.prototype, Events, {\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    interval: 50,\n\n    // Are we at the app root?\n    atRoot: function() {\n      var path = this.location.pathname.replace(/[^\\/]$/, '$&/');\n      return path === this.root && !this.getSearch();\n    },\n\n    // Does the pathname match the root?\n    matchRoot: function() {\n      var path = this.decodeFragment(this.location.pathname);\n      var root = path.slice(0, this.root.length - 1) + '/';\n      return root === this.root;\n    },\n\n    // Unicode characters in `location.pathname` are percent encoded so they're\n    // decoded for comparison. `%25` should not be decoded since it may be part\n    // of an encoded parameter.\n    decodeFragment: function(fragment) {\n      return decodeURI(fragment.replace(/%25/g, '%2525'));\n    },\n\n    // In IE6, the hash fragment and search params are incorrect if the\n    // fragment contains `?`.\n    getSearch: function() {\n      var match = this.location.href.replace(/#.*/, '').match(/\\?.+/);\n      return match ? match[0] : '';\n    },\n\n    // Gets the true hash value. Cannot use location.hash directly due to bug\n    // in Firefox where location.hash will always be decoded.\n    getHash: function(window) {\n      var match = (window || this).location.href.match(/#(.*)$/);\n      return match ? match[1] : '';\n    },\n\n    // Get the pathname and search params, without the root.\n    getPath: function() {\n      var path = this.decodeFragment(\n        this.location.pathname + this.getSearch()\n      ).slice(this.root.length - 1);\n      return path.charAt(0) === '/' ? path.slice(1) : path;\n    },\n\n    // Get the cross-browser normalized URL fragment from the path or hash.\n    getFragment: function(fragment) {\n      if (fragment == null) {\n        if (this._usePushState || !this._wantsHashChange) {\n          fragment = this.getPath();\n        } else {\n          fragment = this.getHash();\n        }\n      }\n      return fragment.replace(routeStripper, '');\n    },\n\n    // Start the hash change handling, returning `true` if the current URL matches\n    // an existing route, and `false` otherwise.\n    start: function(options) {\n      if (History.started) throw new Error('Backbone.history has already been started');\n      History.started = true;\n\n      // Figure out the initial configuration. Do we need an iframe?\n      // Is pushState desired ... is it available?\n      this.options          = _.extend({root: '/'}, this.options, options);\n      this.root             = this.options.root;\n      this._wantsHashChange = this.options.hashChange !== false;\n      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);\n      this._useHashChange   = this._wantsHashChange && this._hasHashChange;\n      this._wantsPushState  = !!this.options.pushState;\n      this._hasPushState    = !!(this.history && this.history.pushState);\n      this._usePushState    = this._wantsPushState && this._hasPushState;\n      this.fragment         = this.getFragment();\n\n      // Normalize root to always include a leading and trailing slash.\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n\n      // Transition from hashChange to pushState or vice versa if both are\n      // requested.\n      if (this._wantsHashChange && this._wantsPushState) {\n\n        // If we've started off with a route from a `pushState`-enabled\n        // browser, but we're currently in a browser that doesn't support it...\n        if (!this._hasPushState && !this.atRoot()) {\n          var root = this.root.slice(0, -1) || '/';\n          this.location.replace(root + '#' + this.getPath());\n          // Return immediately as browser will do redirect to new url\n          return true;\n\n        // Or if we've started out with a hash-based route, but we're currently\n        // in a browser where it could be `pushState`-based instead...\n        } else if (this._hasPushState && this.atRoot()) {\n          this.navigate(this.getHash(), {replace: true});\n        }\n\n      }\n\n      // Proxy an iframe to handle location events if the browser doesn't\n      // support the `hashchange` event, HTML5 history, or the user wants\n      // `hashChange` but not `pushState`.\n      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {\n        this.iframe = document.createElement('iframe');\n        this.iframe.src = 'javascript:0';\n        this.iframe.style.display = 'none';\n        this.iframe.tabIndex = -1;\n        var body = document.body;\n        // Using `appendChild` will throw on IE < 9 if the document is not ready.\n        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;\n        iWindow.document.open();\n        iWindow.document.close();\n        iWindow.location.hash = '#' + this.fragment;\n      }\n\n      // Add a cross-platform `addEventListener` shim for older browsers.\n      var addEventListener = window.addEventListener || function (eventName, listener) {\n        return attachEvent('on' + eventName, listener);\n      };\n\n      // Depending on whether we're using pushState or hashes, and whether\n      // 'onhashchange' is supported, determine how we check the URL state.\n      if (this._usePushState) {\n        addEventListener('popstate', this.checkUrl, false);\n      } else if (this._useHashChange && !this.iframe) {\n        addEventListener('hashchange', this.checkUrl, false);\n      } else if (this._wantsHashChange) {\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n      }\n\n      if (!this.options.silent) return this.loadUrl();\n    },\n\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n    // but possibly useful for unit testing Routers.\n    stop: function() {\n      // Add a cross-platform `removeEventListener` shim for older browsers.\n      var removeEventListener = window.removeEventListener || function (eventName, listener) {\n        return detachEvent('on' + eventName, listener);\n      };\n\n      // Remove window listeners.\n      if (this._usePushState) {\n        removeEventListener('popstate', this.checkUrl, false);\n      } else if (this._useHashChange && !this.iframe) {\n        removeEventListener('hashchange', this.checkUrl, false);\n      }\n\n      // Clean up the iframe if necessary.\n      if (this.iframe) {\n        document.body.removeChild(this.iframe);\n        this.iframe = null;\n      }\n\n      // Some environments will throw when clearing an undefined interval.\n      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);\n      History.started = false;\n    },\n\n    // Add a route to be tested when the fragment changes. Routes added later\n    // may override previous routes.\n    route: function(route, callback) {\n      this.handlers.unshift({route: route, callback: callback});\n    },\n\n    // Checks the current URL to see if it has changed, and if it has,\n    // calls `loadUrl`, normalizing across the hidden iframe.\n    checkUrl: function(e) {\n      var current = this.getFragment();\n\n      // If the user pressed the back button, the iframe's hash will have\n      // changed and we should use that for comparison.\n      if (current === this.fragment && this.iframe) {\n        current = this.getHash(this.iframe.contentWindow);\n      }\n\n      if (current === this.fragment) return false;\n      if (this.iframe) this.navigate(current);\n      this.loadUrl();\n    },\n\n    // Attempt to load the current URL fragment. If a route succeeds with a\n    // match, returns `true`. If no defined routes matches the fragment,\n    // returns `false`.\n    loadUrl: function(fragment) {\n      // If the root doesn't match, no routes can match either.\n      if (!this.matchRoot()) return false;\n      fragment = this.fragment = this.getFragment(fragment);\n      return _.some(this.handlers, function(handler) {\n        if (handler.route.test(fragment)) {\n          handler.callback(fragment);\n          return true;\n        }\n      });\n    },\n\n    // Save a fragment into the hash history, or replace the URL state if the\n    // 'replace' option is passed. You are responsible for properly URL-encoding\n    // the fragment in advance.\n    //\n    // The options object can contain `trigger: true` if you wish to have the\n    // route callback be fired (not usually desirable), or `replace: true`, if\n    // you wish to modify the current URL without adding an entry to the history.\n    navigate: function(fragment, options) {\n      if (!History.started) return false;\n      if (!options || options === true) options = {trigger: !!options};\n\n      // Normalize the fragment.\n      fragment = this.getFragment(fragment || '');\n\n      // Don't include a trailing slash on the root.\n      var root = this.root;\n      if (fragment === '' || fragment.charAt(0) === '?') {\n        root = root.slice(0, -1) || '/';\n      }\n      var url = root + fragment;\n\n      // Strip the hash and decode for matching.\n      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));\n\n      if (this.fragment === fragment) return;\n      this.fragment = fragment;\n\n      // If pushState is available, we use it to set the fragment as a real URL.\n      if (this._usePushState) {\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n      // If hash changes haven't been explicitly disabled, update the hash\n      // fragment to store history.\n      } else if (this._wantsHashChange) {\n        this._updateHash(this.location, fragment, options.replace);\n        if (this.iframe && (fragment !== this.getHash(this.iframe.contentWindow))) {\n          var iWindow = this.iframe.contentWindow;\n\n          // Opening and closing the iframe tricks IE7 and earlier to push a\n          // history entry on hash-tag change.  When replace is true, we don't\n          // want this.\n          if (!options.replace) {\n            iWindow.document.open();\n            iWindow.document.close();\n          }\n\n          this._updateHash(iWindow.location, fragment, options.replace);\n        }\n\n      // If you've told us that you explicitly don't want fallback hashchange-\n      // based history, then `navigate` becomes a page refresh.\n      } else {\n        return this.location.assign(url);\n      }\n      if (options.trigger) return this.loadUrl(fragment);\n    },\n\n    // Update the hash location, either replacing the current entry, or adding\n    // a new one to the browser history.\n    _updateHash: function(location, fragment, replace) {\n      if (replace) {\n        var href = location.href.replace(/(javascript:|#).*$/, '');\n        location.replace(href + '#' + fragment);\n      } else {\n        // Some browsers require that `hash` contains a leading #.\n        location.hash = '#' + fragment;\n      }\n    }\n\n  });\n\n  // Create the default Backbone.history.\n  Backbone.history = new History;\n\n  // Helpers\n  // -------\n\n  // Helper function to correctly set up the prototype chain for subclasses.\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\n  // class properties to be extended.\n  var extend = function(protoProps, staticProps) {\n    var parent = this;\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent constructor.\n    if (protoProps && _.has(protoProps, 'constructor')) {\n      child = protoProps.constructor;\n    } else {\n      child = function(){ return parent.apply(this, arguments); };\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    _.extend(child, parent, staticProps);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent` constructor function.\n    var Surrogate = function(){ this.constructor = child; };\n    Surrogate.prototype = parent.prototype;\n    child.prototype = new Surrogate;\n\n    // Add prototype properties (instance properties) to the subclass,\n    // if supplied.\n    if (protoProps) _.extend(child.prototype, protoProps);\n\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    child.__super__ = parent.prototype;\n\n    return child;\n  };\n\n  // Set up inheritance for the model, collection, router, view and history.\n  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\n\n  // Throw an error when a URL is needed, and none is supplied.\n  var urlError = function() {\n    throw new Error('A \"url\" property or function must be specified');\n  };\n\n  // Wrap an optional error callback with a fallback error event.\n  var wrapError = function(model, options) {\n    var error = options.error;\n    options.error = function(resp) {\n      if (error) error.call(options.context, model, resp, options);\n      model.trigger('error', model, resp, options);\n    };\n  };\n\n  return Backbone;\n\n}));\n","//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.8.3';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result  either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value)) return _.matcher(value);\n    return _.property(value);\n  };\n  _.iteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, undefinedOnly) {\n    return function(obj) {\n      var length = arguments.length;\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var property = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = property('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  function createReduce(dir) {\n    // Optimized iterator function as using arguments.length\n    // in the main function will deoptimize the, see #1991.\n    function iterator(obj, iteratee, memo, keys, index, length) {\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    }\n\n    return function(obj, iteratee, memo, context) {\n      iteratee = optimizeCb(iteratee, context, 4);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      // Determine the initial value if none is provided.\n      if (arguments.length < 3) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      return iterator(obj, iteratee, memo, keys, index, length);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var key;\n    if (isArrayLike(obj)) {\n      key = _.findIndex(obj, predicate, context);\n    } else {\n      key = _.findKey(obj, predicate, context);\n    }\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      var func = isFunc ? method : value[method];\n      return func == null ? func : func.apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\n  _.shuffle = function(obj) {\n    var set = isArrayLike(obj) ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, startIndex) {\n    var output = [], idx = 0;\n    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        //flatten current level of array or arguments object\n        if (!shallow) value = flatten(value, shallow, strict);\n        var j = 0, len = value.length;\n        output.length += len;\n        while (j < len) {\n          output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(arguments, true, true, 1);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    return _.unzip(arguments);\n  };\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions\n  function createPredicateIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a predicate test\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n            i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var args = slice.call(arguments, 2);\n    var bound = function() {\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  function collectNonEnumProps(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object\n  // In contrast to _.map it returns an object\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys =  _.keys(obj),\n          length = keys.length,\n          results = {},\n          currentKey;\n      for (var index = 0; index < length; index++) {\n        currentKey = keys[index];\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(object, oiteratee, context) {\n    var result = {}, obj = object, iteratee, keys;\n    if (obj == null) return result;\n    if (_.isFunction(oiteratee)) {\n      keys = _.allKeys(obj);\n      iteratee = optimizeCb(oiteratee, context);\n    } else {\n      keys = flatten(arguments, false, false, 1);\n      iteratee = function(value, key, obj) { return key in obj; };\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(flatten(arguments, false, false, 1), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), and in Safari 8 (#1929).\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = property;\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    return obj == null ? function(){} : function(key) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property, fallback) {\n    var value = object == null ? void 0 : object[property];\n    if (value === void 0) {\n      value = fallback;\n    }\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return '' + this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this));\n","","/*globals module, URL*/\n\nimport Morph from \"./htmlbars-runtime/morph\";\nimport AttrMorph from \"./morph-attr\";\nimport {\n  buildHTMLDOM,\n  svgNamespace,\n  svgHTMLIntegrationPoints\n} from \"./dom-helper/build-html-dom\";\nimport {\n  addClasses,\n  removeClasses\n} from \"./dom-helper/classes\";\nimport {\n  normalizeProperty\n} from \"./dom-helper/prop\";\nimport { isAttrRemovalValue } from \"./dom-helper/prop\";\n\nvar doc = typeof document === 'undefined' ? false : document;\n\nvar deletesBlankTextNodes = doc && (function(document){\n  var element = document.createElement('div');\n  element.appendChild( document.createTextNode('') );\n  var clonedElement = element.cloneNode(true);\n  return clonedElement.childNodes.length === 0;\n})(doc);\n\nvar ignoresCheckedAttribute = doc && (function(document){\n  var element = document.createElement('input');\n  element.setAttribute('checked', 'checked');\n  var clonedElement = element.cloneNode(false);\n  return !clonedElement.checked;\n})(doc);\n\nvar canRemoveSvgViewBoxAttribute = doc && (doc.createElementNS ? (function(document){\n  var element = document.createElementNS(svgNamespace, 'svg');\n  element.setAttribute('viewBox', '0 0 100 100');\n  element.removeAttribute('viewBox');\n  return !element.getAttribute('viewBox');\n})(doc) : true);\n\nvar canClone = doc && (function(document){\n  var element = document.createElement('div');\n  element.appendChild( document.createTextNode(' '));\n  element.appendChild( document.createTextNode(' '));\n  var clonedElement = element.cloneNode(true);\n  return clonedElement.childNodes[0].nodeValue === ' ';\n})(doc);\n\n// This is not the namespace of the element, but of\n// the elements inside that elements.\nfunction interiorNamespace(element){\n  if (\n    element &&\n    element.namespaceURI === svgNamespace &&\n    !svgHTMLIntegrationPoints[element.tagName]\n  ) {\n    return svgNamespace;\n  } else {\n    return null;\n  }\n}\n\n// The HTML spec allows for \"omitted start tags\". These tags are optional\n// when their intended child is the first thing in the parent tag. For\n// example, this is a tbody start tag:\n//\n// <table>\n//   <tbody>\n//     <tr>\n//\n// The tbody may be omitted, and the browser will accept and render:\n//\n// <table>\n//   <tr>\n//\n// However, the omitted start tag will still be added to the DOM. Here\n// we test the string and context to see if the browser is about to\n// perform this cleanup.\n//\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#optional-tags\n// describes which tags are omittable. The spec for tbody and colgroup\n// explains this behavior:\n//\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/tables.html#the-tbody-element\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/tables.html#the-colgroup-element\n//\n\nvar omittedStartTagChildTest = /<([\\w:]+)/;\nfunction detectOmittedStartTag(string, contextualElement){\n  // Omitted start tags are only inside table tags.\n  if (contextualElement.tagName === 'TABLE') {\n    var omittedStartTagChildMatch = omittedStartTagChildTest.exec(string);\n    if (omittedStartTagChildMatch) {\n      var omittedStartTagChild = omittedStartTagChildMatch[1];\n      // It is already asserted that the contextual element is a table\n      // and not the proper start tag. Just see if a tag was omitted.\n      return omittedStartTagChild === 'tr' ||\n             omittedStartTagChild === 'col';\n    }\n  }\n}\n\nfunction buildSVGDOM(html, dom){\n  var div = dom.document.createElement('div');\n  div.innerHTML = '<svg>'+html+'</svg>';\n  return div.firstChild.childNodes;\n}\n\nvar guid = 1;\n\nfunction ElementMorph(element, dom, namespace) {\n  this.element = element;\n  this.dom = dom;\n  this.namespace = namespace;\n  this.guid = \"element\" + guid++;\n\n  this._state = undefined;\n  this.isDirty = true;\n}\n\nElementMorph.prototype.getState = function() {\n  if (!this._state) {\n    this._state = {};\n  }\n\n  return this._state;\n};\n\nElementMorph.prototype.setState = function(newState) {\n  /*jshint -W093 */\n\n  return this._state = newState;\n};\n\n// renderAndCleanup calls `clear` on all items in the morph map\n// just before calling `destroy` on the morph.\n//\n// As a future refactor this could be changed to set the property\n// back to its original/default value.\nElementMorph.prototype.clear = function() { };\n\nElementMorph.prototype.destroy = function() {\n  this.element = null;\n  this.dom = null;\n};\n\n\n/*\n * A class wrapping DOM functions to address environment compatibility,\n * namespaces, contextual elements for morph un-escaped content\n * insertion.\n *\n * When entering a template, a DOMHelper should be passed:\n *\n *   template(context, { hooks: hooks, dom: new DOMHelper() });\n *\n * TODO: support foreignObject as a passed contextual element. It has\n * a namespace (svg) that does not match its internal namespace\n * (xhtml).\n *\n * @class DOMHelper\n * @constructor\n * @param {HTMLDocument} _document The document DOM methods are proxied to\n */\nfunction DOMHelper(_document){\n  this.document = _document || document;\n  if (!this.document) {\n    throw new Error(\"A document object must be passed to the DOMHelper, or available on the global scope\");\n  }\n  this.canClone = canClone;\n  this.namespace = null;\n\n  installEnvironmentSpecificMethods(this);\n}\n\nvar prototype = DOMHelper.prototype;\nprototype.constructor = DOMHelper;\n\nprototype.getElementById = function(id, rootNode) {\n  rootNode = rootNode || this.document;\n  return rootNode.getElementById(id);\n};\n\nprototype.insertBefore = function(element, childElement, referenceChild) {\n  return element.insertBefore(childElement, referenceChild);\n};\n\nprototype.appendChild = function(element, childElement) {\n  return element.appendChild(childElement);\n};\n\nvar itemAt;\n\n// It appears that sometimes, in yet to be itentified scenarios PhantomJS 2.0\n// crashes on childNodes.item(index), but works as expected with childNodes[index];\n//\n// Although it would be nice to move to childNodes[index] in all scenarios,\n// this would require SimpleDOM to maintain the childNodes array. This would be\n// quite costly, in both dev time and runtime.\n//\n// So instead, we choose the best possible method and call it a day.\n//\n/*global navigator */\nif (typeof navigator !== 'undefined' &&\n    navigator.userAgent.indexOf('PhantomJS')) {\n  itemAt = function(nodes, index) {\n    return nodes[index];\n  };\n} else {\n  itemAt = function(nodes, index) {\n    return nodes.item(index);\n  };\n}\n\nprototype.childAt = function(element, indices) {\n  var child = element;\n\n  for (var i = 0; i < indices.length; i++) {\n    child = itemAt(child.childNodes, indices[i]);\n  }\n\n  return child;\n};\n\n// Note to a Fellow Implementor:\n// Ahh, accessing a child node at an index. Seems like it should be so simple,\n// doesn't it? Unfortunately, this particular method has caused us a surprising\n// amount of pain. As you'll note below, this method has been modified to walk\n// the linked list of child nodes rather than access the child by index\n// directly, even though there are two (2) APIs in the DOM that do this for us.\n// If you're thinking to yourself, \"What an oversight! What an opportunity to\n// optimize this code!\" then to you I say: stop! For I have a tale to tell.\n//\n// First, this code must be compatible with simple-dom for rendering on the\n// server where there is no real DOM. Previously, we accessed a child node\n// directly via `element.childNodes[index]`. While we *could* in theory do a\n// full-fidelity simulation of a live `childNodes` array, this is slow,\n// complicated and error-prone.\n//\n// \"No problem,\" we thought, \"we'll just use the similar\n// `childNodes.item(index)` API.\" Then, we could just implement our own `item`\n// method in simple-dom and walk the child node linked list there, allowing\n// us to retain the performance advantages of the (surely optimized) `item()`\n// API in the browser.\n//\n// Unfortunately, an enterprising soul named Samy Alzahrani discovered that in\n// IE8, accessing an item out-of-bounds via `item()` causes an exception where\n// other browsers return null. This necessitated a... check of\n// `childNodes.length`, bringing us back around to having to support a\n// full-fidelity `childNodes` array!\n//\n// Worst of all, Kris Selden investigated how browsers are actualy implemented\n// and discovered that they're all linked lists under the hood anyway. Accessing\n// `childNodes` requires them to allocate a new live collection backed by that\n// linked list, which is itself a rather expensive operation. Our assumed\n// optimization had backfired! That is the danger of magical thinking about\n// the performance of native implementations.\n//\n// And this, my friends, is why the following implementation just walks the\n// linked list, as surprised as that may make you. Please ensure you understand\n// the above before changing this and submitting a PR.\n//\n// Tom Dale, January 18th, 2015, Portland OR\nprototype.childAtIndex = function(element, index) {\n  var node = element.firstChild;\n\n  for (var idx = 0; node && idx < index; idx++) {\n    node = node.nextSibling;\n  }\n\n  return node;\n};\n\nprototype.appendText = function(element, text) {\n  return element.appendChild(this.document.createTextNode(text));\n};\n\nprototype.setAttribute = function(element, name, value) {\n  element.setAttribute(name, String(value));\n};\n\nprototype.getAttribute = function(element, name) {\n  return element.getAttribute(name);\n};\n\nprototype.setAttributeNS = function(element, namespace, name, value) {\n  element.setAttributeNS(namespace, name, String(value));\n};\n\nprototype.getAttributeNS = function(element, namespace, name) {\n  return element.getAttributeNS(namespace, name);\n};\n\nif (canRemoveSvgViewBoxAttribute){\n  prototype.removeAttribute = function(element, name) {\n    element.removeAttribute(name);\n  };\n} else {\n  prototype.removeAttribute = function(element, name) {\n    if (element.tagName === 'svg' && name === 'viewBox') {\n      element.setAttribute(name, null);\n    } else {\n      element.removeAttribute(name);\n    }\n  };\n}\n\nprototype.setPropertyStrict = function(element, name, value) {\n  if (value === undefined) {\n    value = null;\n  }\n\n  if (value === null && (name === 'value' || name === 'type' || name === 'src')) {\n    value = '';\n  }\n\n  element[name] = value;\n};\n\nprototype.getPropertyStrict = function(element, name) {\n  return element[name];\n};\n\nprototype.setProperty = function(element, name, value, namespace) {\n  if (element.namespaceURI === svgNamespace) {\n    if (isAttrRemovalValue(value)) {\n      element.removeAttribute(name);\n    } else {\n      if (namespace) {\n        element.setAttributeNS(namespace, name, value);\n      } else {\n        element.setAttribute(name, value);\n      }\n    }\n  } else {\n    var { normalized , type } = normalizeProperty(element, name);\n    if (type === 'prop') {\n      element[normalized] = value;\n    } else {\n      if (isAttrRemovalValue(value)) {\n        element.removeAttribute(name);\n      } else {\n        if (namespace && element.setAttributeNS) {\n          element.setAttributeNS(namespace, name, value);\n        } else {\n          element.setAttribute(name, value);\n        }\n      }\n    }\n  }\n};\n\nif (doc && doc.createElementNS) {\n  // Only opt into namespace detection if a contextualElement\n  // is passed.\n  prototype.createElement = function(tagName, contextualElement) {\n    var namespace = this.namespace;\n    if (contextualElement) {\n      if (tagName === 'svg') {\n        namespace = svgNamespace;\n      } else {\n        namespace = interiorNamespace(contextualElement);\n      }\n    }\n    if (namespace) {\n      return this.document.createElementNS(namespace, tagName);\n    } else {\n      return this.document.createElement(tagName);\n    }\n  };\n  prototype.setAttributeNS = function(element, namespace, name, value) {\n    element.setAttributeNS(namespace, name, String(value));\n  };\n} else {\n  prototype.createElement = function(tagName) {\n    return this.document.createElement(tagName);\n  };\n  prototype.setAttributeNS = function(element, namespace, name, value) {\n    element.setAttribute(name, String(value));\n  };\n}\n\nprototype.addClasses = addClasses;\nprototype.removeClasses = removeClasses;\n\nprototype.setNamespace = function(ns) {\n  this.namespace = ns;\n};\n\nprototype.detectNamespace = function(element) {\n  this.namespace = interiorNamespace(element);\n};\n\nprototype.createDocumentFragment = function(){\n  return this.document.createDocumentFragment();\n};\n\nprototype.createTextNode = function(text){\n  return this.document.createTextNode(text);\n};\n\nprototype.createComment = function(text){\n  return this.document.createComment(text);\n};\n\nprototype.repairClonedNode = function(element, blankChildTextNodes, isChecked){\n  if (deletesBlankTextNodes && blankChildTextNodes.length > 0) {\n    for (var i=0, len=blankChildTextNodes.length;i<len;i++){\n      var textNode = this.document.createTextNode(''),\n          offset = blankChildTextNodes[i],\n          before = this.childAtIndex(element, offset);\n      if (before) {\n        element.insertBefore(textNode, before);\n      } else {\n        element.appendChild(textNode);\n      }\n    }\n  }\n  if (ignoresCheckedAttribute && isChecked) {\n    element.setAttribute('checked', 'checked');\n  }\n};\n\nprototype.cloneNode = function(element, deep){\n  var clone = element.cloneNode(!!deep);\n  return clone;\n};\n\nprototype.AttrMorphClass = AttrMorph;\n\nprototype.createAttrMorph = function(element, attrName, namespace){\n  return this.AttrMorphClass.create(element, attrName, this, namespace);\n};\n\nprototype.ElementMorphClass = ElementMorph;\n\nprototype.createElementMorph = function(element, namespace){\n  return new this.ElementMorphClass(element, this, namespace);\n};\n\nprototype.createUnsafeAttrMorph = function(element, attrName, namespace){\n  var morph = this.createAttrMorph(element, attrName, namespace);\n  morph.escaped = false;\n  return morph;\n};\n\nprototype.MorphClass = Morph;\n\nprototype.createMorph = function(parent, start, end, contextualElement){\n  if (contextualElement && contextualElement.nodeType === 11) {\n    throw new Error(\"Cannot pass a fragment as the contextual element to createMorph\");\n  }\n\n  if (!contextualElement && parent && parent.nodeType === 1) {\n    contextualElement = parent;\n  }\n  var morph = new this.MorphClass(this, contextualElement);\n  morph.firstNode = start;\n  morph.lastNode = end;\n  return morph;\n};\n\nprototype.createFragmentMorph = function(contextualElement) {\n  if (contextualElement && contextualElement.nodeType === 11) {\n    throw new Error(\"Cannot pass a fragment as the contextual element to createMorph\");\n  }\n\n  var fragment = this.createDocumentFragment();\n  return Morph.create(this, contextualElement, fragment);\n};\n\nprototype.replaceContentWithMorph = function(element)  {\n  var firstChild = element.firstChild;\n\n  if (!firstChild) {\n    var comment = this.createComment('');\n    this.appendChild(element, comment);\n    return Morph.create(this, element, comment);\n  } else {\n    var morph = Morph.attach(this, element, firstChild, element.lastChild);\n    morph.clear();\n    return morph;\n  }\n};\n\nprototype.createUnsafeMorph = function(parent, start, end, contextualElement){\n  var morph = this.createMorph(parent, start, end, contextualElement);\n  morph.parseTextAsHTML = true;\n  return morph;\n};\n\n// This helper is just to keep the templates good looking,\n// passing integers instead of element references.\nprototype.createMorphAt = function(parent, startIndex, endIndex, contextualElement){\n  var single = startIndex === endIndex;\n  var start = this.childAtIndex(parent, startIndex);\n  var end = single ? start : this.childAtIndex(parent, endIndex);\n  return this.createMorph(parent, start, end, contextualElement);\n};\n\nprototype.createUnsafeMorphAt = function(parent, startIndex, endIndex, contextualElement) {\n  var morph = this.createMorphAt(parent, startIndex, endIndex, contextualElement);\n  morph.parseTextAsHTML = true;\n  return morph;\n};\n\nprototype.insertMorphBefore = function(element, referenceChild, contextualElement) {\n  var insertion = this.document.createComment('');\n  element.insertBefore(insertion, referenceChild);\n  return this.createMorph(element, insertion, insertion, contextualElement);\n};\n\nprototype.appendMorph = function(element, contextualElement) {\n  var insertion = this.document.createComment('');\n  element.appendChild(insertion);\n  return this.createMorph(element, insertion, insertion, contextualElement);\n};\n\nprototype.insertBoundary = function(fragment, index) {\n  // this will always be null or firstChild\n  var child = index === null ? null : this.childAtIndex(fragment, index);\n  this.insertBefore(fragment, this.createTextNode(''), child);\n};\n\nprototype.setMorphHTML = function(morph, html) {\n  morph.setHTML(html);\n};\n\nprototype.parseHTML = function(html, contextualElement) {\n  var childNodes;\n\n  if (interiorNamespace(contextualElement) === svgNamespace) {\n    childNodes = buildSVGDOM(html, this);\n  } else {\n    var nodes = buildHTMLDOM(html, contextualElement, this);\n    if (detectOmittedStartTag(html, contextualElement)) {\n      var node = nodes[0];\n      while (node && node.nodeType !== 1) {\n        node = node.nextSibling;\n      }\n      childNodes = node.childNodes;\n    } else {\n      childNodes = nodes;\n    }\n  }\n\n  // Copy node list to a fragment.\n  var fragment = this.document.createDocumentFragment();\n\n  if (childNodes && childNodes.length > 0) {\n    var currentNode = childNodes[0];\n\n    // We prepend an <option> to <select> boxes to absorb any browser bugs\n    // related to auto-select behavior. Skip past it.\n    if (contextualElement.tagName === 'SELECT') {\n      currentNode = currentNode.nextSibling;\n    }\n\n    while (currentNode) {\n      var tempNode = currentNode;\n      currentNode = currentNode.nextSibling;\n\n      fragment.appendChild(tempNode);\n    }\n  }\n\n  return fragment;\n};\n\nvar nodeURL;\nvar parsingNode;\n\nfunction installEnvironmentSpecificMethods(domHelper) {\n  var protocol = browserProtocolForURL.call(domHelper, 'foobar:baz');\n\n  // Test to see if our DOM implementation parses\n  // and normalizes URLs.\n  if (protocol === 'foobar:') {\n    // Swap in the method that doesn't do this test now that\n    // we know it works.\n    domHelper.protocolForURL = browserProtocolForURL;\n  } else if (typeof URL === 'object') {\n    // URL globally provided, likely from FastBoot's sandbox\n    nodeURL = URL;\n    domHelper.protocolForURL = nodeProtocolForURL;\n  } else if (typeof module === 'object' && typeof module.require === 'function') {\n    // Otherwise, we need to fall back to our own URL parsing.\n    // Global `require` is shadowed by Ember's loader so we have to use the fully\n    // qualified `module.require`.\n    nodeURL = module.require('url');\n    domHelper.protocolForURL = nodeProtocolForURL;\n  } else {\n    throw new Error(\"DOM Helper could not find valid URL parsing mechanism\");\n  }\n\n  // A SimpleDOM-specific extension that allows us to place HTML directly\n  // into the DOM tree, for when the output target is always serialized HTML.\n  if (domHelper.document.createRawHTMLSection) {\n    domHelper.setMorphHTML = nodeSetMorphHTML;\n  }\n}\n\nfunction nodeSetMorphHTML(morph, html) {\n  var section = this.document.createRawHTMLSection(html);\n  morph.setNode(section);\n}\n\nfunction browserProtocolForURL(url) {\n  if (!parsingNode) {\n    parsingNode = this.document.createElement('a');\n  }\n\n  parsingNode.href = url;\n  return parsingNode.protocol;\n}\n\nfunction nodeProtocolForURL(url) {\n  var protocol = nodeURL.parse(url).protocol;\n  return (protocol === null) ? ':' : protocol;\n}\n\nexport default DOMHelper;\n","/* global XMLSerializer:false */\nexport var svgHTMLIntegrationPoints = {foreignObject: 1, desc: 1, title: 1};\nexport var svgNamespace = 'http://www.w3.org/2000/svg';\n\nvar doc = typeof document === 'undefined' ? false : document;\n\n// Safari does not like using innerHTML on SVG HTML integration\n// points (desc/title/foreignObject).\nvar needsIntegrationPointFix = doc && (function(document) {\n  if (document.createElementNS === undefined) {\n    return;\n  }\n  // In FF title will not accept innerHTML.\n  var testEl = document.createElementNS(svgNamespace, 'title');\n  testEl.innerHTML = \"<div></div>\";\n  return testEl.childNodes.length === 0 || testEl.childNodes[0].nodeType !== 1;\n})(doc);\n\n// Internet Explorer prior to 9 does not allow setting innerHTML if the first element\n// is a \"zero-scope\" element. This problem can be worked around by making\n// the first node an invisible text node. We, like Modernizr, use &shy;\nvar needsShy = doc && (function(document) {\n  var testEl = document.createElement('div');\n  testEl.innerHTML = \"<div></div>\";\n  testEl.firstChild.innerHTML = \"<script><\\/script>\";\n  return testEl.firstChild.innerHTML === '';\n})(doc);\n\n// IE 8 (and likely earlier) likes to move whitespace preceeding\n// a script tag to appear after it. This means that we can\n// accidentally remove whitespace when updating a morph.\nvar movesWhitespace = doc && (function(document) {\n  var testEl = document.createElement('div');\n  testEl.innerHTML = \"Test: <script type='text/x-placeholder'><\\/script>Value\";\n  return testEl.childNodes[0].nodeValue === 'Test:' &&\n          testEl.childNodes[2].nodeValue === ' Value';\n})(doc);\n\nvar tagNamesRequiringInnerHTMLFix = doc && (function(document) {\n  var tagNamesRequiringInnerHTMLFix;\n  // IE 9 and earlier don't allow us to set innerHTML on col, colgroup, frameset,\n  // html, style, table, tbody, tfoot, thead, title, tr. Detect this and add\n  // them to an initial list of corrected tags.\n  //\n  // Here we are only dealing with the ones which can have child nodes.\n  //\n  var tableNeedsInnerHTMLFix;\n  var tableInnerHTMLTestElement = document.createElement('table');\n  try {\n    tableInnerHTMLTestElement.innerHTML = '<tbody></tbody>';\n  } catch (e) {\n  } finally {\n    tableNeedsInnerHTMLFix = (tableInnerHTMLTestElement.childNodes.length === 0);\n  }\n  if (tableNeedsInnerHTMLFix) {\n    tagNamesRequiringInnerHTMLFix = {\n      colgroup: ['table'],\n      table: [],\n      tbody: ['table'],\n      tfoot: ['table'],\n      thead: ['table'],\n      tr: ['table', 'tbody']\n    };\n  }\n\n  // IE 8 doesn't allow setting innerHTML on a select tag. Detect this and\n  // add it to the list of corrected tags.\n  //\n  var selectInnerHTMLTestElement = document.createElement('select');\n  selectInnerHTMLTestElement.innerHTML = '<option></option>';\n  if (!selectInnerHTMLTestElement.childNodes[0]) {\n    tagNamesRequiringInnerHTMLFix = tagNamesRequiringInnerHTMLFix || {};\n    tagNamesRequiringInnerHTMLFix.select = [];\n  }\n  return tagNamesRequiringInnerHTMLFix;\n})(doc);\n\nfunction scriptSafeInnerHTML(element, html) {\n  // without a leading text node, IE will drop a leading script tag.\n  html = '&shy;'+html;\n\n  element.innerHTML = html;\n\n  var nodes = element.childNodes;\n\n  // Look for &shy; to remove it.\n  var shyElement = nodes[0];\n  while (shyElement.nodeType === 1 && !shyElement.nodeName) {\n    shyElement = shyElement.firstChild;\n  }\n  // At this point it's the actual unicode character.\n  if (shyElement.nodeType === 3 && shyElement.nodeValue.charAt(0) === \"\\u00AD\") {\n    var newValue = shyElement.nodeValue.slice(1);\n    if (newValue.length) {\n      shyElement.nodeValue = shyElement.nodeValue.slice(1);\n    } else {\n      shyElement.parentNode.removeChild(shyElement);\n    }\n  }\n\n  return nodes;\n}\n\nfunction buildDOMWithFix(html, contextualElement){\n  var tagName = contextualElement.tagName;\n\n  // Firefox versions < 11 do not have support for element.outerHTML.\n  var outerHTML = contextualElement.outerHTML || new XMLSerializer().serializeToString(contextualElement);\n  if (!outerHTML) {\n    throw \"Can't set innerHTML on \"+tagName+\" in this browser\";\n  }\n\n  html = fixSelect(html, contextualElement);\n\n  var wrappingTags = tagNamesRequiringInnerHTMLFix[tagName.toLowerCase()];\n\n  var startTag = outerHTML.match(new RegExp(\"<\"+tagName+\"([^>]*)>\", 'i'))[0];\n  var endTag = '</'+tagName+'>';\n\n  var wrappedHTML = [startTag, html, endTag];\n\n  var i = wrappingTags.length;\n  var wrappedDepth = 1 + i;\n  while(i--) {\n    wrappedHTML.unshift('<'+wrappingTags[i]+'>');\n    wrappedHTML.push('</'+wrappingTags[i]+'>');\n  }\n\n  var wrapper = document.createElement('div');\n  scriptSafeInnerHTML(wrapper, wrappedHTML.join(''));\n  var element = wrapper;\n  while (wrappedDepth--) {\n    element = element.firstChild;\n    while (element && element.nodeType !== 1) {\n      element = element.nextSibling;\n    }\n  }\n  while (element && element.tagName !== tagName) {\n    element = element.nextSibling;\n  }\n  return element ? element.childNodes : [];\n}\n\nvar buildDOM;\nif (needsShy) {\n  buildDOM = function buildDOM(html, contextualElement, dom){\n    html = fixSelect(html, contextualElement);\n\n    contextualElement = dom.cloneNode(contextualElement, false);\n    scriptSafeInnerHTML(contextualElement, html);\n    return contextualElement.childNodes;\n  };\n} else {\n  buildDOM = function buildDOM(html, contextualElement, dom){\n    html = fixSelect(html, contextualElement);\n\n    contextualElement = dom.cloneNode(contextualElement, false);\n    contextualElement.innerHTML = html;\n    return contextualElement.childNodes;\n  };\n}\n\nfunction fixSelect(html, contextualElement) {\n  if (contextualElement.tagName === 'SELECT') {\n    html = \"<option></option>\" + html;\n  }\n\n  return html;\n}\n\nvar buildIESafeDOM;\nif (tagNamesRequiringInnerHTMLFix || movesWhitespace) {\n  buildIESafeDOM = function buildIESafeDOM(html, contextualElement, dom) {\n    // Make a list of the leading text on script nodes. Include\n    // script tags without any whitespace for easier processing later.\n    var spacesBefore = [];\n    var spacesAfter = [];\n    if (typeof html === 'string') {\n      html = html.replace(/(\\s*)(<script)/g, function(match, spaces, tag) {\n        spacesBefore.push(spaces);\n        return tag;\n      });\n\n      html = html.replace(/(<\\/script>)(\\s*)/g, function(match, tag, spaces) {\n        spacesAfter.push(spaces);\n        return tag;\n      });\n    }\n\n    // Fetch nodes\n    var nodes;\n    if (tagNamesRequiringInnerHTMLFix[contextualElement.tagName.toLowerCase()]) {\n      // buildDOMWithFix uses string wrappers for problematic innerHTML.\n      nodes = buildDOMWithFix(html, contextualElement);\n    } else {\n      nodes = buildDOM(html, contextualElement, dom);\n    }\n\n    // Build a list of script tags, the nodes themselves will be\n    // mutated as we add test nodes.\n    var i, j, node, nodeScriptNodes;\n    var scriptNodes = [];\n    for (i=0;i<nodes.length;i++) {\n      node=nodes[i];\n      if (node.nodeType !== 1) {\n        continue;\n      }\n      if (node.tagName === 'SCRIPT') {\n        scriptNodes.push(node);\n      } else {\n        nodeScriptNodes = node.getElementsByTagName('script');\n        for (j=0;j<nodeScriptNodes.length;j++) {\n          scriptNodes.push(nodeScriptNodes[j]);\n        }\n      }\n    }\n\n    // Walk the script tags and put back their leading text nodes.\n    var scriptNode, textNode, spaceBefore, spaceAfter;\n    for (i=0;i<scriptNodes.length;i++) {\n      scriptNode = scriptNodes[i];\n      spaceBefore = spacesBefore[i];\n      if (spaceBefore && spaceBefore.length > 0) {\n        textNode = dom.document.createTextNode(spaceBefore);\n        scriptNode.parentNode.insertBefore(textNode, scriptNode);\n      }\n\n      spaceAfter = spacesAfter[i];\n      if (spaceAfter && spaceAfter.length > 0) {\n        textNode = dom.document.createTextNode(spaceAfter);\n        scriptNode.parentNode.insertBefore(textNode, scriptNode.nextSibling);\n      }\n    }\n\n    return nodes;\n  };\n} else {\n  buildIESafeDOM = buildDOM;\n}\n\nvar buildHTMLDOM;\nif (needsIntegrationPointFix) {\n  buildHTMLDOM = function buildHTMLDOM(html, contextualElement, dom){\n    if (svgHTMLIntegrationPoints[contextualElement.tagName]) {\n      return buildIESafeDOM(html, document.createElement('div'), dom);\n    } else {\n      return buildIESafeDOM(html, contextualElement, dom);\n    }\n  };\n} else {\n  buildHTMLDOM = buildIESafeDOM;\n}\n\nexport {buildHTMLDOM};\n","var doc = typeof document === 'undefined' ? false : document;\n\n// PhantomJS has a broken classList. See https://github.com/ariya/phantomjs/issues/12782\nvar canClassList = doc && (function(){\n  var d = document.createElement('div');\n  if (!d.classList) {\n    return false;\n  }\n  d.classList.add('boo');\n  d.classList.add('boo', 'baz');\n  return (d.className === 'boo baz');\n})();\n\nfunction buildClassList(element) {\n  var classString = (element.getAttribute('class') || '');\n  return classString !== '' && classString !== ' ' ? classString.split(' ') : [];\n}\n\nfunction intersect(containingArray, valuesArray) {\n  var containingIndex = 0;\n  var containingLength = containingArray.length;\n  var valuesIndex = 0;\n  var valuesLength = valuesArray.length;\n\n  var intersection = new Array(valuesLength);\n\n  // TODO: rewrite this loop in an optimal manner\n  for (;containingIndex<containingLength;containingIndex++) {\n    valuesIndex = 0;\n    for (;valuesIndex<valuesLength;valuesIndex++) {\n      if (valuesArray[valuesIndex] === containingArray[containingIndex]) {\n        intersection[valuesIndex] = containingIndex;\n        break;\n      }\n    }\n  }\n\n  return intersection;\n}\n\nfunction addClassesViaAttribute(element, classNames) {\n  var existingClasses = buildClassList(element);\n\n  var indexes = intersect(existingClasses, classNames);\n  var didChange = false;\n\n  for (var i=0, l=classNames.length; i<l; i++) {\n    if (indexes[i] === undefined) {\n      didChange = true;\n      existingClasses.push(classNames[i]);\n    }\n  }\n\n  if (didChange) {\n    element.setAttribute('class', existingClasses.length > 0 ? existingClasses.join(' ') : '');\n  }\n}\n\nfunction removeClassesViaAttribute(element, classNames) {\n  var existingClasses = buildClassList(element);\n\n  var indexes = intersect(classNames, existingClasses);\n  var didChange = false;\n  var newClasses = [];\n\n  for (var i=0, l=existingClasses.length; i<l; i++) {\n    if (indexes[i] === undefined) {\n      newClasses.push(existingClasses[i]);\n    } else {\n      didChange = true;\n    }\n  }\n\n  if (didChange) {\n    element.setAttribute('class', newClasses.length > 0 ? newClasses.join(' ') : '');\n  }\n}\n\nvar addClasses, removeClasses;\nif (canClassList) {\n  addClasses = function addClasses(element, classNames) {\n    if (element.classList) {\n      if (classNames.length === 1) {\n        element.classList.add(classNames[0]);\n      } else if (classNames.length === 2) {\n        element.classList.add(classNames[0], classNames[1]);\n      } else {\n        element.classList.add.apply(element.classList, classNames);\n      }\n    } else {\n      addClassesViaAttribute(element, classNames);\n    }\n  };\n  removeClasses = function removeClasses(element, classNames) {\n    if (element.classList) {\n      if (classNames.length === 1) {\n        element.classList.remove(classNames[0]);\n      } else if (classNames.length === 2) {\n        element.classList.remove(classNames[0], classNames[1]);\n      } else {\n        element.classList.remove.apply(element.classList, classNames);\n      }\n    } else {\n      removeClassesViaAttribute(element, classNames);\n    }\n  };\n} else {\n  addClasses = addClassesViaAttribute;\n  removeClasses = removeClassesViaAttribute;\n}\n\nexport {\n  addClasses,\n  removeClasses\n};\n","export function isAttrRemovalValue(value) {\n  return value === null || value === undefined;\n}\n/*\n *\n * @method normalizeProperty\n * @param element {HTMLElement}\n * @param slotName {String}\n * @returns {Object} { name, type }\n */\nexport function normalizeProperty(element, slotName) {\n  var type, normalized;\n\n  if (slotName in element) {\n    normalized = slotName;\n    type = 'prop';\n  } else {\n    var lower = slotName.toLowerCase();\n    if (lower in element) {\n      type = 'prop';\n      normalized = lower;\n    } else {\n      type = 'attr';\n      normalized = slotName;\n    }\n  }\n\n  if (type === 'prop' &&\n      (normalized.toLowerCase() === 'style' ||\n       preferAttr(element.tagName, normalized))) {\n    type = 'attr';\n  }\n\n  return { normalized, type };\n}\n\n// properties that MUST be set as attributes, due to:\n// * browser bug\n// * strange spec outlier\nvar ATTR_OVERRIDES = {\n\n  // phantomjs < 2.0 lets you set it as a prop but won't reflect it\n  // back to the attribute. button.getAttribute('type') === null\n  BUTTON: { type: true, form: true },\n\n  INPUT: {\n    // TODO: remove when IE8 is droped\n    // Some versions of IE (IE8) throw an exception when setting\n    // `input.list = 'somestring'`:\n    // https://github.com/emberjs/ember.js/issues/10908\n    // https://github.com/emberjs/ember.js/issues/11364\n    list: true,\n    // Some version of IE (like IE9) actually throw an exception\n    // if you set input.type = 'something-unknown'\n    type: true,\n    form: true,\n    // Chrome 46.0.2464.0: 'autocorrect' in document.createElement('input') === false\n    // Safari 8.0.7: 'autocorrect' in document.createElement('input') === false\n    // Mobile Safari (iOS 8.4 simulator): 'autocorrect' in document.createElement('input') === true\n    autocorrect: true\n  },\n\n  // element.form is actually a legitimate readOnly property, that is to be\n  // mutated, but must be mutated by setAttribute...\n  SELECT:   { form: true },\n  OPTION:   { form: true },\n  TEXTAREA: { form: true },\n  LABEL:    { form: true },\n  FIELDSET: { form: true },\n  LEGEND:   { form: true },\n  OBJECT:   { form: true }\n};\n\nfunction preferAttr(tagName, propName) {\n  var tag = ATTR_OVERRIDES[tagName.toUpperCase()];\n  return tag && tag[propName.toLowerCase()] || false;\n}\n","/**\n  # Expression Nodes:\n\n  These nodes are not directly responsible for any part of the DOM, but are\n  eventually passed to a Statement Node.\n\n  * get\n  * subexpr\n  * concat\n*/\n\nexport function acceptParams(nodes, env, scope) {\n  let array = [];\n\n  for (let i = 0, l = nodes.length; i < l; i++) {\n    array.push(acceptExpression(nodes[i], env, scope).value);\n  }\n\n  return array;\n}\n\nexport function acceptHash(pairs, env, scope) {\n  let object = {};\n\n  for (let i = 0, l = pairs.length; i < l; i += 2) {\n    let key = pairs[i];\n    let value = pairs[i+1];\n    object[key] = acceptExpression(value, env, scope).value;\n  }\n\n  return object;\n}\n\nfunction acceptExpression(node, env, scope) {\n  let ret = { value: null };\n\n  // Primitive literals are unambiguously non-array representations of\n  // themselves.\n  if (typeof node !== 'object' || node === null) {\n    ret.value = node;\n  } else {\n    ret.value = evaluateNode(node, env, scope);\n  }\n\n  return ret;\n}\n\nfunction evaluateNode(node, env, scope) {\n  switch (node[0]) {\n    // can be used by manualElement\n    case 'value':   return node[1];\n    case 'get':     return evaluateGet(node, env, scope);\n    case 'subexpr': return evaluateSubexpr(node, env, scope);\n    case 'concat':  return evaluateConcat(node, env, scope);\n  }\n}\n\nfunction evaluateGet(node, env, scope) {\n  let [, path] = node;\n\n  return env.hooks.get(env, scope, path);\n}\n\nfunction evaluateSubexpr(node, env, scope) {\n  let [, path, rawParams, rawHash] = node;\n\n  let params = acceptParams(rawParams, env, scope);\n  let hash = acceptHash(rawHash, env, scope);\n\n  return env.hooks.subexpr(env, scope, path, params, hash);\n}\n\nfunction evaluateConcat(node, env, scope) {\n  let [, rawParts] = node;\n\n  let parts = acceptParams(rawParts, env, scope);\n\n  return env.hooks.concat(env, parts);\n}\n","import render, { RenderOptions } from \"./render\";\nimport MorphList from \"../morph-range/morph-list\";\nimport { createChildMorph } from \"./render\";\nimport { keyLength, shallowCopy } from \"../htmlbars-util/object-utils\";\nimport { validateChildMorphs } from \"../htmlbars-util/morph-utils\";\nimport { RenderState, clearMorph, clearMorphList, renderAndCleanup } from \"../htmlbars-util/template-utils\";\nimport { linkParams } from \"../htmlbars-util/morph-utils\";\n\n/**\n  HTMLBars delegates the runtime behavior of a template to\n  hooks provided by the host environment. These hooks explain\n  the lexical environment of a Handlebars template, the internal\n  representation of references, and the interaction between an\n  HTMLBars template and the DOM it is managing.\n\n  While HTMLBars host hooks have access to all of this internal\n  machinery, templates and helpers have access to the abstraction\n  provided by the host hooks.\n\n  ## The Lexical Environment\n\n  The default lexical environment of an HTMLBars template includes:\n\n  * Any local variables, provided by *block arguments*\n  * The current value of `self`\n\n  ## Simple Nesting\n\n  Let's look at a simple template with a nested block:\n\n  ```hbs\n  <h1>{{title}}</h1>\n\n  {{#if author}}\n    <p class=\"byline\">{{author}}</p>\n  {{/if}}\n  ```\n\n  In this case, the lexical environment at the top-level of the\n  template does not change inside of the `if` block. This is\n  achieved via an implementation of `if` that looks like this:\n\n  ```js\n  registerHelper('if', function(params) {\n    if (!!params[0]) {\n      return this.yield();\n    }\n  });\n  ```\n\n  A call to `this.yield` invokes the child template using the\n  current lexical environment.\n\n  ## Block Arguments\n\n  It is possible for nested blocks to introduce new local\n  variables:\n\n  ```hbs\n  {{#count-calls as |i|}}\n  <h1>{{title}}</h1>\n  <p>Called {{i}} times</p>\n  {{/count}}\n  ```\n\n  In this example, the child block inherits its surrounding\n  lexical environment, but augments it with a single new\n  variable binding.\n\n  The implementation of `count-calls` supplies the value of\n  `i`, but does not otherwise alter the environment:\n\n  ```js\n  var count = 0;\n  registerHelper('count-calls', function() {\n    return this.yield([ ++count ]);\n  });\n  ```\n*/\n\nexport function wrap(template) {\n  if (template === null) { return null;  }\n\n  return {\n    meta: template.meta,\n    arity: template.arity,\n    raw: template,\n    render: function(self, env, options, blockArguments) {\n      var scope = env.hooks.createFreshScope();\n\n      let contextualElement = options && options.contextualElement;\n      let renderOptions = new RenderOptions(null, self, blockArguments, contextualElement);\n\n      return render(template, env, scope, renderOptions);\n    }\n  };\n}\n\nexport function wrapForHelper(template, env, scope, morph, renderState, visitor) {\n  if (!template) { return {}; }\n\n  var yieldArgs = yieldTemplate(template, env, scope, morph, renderState, visitor);\n\n  return {\n    meta: template.meta,\n    arity: template.arity,\n    'yield': yieldArgs, // quoted since it's a reserved word, see issue #420\n    yieldItem: yieldItem(template, env, scope, morph, renderState, visitor),\n    raw: template,\n\n    render: function(self, blockArguments) {\n      yieldArgs(blockArguments, self);\n    }\n  };\n}\n\n// Called by a user-land helper to render a template.\nfunction yieldTemplate(template, env, parentScope, morph, renderState, visitor) {\n  return function(blockArguments, self) {\n    // Render state is used to track the progress of the helper (since it\n    // may call into us multiple times). As the user-land helper calls\n    // into library code, we track what needs to be cleaned up after the\n    // helper has returned.\n    //\n    // Here, we remember that a template has been yielded and so we do not\n    // need to remove the previous template. (If no template is yielded\n    // this render by the helper, we assume nothing should be shown and\n    // remove any previous rendered templates.)\n    renderState.morphToClear = null;\n\n    // In this conditional is true, it means that on the previous rendering pass\n    // the helper yielded multiple items via `yieldItem()`, but this time they\n    // are yielding a single template. In that case, we mark the morph list for\n    // cleanup so it is removed from the DOM.\n    if (morph.morphList) {\n      clearMorphList(morph.morphList, morph, env);\n      renderState.morphListToClear = null;\n    }\n\n    var scope = parentScope;\n\n    if (morph.lastYielded && isStableTemplate(template, morph.lastYielded)) {\n      return morph.lastResult.revalidateWith(env, undefined, self, blockArguments, visitor);\n    }\n\n    // Check to make sure that we actually **need** a new scope, and can't\n    // share the parent scope. Note that we need to move this check into\n    // a host hook, because the host's notion of scope may require a new\n    // scope in more cases than the ones we can determine statically.\n    if (self !== undefined || parentScope === null || template.arity) {\n      scope = env.hooks.createChildScope(parentScope);\n    }\n\n    morph.lastYielded = { self: self, template: template, shadowTemplate: null };\n\n    // Render the template that was selected by the helper\n    let renderOptions = new RenderOptions(morph, self, blockArguments);\n    render(template, env, scope, renderOptions);\n  };\n}\n\nfunction yieldItem(template, env, parentScope, morph, renderState, visitor) {\n  // Initialize state that tracks multiple items being\n  // yielded in.\n  var currentMorph = null;\n\n  // Candidate morphs for deletion.\n  var candidates = {};\n\n  // Reuse existing MorphList if this is not a first-time\n  // render.\n  var morphList = morph.morphList;\n  if (morphList) {\n    currentMorph = morphList.firstChildMorph;\n  }\n\n  // Advances the currentMorph pointer to the morph in the previously-rendered\n  // list that matches the yielded key. While doing so, it marks any morphs\n  // that it advances past as candidates for deletion. Assuming those morphs\n  // are not yielded in later, they will be removed in the prune step during\n  // cleanup.\n  // Note that this helper function assumes that the morph being seeked to is\n  // guaranteed to exist in the previous MorphList; if this is called and the\n  // morph does not exist, it will result in an infinite loop\n  function advanceToKey(key) {\n    let seek = currentMorph;\n\n    while (seek.key !== key) {\n      candidates[seek.key] = seek;\n      seek = seek.nextMorph;\n    }\n\n    currentMorph = seek.nextMorph;\n    return seek;\n  }\n\n  return function(_key, blockArguments, self) {\n    if (typeof _key !== 'string') {\n      throw new Error(\"You must provide a string key when calling `yieldItem`; you provided \" + _key);\n    }\n\n    // At least one item has been yielded, so we do not wholesale\n    // clear the last MorphList but instead apply a prune operation.\n    renderState.morphListToClear = null;\n    morph.lastYielded = null;\n\n    var morphList, morphMap;\n\n    if (!morph.morphList) {\n      morph.morphList = new MorphList();\n      morph.morphMap = {};\n      morph.setMorphList(morph.morphList);\n    }\n\n    morphList = morph.morphList;\n    morphMap = morph.morphMap;\n\n    // A map of morphs that have been yielded in on this\n    // rendering pass. Any morphs that do not make it into\n    // this list will be pruned from the MorphList during the cleanup\n    // process.\n    let handledMorphs = renderState.handledMorphs;\n    let key;\n\n    if (_key in handledMorphs) {\n      // In this branch we are dealing with a duplicate key. The strategy\n      // is to take the original key and append a counter to it that is\n      // incremented every time the key is reused. In order to greatly\n      // reduce the chance of colliding with another valid key we also add\n      // an extra string \"--z8mS2hvDW0A--\" to the new key.\n      let collisions = renderState.collisions;\n      if (collisions === undefined) {\n        collisions = renderState.collisions = {};\n      }\n      let count = collisions[_key] | 0;\n      collisions[_key] = ++count;\n\n      key = _key + '--z8mS2hvDW0A--' + count;\n    } else {\n      key = _key;\n    }\n\n    if (currentMorph && currentMorph.key === key) {\n      yieldTemplate(template, env, parentScope, currentMorph, renderState, visitor)(blockArguments, self);\n      currentMorph = currentMorph.nextMorph;\n      handledMorphs[key] = currentMorph;\n    } else if (morphMap[key] !== undefined) {\n      let foundMorph = morphMap[key];\n\n      if (key in candidates) {\n        // If we already saw this morph, move it forward to this position\n        morphList.insertBeforeMorph(foundMorph, currentMorph);\n      } else {\n        // Otherwise, move the pointer forward to the existing morph for this key\n        advanceToKey(key);\n      }\n\n      handledMorphs[foundMorph.key] = foundMorph;\n      yieldTemplate(template, env, parentScope, foundMorph, renderState, visitor)(blockArguments, self);\n    } else {\n      var childMorph = createChildMorph(env.dom, morph);\n      childMorph.key = key;\n      morphMap[key] = handledMorphs[key] = childMorph;\n      morphList.insertBeforeMorph(childMorph, currentMorph);\n      yieldTemplate(template, env, parentScope, childMorph, renderState, visitor)(blockArguments, self);\n    }\n\n    renderState.morphListToPrune = morphList;\n    morph.childNodes = null;\n  };\n}\n\nfunction isStableTemplate(template, lastYielded) {\n  return !lastYielded.shadowTemplate && template === lastYielded.template;\n}\nfunction optionsFor(template, inverse, env, scope, morph, visitor) {\n  // If there was a template yielded last time, set morphToClear so it will be cleared\n  // if no template is yielded on this render.\n  var morphToClear = morph.lastResult ? morph : null;\n  var renderState = new RenderState(morphToClear, morph.morphList || null);\n\n  return {\n    templates: {\n      template: wrapForHelper(template, env, scope, morph, renderState, visitor),\n      inverse: wrapForHelper(inverse, env, scope, morph, renderState, visitor)\n    },\n    renderState: renderState\n  };\n}\n\nfunction thisFor(options) {\n  return {\n    arity: options.template.arity,\n    'yield': options.template.yield, // quoted since it's a reserved word, see issue #420\n    yieldItem: options.template.yieldItem,\n    yieldIn: options.template.yieldIn\n  };\n}\n\n/**\n  Host Hook: createScope\n\n  @param {Scope?} parentScope\n  @return Scope\n\n  Corresponds to entering a new HTMLBars block.\n\n  This hook is invoked when a block is entered with\n  a new `self` or additional local variables.\n\n  When invoked for a top-level template, the\n  `parentScope` is `null`, and this hook should return\n  a fresh Scope.\n\n  When invoked for a child template, the `parentScope`\n  is the scope for the parent environment.\n\n  Note that the `Scope` is an opaque value that is\n  passed to other host hooks. For example, the `get`\n  hook uses the scope to retrieve a value for a given\n  scope and variable name.\n*/\nexport function createScope(env, parentScope) {\n  if (parentScope) {\n    return env.hooks.createChildScope(parentScope);\n  } else {\n    return env.hooks.createFreshScope();\n  }\n}\n\nexport function createFreshScope() {\n  // because `in` checks have unpredictable performance, keep a\n  // separate dictionary to track whether a local was bound.\n  // See `bindLocal` for more information.\n  return { self: null, blocks: {}, locals: {}, localPresent: {} };\n}\n\n/**\n  Host Hook: bindShadowScope\n\n  @param {Scope?} parentScope\n  @return Scope\n\n  Corresponds to rendering a new template into an existing\n  render tree, but with a new top-level lexical scope. This\n  template is called the \"shadow root\".\n\n  If a shadow template invokes `{{yield}}`, it will render\n  the block provided to the shadow root in the original\n  lexical scope.\n\n  ```hbs\n  {{!-- post template --}}\n  <p>{{props.title}}</p>\n  {{yield}}\n\n  {{!-- blog template --}}\n  {{#post title=\"Hello world\"}}\n    <p>by {{byline}}</p>\n    <article>This is my first post</article>\n  {{/post}}\n\n  {{#post title=\"Goodbye world\"}}\n    <p>by {{byline}}</p>\n    <article>This is my last post</article>\n  {{/post}}\n  ```\n\n  ```js\n  helpers.post = function(params, hash, options) {\n    options.template.yieldIn(postTemplate, { props: hash });\n  };\n\n  blog.render({ byline: \"Yehuda Katz\" });\n  ```\n\n  Produces:\n\n  ```html\n  <p>Hello world</p>\n  <p>by Yehuda Katz</p>\n  <article>This is my first post</article>\n\n  <p>Goodbye world</p>\n  <p>by Yehuda Katz</p>\n  <article>This is my last post</article>\n  ```\n\n  In short, `yieldIn` creates a new top-level scope for the\n  provided template and renders it, making the original block\n  available to `{{yield}}` in that template.\n*/\nexport function bindShadowScope(env /*, parentScope, shadowScope */) {\n  return env.hooks.createFreshScope();\n}\n\nexport function createChildScope(parent) {\n  var scope = Object.create(parent);\n  scope.locals = Object.create(parent.locals);\n  scope.localPresent = Object.create(parent.localPresent);\n  scope.blocks = Object.create(parent.blocks);\n  return scope;\n}\n\n/**\n  Host Hook: bindSelf\n\n  @param {Scope} scope\n  @param {any} self\n\n  Corresponds to entering a template.\n\n  This hook is invoked when the `self` value for a scope is ready to be bound.\n\n  The host must ensure that child scopes reflect the change to the `self` in\n  future calls to the `get` hook.\n*/\nexport function bindSelf(env, scope, self) {\n  scope.self = self;\n}\n\nexport function updateSelf(env, scope, self) {\n  env.hooks.bindSelf(env, scope, self);\n}\n\n/**\n  Host Hook: bindLocal\n\n  @param {Environment} env\n  @param {Scope} scope\n  @param {String} name\n  @param {any} value\n\n  Corresponds to entering a template with block arguments.\n\n  This hook is invoked when a local variable for a scope has been provided.\n\n  The host must ensure that child scopes reflect the change in future calls\n  to the `get` hook.\n*/\nexport function bindLocal(env, scope, name, value) {\n  scope.localPresent[name] = true;\n  scope.locals[name] = value;\n}\n\nexport function updateLocal(env, scope, name, value) {\n  env.hooks.bindLocal(env, scope, name, value);\n}\n\n/**\n  Host Hook: bindBlock\n\n  @param {Environment} env\n  @param {Scope} scope\n  @param {Function} block\n\n  Corresponds to entering a shadow template that was invoked by a block helper with\n  `yieldIn`.\n\n  This hook is invoked with an opaque block that will be passed along\n  to the shadow template, and inserted into the shadow template when\n  `{{yield}}` is used. Optionally provide a non-default block name\n  that can be targeted by `{{yield to=blockName}}`.\n*/\nexport function bindBlock(env, scope, block, name='default') {\n  scope.blocks[name] = block;\n}\n\n/**\n  Host Hook: block\n\n  @param {RenderNode} renderNode\n  @param {Environment} env\n  @param {Scope} scope\n  @param {String} path\n  @param {Array} params\n  @param {Object} hash\n  @param {Block} block\n  @param {Block} elseBlock\n\n  Corresponds to:\n\n  ```hbs\n  {{#helper param1 param2 key1=val1 key2=val2}}\n    {{!-- child template --}}\n  {{/helper}}\n  ```\n\n  This host hook is a workhorse of the system. It is invoked\n  whenever a block is encountered, and is responsible for\n  resolving the helper to call, and then invoke it.\n\n  The helper should be invoked with:\n\n  - `{Array} params`: the parameters passed to the helper\n    in the template.\n  - `{Object} hash`: an object containing the keys and values passed\n    in the hash position in the template.\n\n  The values in `params` and `hash` will already be resolved\n  through a previous call to the `get` host hook.\n\n  The helper should be invoked with a `this` value that is\n  an object with one field:\n\n  `{Function} yield`: when invoked, this function executes the\n  block with the current scope. It takes an optional array of\n  block parameters. If block parameters are supplied, HTMLBars\n  will invoke the `bindLocal` host hook to bind the supplied\n  values to the block arguments provided by the template.\n\n  In general, the default implementation of `block` should work\n  for most host environments. It delegates to other host hooks\n  where appropriate, and properly invokes the helper with the\n  appropriate arguments.\n*/\nexport function block(morph, env, scope, path, params, hash, template, inverse, visitor) {\n  if (handleRedirect(morph, env, scope, path, params, hash, template, inverse, visitor)) {\n    return;\n  }\n\n  continueBlock(morph, env, scope, path, params, hash, template, inverse, visitor);\n}\n\nexport function continueBlock(morph, env, scope, path, params, hash, template, inverse, visitor) {\n  hostBlock(morph, env, scope, template, inverse, null, visitor, function(options) {\n    var helper = env.hooks.lookupHelper(env, scope, path);\n    return env.hooks.invokeHelper(morph, env, scope, visitor, params, hash, helper, options.templates, thisFor(options.templates));\n  });\n}\n\nexport function hostBlock(morph, env, scope, template, inverse, shadowOptions, visitor, callback) {\n  var options = optionsFor(template, inverse, env, scope, morph, visitor);\n  renderAndCleanup(morph, env, options, shadowOptions, callback);\n}\n\nexport function handleRedirect(morph, env, scope, path, params, hash, template, inverse, visitor) {\n  if (!path) {\n    return false;\n  }\n\n  var redirect = env.hooks.classify(env, scope, path);\n  if (redirect) {\n    switch(redirect) {\n      case 'component': env.hooks.component(morph, env, scope, path, params, hash, {default: template, inverse}, visitor); break;\n      case 'inline': env.hooks.inline(morph, env, scope, path, params, hash, visitor); break;\n      case 'block': env.hooks.block(morph, env, scope, path, params, hash, template, inverse, visitor); break;\n      default: throw new Error(\"Internal HTMLBars redirection to \" + redirect + \" not supported\");\n    }\n    return true;\n  }\n\n  if (handleKeyword(path, morph, env, scope, params, hash, template, inverse, visitor)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function handleKeyword(path, morph, env, scope, params, hash, template, inverse, visitor) {\n  var keyword = env.hooks.keywords[path];\n  if (!keyword) { return false; }\n\n  if (typeof keyword === 'function') {\n    return keyword(morph, env, scope, params, hash, template, inverse, visitor);\n  }\n\n  if (keyword.willRender) {\n    keyword.willRender(morph, env);\n  }\n\n  var lastState, newState;\n  if (keyword.setupState) {\n    lastState = shallowCopy(morph.getState());\n    newState = morph.setState(keyword.setupState(lastState, env, scope, params, hash));\n  }\n\n  if (keyword.childEnv) {\n    // Build the child environment...\n    env = keyword.childEnv(morph.getState(), env);\n\n    // ..then save off the child env builder on the render node. If the render\n    // node tree is re-rendered and this node is not dirty, the child env\n    // builder will still be invoked so that child dirty render nodes still get\n    // the correct child env.\n    morph.buildChildEnv = keyword.childEnv;\n  }\n\n  var firstTime = !morph.rendered;\n\n  if (keyword.isEmpty) {\n    var isEmpty = keyword.isEmpty(morph.getState(), env, scope, params, hash);\n\n    if (isEmpty) {\n      if (!firstTime) { clearMorph(morph, env, false); }\n      return true;\n    }\n  }\n\n  if (firstTime) {\n    if (keyword.render) {\n      keyword.render(morph, env, scope, params, hash, template, inverse, visitor);\n    }\n    morph.rendered = true;\n    return true;\n  }\n\n  var isStable;\n  if (keyword.isStable) {\n    isStable = keyword.isStable(lastState, newState);\n  } else {\n    isStable = stableState(lastState, newState);\n  }\n\n  if (isStable) {\n    if (keyword.rerender) {\n      var newEnv = keyword.rerender(morph, env, scope, params, hash, template, inverse, visitor);\n      env = newEnv || env;\n    }\n    validateChildMorphs(env, morph, visitor);\n    return true;\n  } else {\n    clearMorph(morph, env, false);\n  }\n\n  // If the node is unstable, re-render from scratch\n  if (keyword.render) {\n    keyword.render(morph, env, scope, params, hash, template, inverse, visitor);\n    morph.rendered = true;\n    return true;\n  }\n}\n\nfunction stableState(oldState, newState) {\n  if (keyLength(oldState) !== keyLength(newState)) { return false; }\n\n  for (var prop in oldState) {\n    if (oldState[prop] !== newState[prop]) { return false; }\n  }\n\n  return true;\n}\n\nexport function linkRenderNode(/* morph, env, scope, params, hash */) {\n  return;\n}\n\n/**\n  Host Hook: inline\n\n  @param {RenderNode} renderNode\n  @param {Environment} env\n  @param {Scope} scope\n  @param {String} path\n  @param {Array} params\n  @param {Hash} hash\n\n  Corresponds to:\n\n  ```hbs\n  {{helper param1 param2 key1=val1 key2=val2}}\n  ```\n\n  This host hook is similar to the `block` host hook, but it\n  invokes helpers that do not supply an attached block.\n\n  Like the `block` hook, the helper should be invoked with:\n\n  - `{Array} params`: the parameters passed to the helper\n    in the template.\n  - `{Object} hash`: an object containing the keys and values passed\n    in the hash position in the template.\n\n  The values in `params` and `hash` will already be resolved\n  through a previous call to the `get` host hook.\n\n  In general, the default implementation of `inline` should work\n  for most host environments. It delegates to other host hooks\n  where appropriate, and properly invokes the helper with the\n  appropriate arguments.\n\n  The default implementation of `inline` also makes `partial`\n  a keyword. Instead of invoking a helper named `partial`,\n  it invokes the `partial` host hook.\n*/\nexport function inline(morph, env, scope, path, params, hash, visitor) {\n  if (handleRedirect(morph, env, scope, path, params, hash, null, null, visitor)) {\n    return;\n  }\n\n  let value, hasValue;\n  if (morph.linkedResult) {\n    value = env.hooks.getValue(morph.linkedResult);\n    hasValue = true;\n  } else {\n    var options = optionsFor(null, null, env, scope, morph);\n\n    var helper = env.hooks.lookupHelper(env, scope, path);\n    var result = env.hooks.invokeHelper(morph, env, scope, visitor, params, hash, helper, options.templates, thisFor(options.templates));\n\n    if (result && result.link) {\n      morph.linkedResult = result.value;\n      linkParams(env, scope, morph, '@content-helper', [morph.linkedResult], null);\n    }\n\n    if (result && 'value' in result) {\n      value = env.hooks.getValue(result.value);\n      hasValue = true;\n    }\n  }\n\n  if (hasValue) {\n    if (morph.lastValue !== value) {\n      morph.setContent(value);\n    }\n    morph.lastValue = value;\n  }\n}\n\nexport function keyword(path, morph, env, scope, params, hash, template, inverse, visitor)  {\n  handleKeyword(path, morph, env, scope, params, hash, template, inverse, visitor);\n}\n\nexport function invokeHelper(morph, env, scope, visitor, _params, _hash, helper, templates, context) {\n  var params = normalizeArray(env, _params);\n  var hash = normalizeObject(env, _hash);\n  return { value: helper.call(context, params, hash, templates) };\n}\n\nfunction normalizeArray(env, array) {\n  var out = new Array(array.length);\n\n  for (var i=0, l=array.length; i<l; i++) {\n    out[i] = env.hooks.getCellOrValue(array[i]);\n  }\n\n  return out;\n}\n\nfunction normalizeObject(env, object) {\n  var out = {};\n\n  for (var prop in object)  {\n    out[prop] = env.hooks.getCellOrValue(object[prop]);\n  }\n\n  return out;\n}\n\nexport function classify(/* env, scope, path */) {\n  return null;\n}\n\nexport var keywords = {\n  partial: function(morph, env, scope, params) {\n    var value = env.hooks.partial(morph, env, scope, params[0]);\n    morph.setContent(value);\n    return true;\n  },\n\n  // quoted since it's a reserved word, see issue #420\n  'yield': function(morph, env, scope, params, hash, template, inverse, visitor) {\n    // the current scope is provided purely for the creation of shadow\n    // scopes; it should not be provided to user code.\n\n    var to = env.hooks.getValue(hash.to) || 'default';\n    var block = env.hooks.getBlock(scope, to);\n\n    if (block) {\n      block.invoke(env, params, hash.self, morph, scope, visitor);\n    }\n    return true;\n  },\n\n  hasBlock: function(morph, env, scope, params) {\n    var name = env.hooks.getValue(params[0]) || 'default';\n    return !!env.hooks.getBlock(scope, name);\n  },\n\n  hasBlockParams: function(morph, env, scope, params) {\n    var name = env.hooks.getValue(params[0]) || 'default';\n    var block = env.hooks.getBlock(scope, name);\n    return !!(block && block.arity);\n  }\n\n};\n\n/**\n  Host Hook: partial\n\n  @param {RenderNode} renderNode\n  @param {Environment} env\n  @param {Scope} scope\n  @param {String} path\n\n  Corresponds to:\n\n  ```hbs\n  {{partial \"location\"}}\n  ```\n\n  This host hook is invoked by the default implementation of\n  the `inline` hook. This makes `partial` a keyword in an\n  HTMLBars environment using the default `inline` host hook.\n\n  It is implemented as a host hook so that it can retrieve\n  the named partial out of the `Environment`. Helpers, in\n  contrast, only have access to the values passed in to them,\n  and not to the ambient lexical environment.\n\n  The host hook should invoke the referenced partial with\n  the ambient `self`.\n*/\nexport function partial(renderNode, env, scope, path) {\n  var template = env.partials[path];\n  return template.render(scope.self, env, {}).fragment;\n}\n\n/**\n  Host hook: range\n\n  @param {RenderNode} renderNode\n  @param {Environment} env\n  @param {Scope} scope\n  @param {any} value\n\n  Corresponds to:\n\n  ```hbs\n  {{content}}\n  {{{unescaped}}}\n  ```\n\n  This hook is responsible for updating a render node\n  that represents a range of content with a value.\n*/\nexport function range(morph, env, scope, path, value, visitor) {\n  if (handleRedirect(morph, env, scope, path, [], {}, null, null, visitor)) {\n    return;\n  }\n\n  value = env.hooks.getValue(value);\n\n  if (morph.lastValue !== value) {\n    morph.setContent(value);\n  }\n\n  morph.lastValue = value;\n}\n\n/**\n  Host hook: element\n\n  @param {RenderNode} renderNode\n  @param {Environment} env\n  @param {Scope} scope\n  @param {String} path\n  @param {Array} params\n  @param {Hash} hash\n\n  Corresponds to:\n\n  ```hbs\n  <div {{bind-attr foo=bar}}></div>\n  ```\n\n  This hook is responsible for invoking a helper that\n  modifies an element.\n\n  Its purpose is largely legacy support for awkward\n  idioms that became common when using the string-based\n  Handlebars engine.\n\n  Most of the uses of the `element` hook are expected\n  to be superseded by component syntax and the\n  `attribute` hook.\n*/\nexport function element(morph, env, scope, path, params, hash, visitor) {\n  if (handleRedirect(morph, env, scope, path, params, hash, null, null, visitor)) {\n    return;\n  }\n\n  var helper = env.hooks.lookupHelper(env, scope, path);\n  if (helper) {\n    env.hooks.invokeHelper(null, env, scope, null, params, hash, helper, { element: morph.element });\n  }\n}\n\n/**\n  Host hook: attribute\n\n  @param {RenderNode} renderNode\n  @param {Environment} env\n  @param {String} name\n  @param {any} value\n\n  Corresponds to:\n\n  ```hbs\n  <div foo={{bar}}></div>\n  ```\n\n  This hook is responsible for updating a render node\n  that represents an element's attribute with a value.\n\n  It receives the name of the attribute as well as an\n  already-resolved value, and should update the render\n  node with the value if appropriate.\n*/\nexport function attribute(morph, env, scope, name, value) {\n  value = env.hooks.getValue(value);\n\n  if (morph.lastValue !== value) {\n    morph.setContent(value);\n  }\n\n  morph.lastValue = value;\n}\n\nexport function subexpr(env, scope, helperName, params, hash) {\n  var helper = env.hooks.lookupHelper(env, scope, helperName);\n  var result = env.hooks.invokeHelper(null, env, scope, null, params, hash, helper, {});\n  if (result && 'value' in result) { return env.hooks.getValue(result.value); }\n}\n\n/**\n  Host Hook: get\n\n  @param {Environment} env\n  @param {Scope} scope\n  @param {String} path\n\n  Corresponds to:\n\n  ```hbs\n  {{foo.bar}}\n    ^\n\n  {{helper foo.bar key=value}}\n           ^           ^\n  ```\n\n  This hook is the \"leaf\" hook of the system. It is used to\n  resolve a path relative to the current scope.\n*/\nexport function get(env, scope, path) {\n  if (path === '') {\n    return scope.self;\n  }\n\n  var keys = path.split('.');\n  var value = env.hooks.getRoot(scope, keys[0])[0];\n\n  for (var i = 1; i < keys.length; i++) {\n    if (value) {\n      value = env.hooks.getChild(value, keys[i]);\n    } else {\n      break;\n    }\n  }\n\n  return value;\n}\n\nexport function getRoot(scope, key) {\n  if (scope.localPresent[key]) {\n    return [scope.locals[key]];\n  } else if (scope.self) {\n    return [scope.self[key]];\n  } else {\n    return [undefined];\n  }\n}\n\nexport function getBlock(scope, key) {\n  return scope.blocks[key];\n}\n\nexport function getChild(value, key) {\n  return value[key];\n}\n\nexport function getValue(reference) {\n  return reference;\n}\n\nexport function getCellOrValue(reference) {\n  return reference;\n}\n\nexport function component(morph, env, scope, tagName, params, attrs, templates, visitor) {\n  if (env.hooks.hasHelper(env, scope, tagName)) {\n    return env.hooks.block(morph, env, scope, tagName, params, attrs, templates.default, templates.inverse, visitor);\n  }\n\n  componentFallback(morph, env, scope, tagName, attrs, templates.default);\n}\n\nexport function concat(env, params) {\n  var value = \"\";\n  for (var i = 0, l = params.length; i < l; i++) {\n    value += env.hooks.getValue(params[i]);\n  }\n  return value;\n}\n\nfunction componentFallback(morph, env, scope, tagName, attrs, template) {\n  var element = env.dom.createElement(tagName);\n  for (var name in attrs) {\n    element.setAttribute(name, env.hooks.getValue(attrs[name]));\n  }\n  var fragment = render(template, env, scope, {}).fragment;\n  element.appendChild(fragment);\n  morph.setNode(element);\n}\n\nexport function hasHelper(env, scope, helperName) {\n  return env.helpers[helperName] !== undefined;\n}\n\nexport function lookupHelper(env, scope, helperName) {\n  return env.helpers[helperName];\n}\n\nexport function bindScope(/* env, scope */) {\n  // this function is used to handle host-specified extensions to scope\n  // other than `self`, `locals` and `block`.\n}\n\nexport function updateScope(env, scope) {\n  env.hooks.bindScope(env, scope);\n}\n\nexport default {\n  // fundamental hooks that you will likely want to override\n  bindLocal: bindLocal,\n  bindSelf: bindSelf,\n  bindScope: bindScope,\n  classify: classify,\n  component: component,\n  concat: concat,\n  createFreshScope: createFreshScope,\n  getChild: getChild,\n  getRoot: getRoot,\n  getBlock: getBlock,\n  getValue: getValue,\n  getCellOrValue: getCellOrValue,\n  keywords: keywords,\n  linkRenderNode: linkRenderNode,\n  partial: partial,\n  subexpr: subexpr,\n\n  // fundamental hooks with good default behavior\n  bindBlock: bindBlock,\n  bindShadowScope: bindShadowScope,\n  updateLocal: updateLocal,\n  updateSelf: updateSelf,\n  updateScope: updateScope,\n  createChildScope: createChildScope,\n  hasHelper: hasHelper,\n  lookupHelper: lookupHelper,\n  invokeHelper: invokeHelper,\n  cleanupRenderNode: null,\n  destroyRenderNode: null,\n  willCleanupTree: null,\n  didCleanupTree: null,\n  willRenderNode: null,\n  didRenderNode: null,\n\n  // derived hooks\n  attribute: attribute,\n  block: block,\n  createScope: createScope,\n  element: element,\n  get: get,\n  inline: inline,\n  range: range,\n  keyword: keyword\n};\n","import MorphBase from \"../morph-range\";\n\nvar guid = 1;\n\nfunction HTMLBarsMorph(domHelper, contextualElement) {\n  this.super$constructor(domHelper, contextualElement);\n\n  this._state = undefined;\n  this.ownerNode = null;\n  this.isDirty = false;\n  this.isSubtreeDirty = false;\n  this.lastYielded = null;\n  this.lastResult = null;\n  this.lastValue = null;\n  this.buildChildEnv = null;\n  this.morphList = null;\n  this.morphMap = null;\n  this.key = null;\n  this.linkedParams = null;\n  this.linkedResult = null;\n  this.childNodes = null;\n  this.rendered = false;\n  this.guid = \"range\" + guid++;\n  this.seen = false;\n}\n\nHTMLBarsMorph.empty = function(domHelper, contextualElement) {\n  var morph = new HTMLBarsMorph(domHelper, contextualElement);\n  morph.clear();\n  return morph;\n};\n\nHTMLBarsMorph.create = function (domHelper, contextualElement, node) {\n  var morph = new HTMLBarsMorph(domHelper, contextualElement);\n  morph.setNode(node);\n  return morph;\n};\n\nHTMLBarsMorph.attach = function (domHelper, contextualElement, firstNode, lastNode) {\n  var morph = new HTMLBarsMorph(domHelper, contextualElement);\n  morph.setRange(firstNode, lastNode);\n  return morph;\n};\n\nvar prototype = HTMLBarsMorph.prototype = Object.create(MorphBase.prototype);\nprototype.constructor = HTMLBarsMorph;\nprototype.super$constructor = MorphBase;\n\nprototype.getState = function() {\n  if (!this._state) {\n    this._state = {};\n  }\n\n  return this._state;\n};\n\nprototype.setState = function(newState) {\n  /*jshint -W093 */\n\n  return this._state = newState;\n};\n\n\nexport default HTMLBarsMorph;\n","import { validateChildMorphs, linkParams } from \"../htmlbars-util/morph-utils\";\nimport { acceptParams, acceptHash } from \"./expression-visitor\";\n\n/**\n  Node classification:\n\n  # Primary Statement Nodes:\n\n  These nodes are responsible for a render node that represents a morph-range.\n\n  * block\n  * inline\n  * content\n  * element\n  * component\n\n  # Leaf Statement Nodes:\n\n  This node is responsible for a render node that represents a morph-attr.\n\n  * attribute\n*/\n\nfunction linkParamsAndHash(env, scope, morph, path, params, hash) {\n  if (morph.linkedParams) {\n    params = morph.linkedParams.params;\n    hash = morph.linkedParams.hash;\n  } else {\n    params = params && acceptParams(params, env, scope);\n    hash = hash && acceptHash(hash, env, scope);\n  }\n\n  linkParams(env, scope, morph, path, params, hash);\n  return [params, hash];\n}\n\nexport let AlwaysDirtyVisitor = {\n\n  block(node, morph, env, scope, template, visitor) {\n    let [, path, params, hash, templateId, inverseId] = node;\n    let paramsAndHash = linkParamsAndHash(env, scope, morph, path, params, hash);\n\n    morph.isDirty = morph.isSubtreeDirty = false;\n    env.hooks.block(morph, env, scope, path, paramsAndHash[0], paramsAndHash[1],\n                           templateId === null ? null : template.templates[templateId],\n                           inverseId === null ? null : template.templates[inverseId],\n                           visitor);\n  },\n\n  inline(node, morph, env, scope, visitor) {\n    let [, path, params, hash] = node;\n    let paramsAndHash = linkParamsAndHash(env, scope, morph, path, params, hash);\n\n    morph.isDirty = morph.isSubtreeDirty = false;\n    env.hooks.inline(morph, env, scope, path, paramsAndHash[0], paramsAndHash[1], visitor);\n  },\n\n  content(node, morph, env, scope, visitor) {\n    let [, path] = node;\n\n    morph.isDirty = morph.isSubtreeDirty = false;\n\n    if (isHelper(env, scope, path)) {\n      env.hooks.inline(morph, env, scope, path, [], {}, visitor);\n      if (morph.linkedResult) {\n        linkParams(env, scope, morph, '@content-helper', [morph.linkedResult], null);\n      }\n      return;\n    }\n\n    let params;\n    if (morph.linkedParams) {\n      params = morph.linkedParams.params;\n    } else {\n      params = [env.hooks.get(env, scope, path)];\n    }\n\n    linkParams(env, scope, morph, '@range', params, null);\n    env.hooks.range(morph, env, scope, path, params[0], visitor);\n  },\n\n  element(node, morph, env, scope, visitor) {\n    let [, path, params, hash] = node;\n    let paramsAndHash = linkParamsAndHash(env, scope, morph, path, params, hash);\n\n    morph.isDirty = morph.isSubtreeDirty = false;\n    env.hooks.element(morph, env, scope, path, paramsAndHash[0], paramsAndHash[1], visitor);\n  },\n\n  attribute(node, morph, env, scope) {\n    let [, name, value] = node;\n    let paramsAndHash = linkParamsAndHash(env, scope, morph, '@attribute', [value], null);\n\n    morph.isDirty = morph.isSubtreeDirty = false;\n    env.hooks.attribute(morph, env, scope, name, paramsAndHash[0][0]);\n  },\n\n  component(node, morph, env, scope, template, visitor) {\n    let [, path, attrs, templateId, inverseId] = node;\n    let paramsAndHash = linkParamsAndHash(env, scope, morph, path, [], attrs);\n    let templates = {\n      default: template.templates[templateId],\n      inverse: template.templates[inverseId]\n    };\n\n    morph.isDirty = morph.isSubtreeDirty = false;\n    env.hooks.component(morph, env, scope, path, paramsAndHash[0], paramsAndHash[1],\n                        templates, visitor);\n  },\n\n  attributes(node, morph, env, scope, parentMorph, visitor) {\n    let [, template] = node;\n    env.hooks.attributes(morph, env, scope, template, parentMorph, visitor);\n  }\n\n};\n\nexport default {\n  block(node, morph, env, scope, template, visitor) {\n    dirtyCheck(env, morph, visitor, visitor => {\n      AlwaysDirtyVisitor.block(node, morph, env, scope, template, visitor);\n    });\n  },\n\n  inline(node, morph, env, scope, visitor) {\n    dirtyCheck(env, morph, visitor, visitor => {\n      AlwaysDirtyVisitor.inline(node, morph, env, scope, visitor);\n    });\n  },\n\n  content(node, morph, env, scope, visitor) {\n    dirtyCheck(env, morph, visitor, visitor => {\n      AlwaysDirtyVisitor.content(node, morph, env, scope, visitor);\n    });\n  },\n\n  element(node, morph, env, scope, template, visitor) {\n    dirtyCheck(env, morph, visitor, visitor => {\n      AlwaysDirtyVisitor.element(node, morph, env, scope, template, visitor);\n    });\n  },\n\n  attribute(node, morph, env, scope, template) {\n    dirtyCheck(env, morph, null, () => {\n      AlwaysDirtyVisitor.attribute(node, morph, env, scope, template);\n    });\n  },\n\n  component(node, morph, env, scope, template, visitor) {\n    dirtyCheck(env, morph, visitor, visitor => {\n      AlwaysDirtyVisitor.component(node, morph, env, scope, template, visitor);\n    });\n  },\n\n  attributes(node, morph, env, scope, parentMorph, visitor) {\n    AlwaysDirtyVisitor.attributes(node, morph, env, scope, parentMorph, visitor);\n  }\n};\n\nfunction dirtyCheck(_env, morph, visitor, callback) {\n  var isDirty = morph.isDirty;\n  var isSubtreeDirty = morph.isSubtreeDirty;\n  var env = _env;\n\n  if (isSubtreeDirty) {\n    visitor = AlwaysDirtyVisitor;\n  }\n\n  if (isDirty || isSubtreeDirty) {\n    callback(visitor);\n  } else {\n    if (morph.buildChildEnv) {\n      env = morph.buildChildEnv(morph.getState(), env);\n    }\n    validateChildMorphs(env, morph, visitor);\n  }\n}\n\nfunction isHelper(env, scope, path) {\n  return (env.hooks.keywords[path] !== undefined) || env.hooks.hasHelper(env, scope, path);\n}\n","import { visitChildren } from \"../htmlbars-util/morph-utils\";\nimport ExpressionVisitor from \"./node-visitor\";\nimport { AlwaysDirtyVisitor } from \"./node-visitor\";\nimport Morph from \"./morph\";\nimport { clearMorph } from \"../htmlbars-util/template-utils\";\nimport voidMap from '../htmlbars-util/void-tag-names';\n\nvar svgNamespace = \"http://www.w3.org/2000/svg\";\n\nexport default function render(template, env, scope, options) {\n  var dom = env.dom;\n  var contextualElement;\n\n  if (options) {\n    if (options.renderNode) {\n      contextualElement = options.renderNode.contextualElement;\n    } else if (options.contextualElement) {\n      contextualElement = options.contextualElement;\n    }\n  }\n\n  dom.detectNamespace(contextualElement);\n\n  var renderResult = RenderResult.build(env, scope, template, options, contextualElement);\n  renderResult.render();\n\n  return renderResult;\n}\n\nexport function RenderOptions(renderNode, self, blockArguments, contextualElement) {\n  this.renderNode = renderNode || null;\n  this.self = self;\n  this.blockArguments = blockArguments || null;\n  this.contextualElement = contextualElement || null;\n}\n\nfunction RenderResult(env, scope, options, rootNode, ownerNode, nodes, fragment, template, shouldSetContent) {\n  this.root = rootNode;\n  this.fragment = fragment;\n\n  this.nodes = nodes;\n  this.template = template;\n  this.statements = template.statements.slice();\n  this.env = env;\n  this.scope = scope;\n  this.shouldSetContent = shouldSetContent;\n\n  if (options.self !== undefined) { this.bindSelf(options.self); }\n  if (options.blockArguments !== undefined) { this.bindLocals(options.blockArguments); }\n\n  this.initializeNodes(ownerNode);\n}\n\nRenderResult.build = function(env, scope, template, options, contextualElement) {\n  var dom = env.dom;\n  var fragment = getCachedFragment(template, env);\n  var nodes = template.buildRenderNodes(dom, fragment, contextualElement);\n\n  var rootNode, ownerNode, shouldSetContent;\n\n  if (options && options.renderNode) {\n    rootNode = options.renderNode;\n    ownerNode = rootNode.ownerNode;\n    shouldSetContent = true;\n  } else {\n    rootNode = dom.createMorph(null, fragment.firstChild, fragment.lastChild, contextualElement);\n    ownerNode = rootNode;\n    rootNode.ownerNode = ownerNode;\n    shouldSetContent = false;\n  }\n\n  if (rootNode.childNodes) {\n    visitChildren(rootNode.childNodes, function(node) {\n      clearMorph(node, env, true);\n    });\n  }\n\n  rootNode.childNodes = nodes;\n  return new RenderResult(env, scope, options, rootNode, ownerNode, nodes, fragment, template, shouldSetContent);\n};\n\nexport function manualElement(tagName, attributes, _isEmpty) {\n  var statements = [];\n\n  for (var key in attributes) {\n    if (typeof attributes[key] === 'string') { continue; }\n    statements.push([\"attribute\", key, attributes[key]]);\n  }\n\n  var isEmpty = _isEmpty || voidMap[tagName];\n\n  if (!isEmpty) {\n    statements.push(['content', 'yield']);\n  }\n\n  var template = {\n    arity: 0,\n    cachedFragment: null,\n    hasRendered: false,\n    buildFragment: function buildFragment(dom) {\n      var el0 = dom.createDocumentFragment();\n      if (tagName === 'svg') {\n        dom.setNamespace(svgNamespace);\n      }\n      var el1 = dom.createElement(tagName);\n\n      for (var key in attributes) {\n        if (typeof attributes[key] !== 'string') { continue; }\n        dom.setAttribute(el1, key, attributes[key]);\n      }\n\n      if (!isEmpty) {\n        var el2 = dom.createComment(\"\");\n        dom.appendChild(el1, el2);\n      }\n\n      dom.appendChild(el0, el1);\n\n      return el0;\n    },\n    buildRenderNodes: function buildRenderNodes(dom, fragment) {\n      var element = dom.childAt(fragment, [0]);\n      var morphs = [];\n\n      for (var key in attributes) {\n        if (typeof attributes[key] === 'string') { continue; }\n        morphs.push(dom.createAttrMorph(element, key));\n      }\n\n      if (!isEmpty) {\n        morphs.push(dom.createMorphAt(element, 0, 0));\n      }\n\n      return morphs;\n    },\n    statements: statements,\n    locals: [],\n    templates: []\n  };\n\n  return template;\n}\n\nexport function attachAttributes(attributes) {\n  var statements = [];\n\n  for (var key in attributes) {\n    if (typeof attributes[key] === 'string') { continue; }\n    statements.push([\"attribute\", key, attributes[key]]);\n  }\n\n  var template = {\n    arity: 0,\n    cachedFragment: null,\n    hasRendered: false,\n    buildFragment: function buildFragment(dom) {\n      var el0 = this.element;\n      if (el0.namespaceURI === \"http://www.w3.org/2000/svg\") {\n        dom.setNamespace(svgNamespace);\n      }\n      for (var key in attributes) {\n        if (typeof attributes[key] !== 'string') { continue; }\n        dom.setAttribute(el0, key, attributes[key]);\n      }\n\n      return el0;\n    },\n    buildRenderNodes: function buildRenderNodes(dom) {\n      var element = this.element;\n      var morphs = [];\n\n      for (var key in attributes) {\n        if (typeof attributes[key] === 'string') { continue; }\n        morphs.push(dom.createAttrMorph(element, key));\n      }\n\n      return morphs;\n    },\n    statements: statements,\n    locals: [],\n    templates: [],\n    element: null\n  };\n\n  return template;\n}\n\nRenderResult.prototype.initializeNodes = function(ownerNode) {\n  let childNodes = this.root.childNodes;\n\n  for (let i=0, l=childNodes.length; i<l; i++) {\n    childNodes[i].ownerNode = ownerNode;\n  }\n};\n\nRenderResult.prototype.render = function() {\n  this.root.lastResult = this;\n  this.root.rendered = true;\n  this.populateNodes(AlwaysDirtyVisitor);\n\n  if (this.shouldSetContent && this.root.setContent) {\n    this.root.setContent(this.fragment);\n  }\n};\n\nRenderResult.prototype.dirty = function() {\n  visitChildren([this.root], function(node) { node.isDirty = true; });\n};\n\nRenderResult.prototype.revalidate = function(env, self, blockArguments, scope) {\n  this.revalidateWith(env, scope, self, blockArguments, ExpressionVisitor);\n};\n\nRenderResult.prototype.rerender = function(env, self, blockArguments, scope) {\n  this.revalidateWith(env, scope, self, blockArguments, AlwaysDirtyVisitor);\n};\n\nRenderResult.prototype.revalidateWith = function(env, scope, self, blockArguments, visitor) {\n  if (env !== undefined) { this.env = env; }\n  if (scope !== undefined) { this.scope = scope; }\n  this.updateScope();\n\n  if (self !== undefined) { this.updateSelf(self); }\n  if (blockArguments !== undefined) { this.updateLocals(blockArguments); }\n\n  this.populateNodes(visitor);\n};\n\nRenderResult.prototype.destroy = function() {\n  var rootNode = this.root;\n  clearMorph(rootNode, this.env, true);\n};\n\nRenderResult.prototype.populateNodes = function(visitor) {\n  var env = this.env;\n  var scope = this.scope;\n  var template = this.template;\n  var nodes = this.nodes;\n  var statements = this.statements;\n  var i, l;\n\n  for (i=0, l=statements.length; i<l; i++) {\n    var statement = statements[i];\n    var morph = nodes[i];\n\n    if (env.hooks.willRenderNode) {\n      env.hooks.willRenderNode(morph, env, scope);\n    }\n\n    switch (statement[0]) {\n      case 'block': visitor.block(statement, morph, env, scope, template, visitor); break;\n      case 'inline': visitor.inline(statement, morph, env, scope, visitor); break;\n      case 'content': visitor.content(statement, morph, env, scope, visitor); break;\n      case 'element': visitor.element(statement, morph, env, scope, template, visitor); break;\n      case 'attribute': visitor.attribute(statement, morph, env, scope); break;\n      case 'component': visitor.component(statement, morph, env, scope, template, visitor); break;\n    }\n\n    if (env.hooks.didRenderNode) {\n      env.hooks.didRenderNode(morph, env, scope);\n    }\n  }\n};\n\nRenderResult.prototype.bindScope = function() {\n  this.env.hooks.bindScope(this.env, this.scope);\n};\n\nRenderResult.prototype.updateScope = function() {\n  this.env.hooks.updateScope(this.env, this.scope);\n};\n\nRenderResult.prototype.bindSelf = function(self) {\n  this.env.hooks.bindSelf(this.env, this.scope, self);\n};\n\nRenderResult.prototype.updateSelf = function(self) {\n  this.env.hooks.updateSelf(this.env, this.scope, self);\n};\n\nRenderResult.prototype.bindLocals = function(blockArguments) {\n  var localNames = this.template.locals;\n\n  for (var i=0, l=localNames.length; i<l; i++) {\n    this.env.hooks.bindLocal(this.env, this.scope, localNames[i], blockArguments[i]);\n  }\n};\n\nRenderResult.prototype.updateLocals = function(blockArguments) {\n  var localNames = this.template.locals;\n\n  for (var i=0, l=localNames.length; i<l; i++) {\n    this.env.hooks.updateLocal(this.env, this.scope, localNames[i], blockArguments[i]);\n  }\n};\n\nfunction initializeNode(node, owner) {\n  node.ownerNode = owner;\n}\n\nexport function createChildMorph(dom, parentMorph, contextualElement) {\n  var morph = Morph.empty(dom, contextualElement || parentMorph.contextualElement);\n  initializeNode(morph, parentMorph.ownerNode);\n  return morph;\n}\n\nexport function getCachedFragment(template, env) {\n  var dom = env.dom, fragment;\n  if (env.useFragmentCache && dom.canClone) {\n    if (template.cachedFragment === null) {\n      fragment = template.buildFragment(dom);\n      if (template.hasRendered) {\n        template.cachedFragment = fragment;\n      } else {\n        template.hasRendered = true;\n      }\n    }\n    if (template.cachedFragment) {\n      fragment = dom.cloneNode(template.cachedFragment, true);\n    }\n  } else if (!fragment) {\n    fragment = template.buildFragment(dom);\n  }\n\n  return fragment;\n}\n","import SafeString from './htmlbars-util/safe-string';\nimport { escapeExpression } from './htmlbars-util/handlebars/utils';\nimport { getAttrNamespace } from './htmlbars-util/namespaces';\nimport { validateChildMorphs, linkParams, dump } from './htmlbars-util/morph-utils';\n\nexport {\n  SafeString,\n  escapeExpression,\n  getAttrNamespace,\n  validateChildMorphs,\n  linkParams,\n  dump\n};\n","export function forEach(array, callback, binding) {\n  var i, l;\n  if (binding === undefined) {\n    for (i = 0, l = array.length; i < l; i++) {\n      callback(array[i], i, array);\n    }\n  } else {\n    for (i = 0, l = array.length; i < l; i++) {\n      callback.call(binding, array[i], i, array);\n    }\n  }\n}\n\nexport function map(array, callback) {\n  var output = [];\n  var i, l;\n\n  for (i = 0, l = array.length; i < l; i++) {\n    output.push(callback(array[i], i, array));\n  }\n\n  return output;\n}\n\nvar getIdx;\nif (Array.prototype.indexOf) {\n  getIdx = function(array, obj, from){\n    return array.indexOf(obj, from);\n  };\n} else {\n  getIdx = function(array, obj, from) {\n    if (from === undefined || from === null) {\n      from = 0;\n    } else if (from < 0) {\n      from = Math.max(0, array.length + from);\n    }\n    for (var i = from, l= array.length; i < l; i++) {\n      if (array[i] === obj) {\n        return i;\n      }\n    }\n    return -1;\n  };\n}\n\nexport var isArray = (Array.isArray || function(array) {\n  return Object.prototype.toString.call(array) === '[object Array]';\n});\n\nexport var indexOfArray = getIdx;\n","// Build out our basic SafeString type\nfunction SafeString(string) {\n  this.string = string;\n}\n\nSafeString.prototype.toString = SafeString.prototype.toHTML = function() {\n  return '' + this.string;\n};\n\nexport default SafeString;\n","const escape = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#x27;',\n  '`': '&#x60;'\n};\n\nconst badChars = /[&<>\"'`]/g,\n      possible = /[&<>\"'`]/;\n\nfunction escapeChar(chr) {\n  return escape[chr];\n}\n\nexport function extend(obj /* , ...source */) {\n  for (let i = 1; i < arguments.length; i++) {\n    for (let key in arguments[i]) {\n      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {\n        obj[key] = arguments[i][key];\n      }\n    }\n  }\n\n  return obj;\n}\n\nexport let toString = Object.prototype.toString;\n\n// Sourced from lodash\n// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt\n/*eslint-disable func-style, no-var */\nvar isFunction = function(value) {\n  return typeof value === 'function';\n};\n// fallback for older versions of Chrome and Safari\n/* istanbul ignore next */\nif (isFunction(/x/)) {\n  isFunction = function(value) {\n    return typeof value === 'function' && toString.call(value) === '[object Function]';\n  };\n}\nexport var isFunction;\n/*eslint-enable func-style, no-var */\n\n/* istanbul ignore next */\nexport const isArray = Array.isArray || function(value) {\n  return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;\n};\n\n// Older IE versions do not directly support indexOf so we must implement our own, sadly.\nexport function indexOf(array, value) {\n  for (let i = 0, len = array.length; i < len; i++) {\n    if (array[i] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n\nexport function escapeExpression(string) {\n  if (typeof string !== 'string') {\n    // don't escape SafeStrings, since they're already safe\n    if (string && string.toHTML) {\n      return string.toHTML();\n    } else if (string == null) {\n      return '';\n    } else if (!string) {\n      return string + '';\n    }\n\n    // Force a string conversion as this will be done by the append regardless and\n    // the regex test will do this transparently behind the scenes, causing issues if\n    // an object's to string has escaped characters in it.\n    string = '' + string;\n  }\n\n  if (!possible.test(string)) { return string; }\n  return string.replace(badChars, escapeChar);\n}\n\nexport function isEmpty(value) {\n  if (!value && value !== 0) {\n    return true;\n  } else if (isArray(value) && value.length === 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function blockParams(params, ids) {\n  params.path = ids;\n  return params;\n}\n\nexport function appendContextPath(contextPath, id) {\n  return (contextPath ? contextPath + '.' : '') + id;\n}\n","/*globals console*/\n\nexport function visitChildren(nodes, callback) {\n  if (!nodes || nodes.length === 0) { return; }\n\n  nodes = nodes.slice();\n\n  while (nodes.length) {\n    var node = nodes.pop();\n    callback(node);\n\n    if (node.childNodes) {\n      nodes.push.apply(nodes, node.childNodes);\n    } else if (node.firstChildMorph) {\n      let current = node.firstChildMorph;\n\n      while (current) {\n        nodes.push(current);\n        current = current.nextMorph;\n      }\n    } else if (node.morphList) {\n      let current = node.morphList.firstChildMorph;\n\n      while (current) {\n        nodes.push(current);\n        current = current.nextMorph;\n      }\n    }\n  }\n}\n\n\nexport function validateChildMorphs(env, morph, visitor) {\n  var morphList = morph.morphList;\n  if (morph.morphList) {\n    var current = morphList.firstChildMorph;\n\n    while (current) {\n      var next = current.nextMorph;\n      validateChildMorphs(env, current, visitor);\n      current = next;\n    }\n  } else if (morph.lastResult) {\n    morph.lastResult.revalidateWith(env, undefined, undefined, undefined, visitor);\n  } else if (morph.childNodes) {\n    // This means that the childNodes were wired up manually\n    for (var i=0, l=morph.childNodes.length; i<l; i++) {\n      validateChildMorphs(env, morph.childNodes[i], visitor);\n    }\n  }\n}\n\nexport function linkParams(env, scope, morph, path, params, hash) {\n  if (morph.linkedParams) {\n    return;\n  }\n\n  if (env.hooks.linkRenderNode(morph, env, scope, path, params, hash)) {\n    morph.linkedParams = { params: params, hash: hash };\n  }\n}\n\nexport function dump(node) {\n  console.group(node, node.isDirty);\n\n  if (node.childNodes) {\n    map(node.childNodes, dump);\n  } else if (node.firstChildMorph) {\n    var current = node.firstChildMorph;\n\n    while (current) {\n      dump(current);\n      current = current.nextMorph;\n    }\n  } else if (node.morphList) {\n    dump(node.morphList);\n  }\n\n  console.groupEnd();\n}\n\nfunction map(nodes, cb) {\n  for (var i=0, l=nodes.length; i<l; i++) {\n    cb(nodes[i]);\n  }\n}\n","// ref http://dev.w3.org/html5/spec-LC/namespaces.html\nvar defaultNamespaces = {\n  html: 'http://www.w3.org/1999/xhtml',\n  mathml: 'http://www.w3.org/1998/Math/MathML',\n  svg: 'http://www.w3.org/2000/svg',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace'\n};\n\nexport function getAttrNamespace(attrName, detectedNamespace) {\n  if (detectedNamespace) {\n    return detectedNamespace;\n  }\n\n  var namespace;\n\n  var colonIndex = attrName.indexOf(':');\n  if (colonIndex !== -1) {\n    var prefix = attrName.slice(0, colonIndex);\n    namespace = defaultNamespaces[prefix];\n  }\n\n  return namespace || null;\n}\n","export function merge(options, defaults) {\n  for (var prop in defaults) {\n    if (options.hasOwnProperty(prop)) { continue; }\n    options[prop] = defaults[prop];\n  }\n  return options;\n}\n\nexport function shallowCopy(obj) {\n  return merge({}, obj);\n}\n\nexport function keySet(obj) {\n  var set = {};\n\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      set[prop] = true;\n    }\n  }\n\n  return set;\n}\n\nexport function keyLength(obj) {\n  var count = 0;\n\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      count++;\n    }\n  }\n\n  return count;\n}\n","import SafeString from './handlebars/safe-string';\n\nexport default SafeString;\n","import { visitChildren } from \"../htmlbars-util/morph-utils\";\nimport { RenderOptions } from \"../htmlbars-runtime/render\";\n\nexport function RenderState(renderNode, morphList) {\n  // The morph list that is no longer needed and can be\n  // destroyed.\n  this.morphListToClear = morphList;\n\n  // The morph list that needs to be pruned of any items\n  // that were not yielded on a subsequent render.\n  this.morphListToPrune = null;\n\n  // A map of morphs for each item yielded in during this\n  // rendering pass. Any morphs in the DOM but not in this map\n  // will be pruned during cleanup.\n  this.handledMorphs = {};\n  this.collisions = undefined;\n\n  // The morph to clear once rendering is complete. By\n  // default, we set this to the previous morph (to catch\n  // the case where nothing is yielded; in that case, we\n  // should just clear the morph). Otherwise this gets set\n  // to null if anything is rendered.\n  this.morphToClear = renderNode;\n\n  this.shadowOptions = null;\n}\n\nfunction Block(render, template, blockOptions) {\n  this.render = render;\n  this.template = template;\n  this.blockOptions = blockOptions;\n  this.arity = template.arity;\n}\n\nBlock.prototype.invoke = function(env, blockArguments, _self, renderNode, parentScope, visitor) {\n  if (renderNode.lastResult) {\n    renderNode.lastResult.revalidateWith(env, undefined, _self, blockArguments, visitor);\n  } else {\n    this._firstRender(env, blockArguments, _self, renderNode, parentScope);\n  }\n};\n\nBlock.prototype._firstRender = function(env, blockArguments, _self, renderNode, parentScope) {\n  let options = { renderState: new RenderState(renderNode) };\n  let { render, template, blockOptions: { scope } } = this;\n  let shadowScope = scope ? env.hooks.createChildScope(scope) : env.hooks.createFreshScope();\n\n  env.hooks.bindShadowScope(env, parentScope, shadowScope, this.blockOptions.options);\n\n  if (_self !== undefined) {\n    env.hooks.bindSelf(env, shadowScope, _self);\n  } else if (this.blockOptions.self !== undefined) {\n    env.hooks.bindSelf(env, shadowScope, this.blockOptions.self);\n  }\n\n  bindBlocks(env, shadowScope, this.blockOptions.yieldTo);\n\n  renderAndCleanup(renderNode, env, options, null, function() {\n    options.renderState.morphToClear = null;\n    let renderOptions = new RenderOptions(renderNode, undefined, blockArguments);\n    render(template, env, shadowScope, renderOptions);\n  });\n};\n\nexport function blockFor(render, template, blockOptions) {\n  return new Block(render, template, blockOptions);\n}\n\nfunction bindBlocks(env, shadowScope, blocks) {\n  if (!blocks) {\n    return;\n  }\n  if (blocks instanceof Block) {\n    env.hooks.bindBlock(env, shadowScope, blocks);\n  } else {\n    for (var name in blocks) {\n      if (blocks.hasOwnProperty(name)) {\n        env.hooks.bindBlock(env, shadowScope, blocks[name], name);\n      }\n    }\n  }\n}\n\nexport function renderAndCleanup(morph, env, options, shadowOptions, callback) {\n  // The RenderState object is used to collect information about what the\n  // helper or hook being invoked has yielded. Once it has finished either\n  // yielding multiple items (via yieldItem) or a single template (via\n  // yieldTemplate), we detect what was rendered and how it differs from\n  // the previous render, cleaning up old state in DOM as appropriate.\n  var renderState = options.renderState;\n  renderState.collisions = undefined;\n  renderState.shadowOptions = shadowOptions;\n\n  // Invoke the callback, instructing it to save information about what it\n  // renders into RenderState.\n  var result = callback(options);\n\n  // The hook can opt-out of cleanup if it handled cleanup itself.\n  if (result && result.handled) {\n    return;\n  }\n\n  var morphMap = morph.morphMap;\n\n  // Walk the morph list, clearing any items that were yielded in a previous\n  // render but were not yielded during this render.\n  let morphList = renderState.morphListToPrune;\n  if (morphList) {\n    let handledMorphs = renderState.handledMorphs;\n    let item = morphList.firstChildMorph;\n\n    while (item) {\n      let next = item.nextMorph;\n\n      // If we don't see the key in handledMorphs, it wasn't\n      // yielded in and we can safely remove it from DOM.\n      if (!(item.key in handledMorphs)) {\n        morphMap[item.key] = undefined;\n        clearMorph(item, env, true);\n        item.destroy();\n      }\n\n      item = next;\n    }\n  }\n\n  morphList = renderState.morphListToClear;\n  if (morphList) {\n    clearMorphList(morphList, morph, env);\n  }\n\n  let toClear = renderState.morphToClear;\n  if (toClear) {\n    clearMorph(toClear, env);\n  }\n}\n\nexport function clearMorph(morph, env, destroySelf) {\n  var cleanup = env.hooks.cleanupRenderNode;\n  var destroy = env.hooks.destroyRenderNode;\n  var willCleanup = env.hooks.willCleanupTree;\n  var didCleanup = env.hooks.didCleanupTree;\n\n  function destroyNode(node) {\n    if (cleanup) { cleanup(node); }\n    if (destroy) { destroy(node); }\n  }\n\n  if (willCleanup) { willCleanup(env, morph, destroySelf); }\n  if (cleanup) { cleanup(morph); }\n  if (destroySelf && destroy) { destroy(morph); }\n\n  visitChildren(morph.childNodes, destroyNode);\n\n  // TODO: Deal with logical children that are not in the DOM tree\n  morph.clear();\n  if (didCleanup) { didCleanup(env, morph, destroySelf); }\n\n  morph.lastResult = null;\n  morph.lastYielded = null;\n  morph.childNodes = null;\n}\n\nexport function clearMorphList(morphList, morph, env) {\n  let item = morphList.firstChildMorph;\n\n  while (item) {\n    let next = item.nextMorph;\n    morph.morphMap[item.key] = undefined;\n    clearMorph(item, env, true);\n    item.destroy();\n\n    item = next;\n  }\n\n  // Remove the MorphList from the morph.\n  morphList.clear();\n  morph.morphList = null;\n}\n","import { forEach } from \"./array-utils\";\n\n// The HTML elements in this list are speced by\n// http://www.w3.org/TR/html-markup/syntax.html#syntax-elements,\n// and will be forced to close regardless of if they have a\n// self-closing /> at the end.\nvar voidTagNames = \"area base br col command embed hr img input keygen link meta param source track wbr\";\nvar voidMap = {};\n\nforEach(voidTagNames.split(\" \"), function(tagName) {\n  voidMap[tagName] = true;\n});\n\nexport default voidMap;\n","import { sanitizeAttributeValue } from \"./morph-attr/sanitize-attribute-value\";\nimport { isAttrRemovalValue, normalizeProperty } from \"./dom-helper/prop\";\nimport { svgNamespace } from \"./dom-helper/build-html-dom\";\nimport { getAttrNamespace } from \"./htmlbars-util\";\n\nfunction getProperty() {\n  return this.domHelper.getPropertyStrict(this.element, this.attrName);\n}\n\nfunction updateProperty(value) {\n  if (this._renderedInitially === true || !isAttrRemovalValue(value)) {\n    // do not render if initial value is undefined or null\n    this.domHelper.setPropertyStrict(this.element, this.attrName, value);\n  }\n\n  this._renderedInitially = true;\n}\n\nfunction getAttribute() {\n  return this.domHelper.getAttribute(this.element, this.attrName);\n}\n\nfunction updateAttribute(value) {\n  if (isAttrRemovalValue(value)) {\n    this.domHelper.removeAttribute(this.element, this.attrName);\n  } else {\n    this.domHelper.setAttribute(this.element, this.attrName, value);\n  }\n}\n\nfunction getAttributeNS() {\n  return this.domHelper.getAttributeNS(this.element, this.namespace, this.attrName);\n}\n\nfunction updateAttributeNS(value) {\n  if (isAttrRemovalValue(value)) {\n    this.domHelper.removeAttribute(this.element, this.attrName);\n  } else {\n    this.domHelper.setAttributeNS(this.element, this.namespace, this.attrName, value);\n  }\n}\n\nvar UNSET = { unset: true };\n\nvar guid = 1;\n\nAttrMorph.create = function(element, attrName, domHelper, namespace) {\n  let ns = getAttrNamespace(attrName, namespace);\n\n  if (ns) {\n    return new AttributeNSAttrMorph(element, attrName, domHelper, ns);\n  } else {\n    return createNonNamespacedAttrMorph(element, attrName, domHelper);\n  }\n};\n\nfunction createNonNamespacedAttrMorph(element, attrName, domHelper) {\n  let { normalized, type } = normalizeProperty(element, attrName);\n\n  if (element.namespaceURI === svgNamespace || attrName === 'style' || type === 'attr') {\n    return new AttributeAttrMorph(element, normalized, domHelper);\n  } else {\n    return new PropertyAttrMorph(element, normalized, domHelper);\n  }\n}\n\nfunction AttrMorph(element, attrName, domHelper) {\n  this.element = element;\n  this.domHelper = domHelper;\n  this.attrName = attrName;\n  this._state = undefined;\n  this.isDirty = false;\n  this.isSubtreeDirty = false;\n  this.escaped = true;\n  this.lastValue = UNSET;\n  this.lastResult = null;\n  this.lastYielded = null;\n  this.childNodes = null;\n  this.linkedParams = null;\n  this.linkedResult = null;\n  this.guid = \"attr\" + guid++;\n  this.seen = false;\n  this.ownerNode = null;\n  this.rendered = false;\n  this._renderedInitially = false;\n  this.namespace = undefined;\n  this.didInit();\n}\n\nAttrMorph.prototype.getState = function() {\n  if (!this._state) {\n    this._state = {};\n  }\n\n  return this._state;\n};\n\nAttrMorph.prototype.setState = function(newState) {\n  /*jshint -W093 */\n\n  return this._state = newState;\n};\n\nAttrMorph.prototype.didInit = function() {};\nAttrMorph.prototype.willSetContent = function() {};\n\nAttrMorph.prototype.setContent = function (value) {\n  this.willSetContent(value);\n\n  if (this.lastValue === value) { return; }\n  this.lastValue = value;\n\n  if (this.escaped) {\n    var sanitized = sanitizeAttributeValue(this.domHelper, this.element, this.attrName, value);\n    this._update(sanitized, this.namespace);\n  } else {\n    this._update(value, this.namespace);\n  }\n};\n\nAttrMorph.prototype.getContent = function () {\n  var value = this.lastValue = this._get();\n  return value;\n};\n\n// renderAndCleanup calls `clear` on all items in the morph map\n// just before calling `destroy` on the morph.\n//\n// As a future refactor this could be changed to set the property\n// back to its original/default value.\nAttrMorph.prototype.clear = function() { };\n\nAttrMorph.prototype.destroy = function() {\n  this.element = null;\n  this.domHelper = null;\n};\n\nAttrMorph.prototype._$superAttrMorph = AttrMorph;\n\nfunction PropertyAttrMorph(element, attrName, domHelper) {\n  this._$superAttrMorph(element, attrName, domHelper);\n}\n\nPropertyAttrMorph.prototype = Object.create(AttrMorph.prototype);\nPropertyAttrMorph.prototype._update = updateProperty;\nPropertyAttrMorph.prototype._get = getProperty;\n\nfunction AttributeNSAttrMorph(element, attrName, domHelper, namespace) {\n  this._$superAttrMorph(element, attrName, domHelper);\n  this.namespace = namespace;\n}\n\nAttributeNSAttrMorph.prototype = Object.create(AttrMorph.prototype);\nAttributeNSAttrMorph.prototype._update = updateAttributeNS;\nAttributeNSAttrMorph.prototype._get = getAttributeNS;\n\nfunction AttributeAttrMorph(element, attrName, domHelper) {\n  this._$superAttrMorph(element, attrName, domHelper);\n}\n\nAttributeAttrMorph.prototype = Object.create(AttrMorph.prototype);\nAttributeAttrMorph.prototype._update = updateAttribute;\nAttributeAttrMorph.prototype._get = getAttribute;\n\nexport default AttrMorph;\n\nexport { sanitizeAttributeValue };\n","/* jshint scripturl:true */\n\nvar badProtocols = {\n  'javascript:': true,\n  'vbscript:': true\n};\n\nvar badTags = {\n  'A': true,\n  'BODY': true,\n  'LINK': true,\n  'IMG': true,\n  'IFRAME': true,\n  'BASE': true,\n  'FORM': true\n};\n\nvar badTagsForDataURI = {\n  'EMBED': true\n};\n\nexport var badAttributes = {\n  'href': true,\n  'src': true,\n  'background': true,\n  'action': true\n};\n\nvar badAttributesForDataURI = {\n  'src': true\n};\n\nexport function sanitizeAttributeValue(dom, element, attribute, value) {\n  var tagName;\n\n  if (!element) {\n    tagName = null;\n  } else {\n    tagName = element.tagName.toUpperCase();\n  }\n\n  if (value && value.toHTML) {\n    return value.toHTML();\n  }\n\n  if ((tagName === null || badTags[tagName]) && badAttributes[attribute]) {\n    var protocol = dom.protocolForURL(value);\n    if (badProtocols[protocol] === true) {\n      return 'unsafe:' + value;\n    }\n  }\n\n  if (badTagsForDataURI[tagName] && badAttributesForDataURI[attribute]) {\n    return 'unsafe:' + value;\n  }\n\n  return value;\n}\n","import { clear, insertBefore } from './morph-range/utils';\n\n// constructor just initializes the fields\n// use one of the static initializers to create a valid morph.\nfunction Morph(domHelper, contextualElement) {\n  this.domHelper = domHelper;\n  // context if content if current content is detached\n  this.contextualElement = contextualElement;\n  // inclusive range of morph\n  // these should be nodeType 1, 3, or 8\n  this.firstNode = null;\n  this.lastNode  = null;\n\n  // flag to force text to setContent to be treated as html\n  this.parseTextAsHTML = false;\n\n  // morph list graph\n  this.parentMorphList = null;\n  this.previousMorph   = null;\n  this.nextMorph       = null;\n}\n\nMorph.empty = function (domHelper, contextualElement) {\n  var morph = new Morph(domHelper, contextualElement);\n  morph.clear();\n  return morph;\n};\n\nMorph.create = function (domHelper, contextualElement, node) {\n  var morph = new Morph(domHelper, contextualElement);\n  morph.setNode(node);\n  return morph;\n};\n\nMorph.attach = function (domHelper, contextualElement, firstNode, lastNode) {\n  var morph = new Morph(domHelper, contextualElement);\n  morph.setRange(firstNode, lastNode);\n  return morph;\n};\n\nMorph.prototype.setContent = function Morph$setContent(content) {\n  if (content === null || content === undefined) {\n    return this.clear();\n  }\n\n  var type = typeof content;\n  switch (type) {\n    case 'string':\n      if (this.parseTextAsHTML) {\n        return this.domHelper.setMorphHTML(this, content);\n      }\n      return this.setText(content);\n    case 'object':\n      if (typeof content.nodeType === 'number') {\n        return this.setNode(content);\n      }\n      /* Handlebars.SafeString */\n      if (typeof content.string === 'string') {\n        return this.setHTML(content.string);\n      }\n      if (this.parseTextAsHTML) {\n        return this.setHTML(content.toString());\n      }\n      /* falls through */\n    case 'boolean':\n    case 'number':\n      return this.setText(content.toString());\n    case 'function':\n      raiseCannotBindToFunction(content);\n    default:\n      throw new TypeError('unsupported content');\n  }\n};\n\nfunction raiseCannotBindToFunction(content) {\n  var functionName = content.name;\n  var message;\n\n  if (functionName) {\n    message = 'Unsupported Content: Cannot bind to function `' + functionName + '`';\n  } else {\n    message = 'Unsupported Content: Cannot bind to function';\n  }\n\n  throw new TypeError(message);\n}\n\nMorph.prototype.clear = function Morph$clear() {\n  var node = this.setNode(this.domHelper.createComment(''));\n  return node;\n};\n\nMorph.prototype.setText = function Morph$setText(text) {\n  var firstNode = this.firstNode;\n  var lastNode = this.lastNode;\n\n  if (firstNode &&\n      lastNode === firstNode &&\n      firstNode.nodeType === 3) {\n    firstNode.nodeValue = text;\n    return firstNode;\n  }\n\n  return this.setNode(\n    text ? this.domHelper.createTextNode(text) : this.domHelper.createComment('')\n  );\n};\n\nMorph.prototype.setNode = function Morph$setNode(newNode) {\n  var firstNode, lastNode;\n  switch (newNode.nodeType) {\n    case 3:\n      firstNode = newNode;\n      lastNode = newNode;\n      break;\n    case 11:\n      firstNode = newNode.firstChild;\n      lastNode = newNode.lastChild;\n      if (firstNode === null) {\n        firstNode = this.domHelper.createComment('');\n        newNode.appendChild(firstNode);\n        lastNode = firstNode;\n      }\n      break;\n    default:\n      firstNode = newNode;\n      lastNode = newNode;\n      break;\n  }\n\n  this.setRange(firstNode, lastNode);\n\n  return newNode;\n};\n\nMorph.prototype.setRange = function (firstNode, lastNode) {\n  var previousFirstNode = this.firstNode;\n  if (previousFirstNode !== null) {\n\n    var parentNode = previousFirstNode.parentNode;\n    if (parentNode !== null) {\n      insertBefore(parentNode, firstNode, lastNode, previousFirstNode);\n      clear(parentNode, previousFirstNode, this.lastNode);\n    }\n  }\n\n  this.firstNode = firstNode;\n  this.lastNode = lastNode;\n\n  if (this.parentMorphList) {\n    this._syncFirstNode();\n    this._syncLastNode();\n  }\n};\n\nMorph.prototype.destroy = function Morph$destroy() {\n  this.unlink();\n\n  var firstNode = this.firstNode;\n  var lastNode = this.lastNode;\n  var parentNode = firstNode && firstNode.parentNode;\n\n  this.firstNode = null;\n  this.lastNode = null;\n\n  clear(parentNode, firstNode, lastNode);\n};\n\nMorph.prototype.unlink = function Morph$unlink() {\n  var parentMorphList = this.parentMorphList;\n  var previousMorph = this.previousMorph;\n  var nextMorph = this.nextMorph;\n\n  if (previousMorph) {\n    if (nextMorph) {\n      previousMorph.nextMorph = nextMorph;\n      nextMorph.previousMorph = previousMorph;\n    } else {\n      previousMorph.nextMorph = null;\n      parentMorphList.lastChildMorph = previousMorph;\n    }\n  } else {\n    if (nextMorph) {\n      nextMorph.previousMorph = null;\n      parentMorphList.firstChildMorph = nextMorph;\n    } else if (parentMorphList) {\n      parentMorphList.lastChildMorph = parentMorphList.firstChildMorph = null;\n    }\n  }\n\n  this.parentMorphList = null;\n  this.nextMorph = null;\n  this.previousMorph = null;\n\n  if (parentMorphList && parentMorphList.mountedMorph) {\n    if (!parentMorphList.firstChildMorph) {\n      // list is empty\n      parentMorphList.mountedMorph.clear();\n      return;\n    } else {\n      parentMorphList.firstChildMorph._syncFirstNode();\n      parentMorphList.lastChildMorph._syncLastNode();\n    }\n  }\n};\n\nMorph.prototype.setHTML = function(text) {\n  var fragment = this.domHelper.parseHTML(text, this.contextualElement);\n  return this.setNode(fragment);\n};\n\nMorph.prototype.setMorphList = function Morph$appendMorphList(morphList) {\n  morphList.mountedMorph = this;\n  this.clear();\n\n  var originalFirstNode = this.firstNode;\n\n  if (morphList.firstChildMorph) {\n    this.firstNode = morphList.firstChildMorph.firstNode;\n    this.lastNode = morphList.lastChildMorph.lastNode;\n\n    var current = morphList.firstChildMorph;\n\n    while (current) {\n      var next = current.nextMorph;\n      current.insertBeforeNode(originalFirstNode, null);\n      current = next;\n    }\n    originalFirstNode.parentNode.removeChild(originalFirstNode);\n  }\n};\n\nMorph.prototype._syncFirstNode = function Morph$syncFirstNode() {\n  var morph = this;\n  var parentMorphList;\n  while (parentMorphList = morph.parentMorphList) {\n    if (parentMorphList.mountedMorph === null) {\n      break;\n    }\n    if (morph !== parentMorphList.firstChildMorph) {\n      break;\n    }\n    if (morph.firstNode === parentMorphList.mountedMorph.firstNode) {\n      break;\n    }\n\n    parentMorphList.mountedMorph.firstNode = morph.firstNode;\n\n    morph = parentMorphList.mountedMorph;\n  }\n};\n\nMorph.prototype._syncLastNode = function Morph$syncLastNode() {\n  var morph = this;\n  var parentMorphList;\n  while (parentMorphList = morph.parentMorphList) {\n    if (parentMorphList.mountedMorph === null) {\n      break;\n    }\n    if (morph !== parentMorphList.lastChildMorph) {\n      break;\n    }\n    if (morph.lastNode === parentMorphList.mountedMorph.lastNode) {\n      break;\n    }\n\n    parentMorphList.mountedMorph.lastNode = morph.lastNode;\n\n    morph = parentMorphList.mountedMorph;\n  }\n};\n\nMorph.prototype.insertBeforeNode = function Morph$insertBeforeNode(parentNode, refNode) {\n  insertBefore(parentNode, this.firstNode, this.lastNode, refNode);\n};\n\nMorph.prototype.appendToNode = function Morph$appendToNode(parentNode) {\n  insertBefore(parentNode, this.firstNode, this.lastNode, null);\n};\n\nexport default Morph;\n","import { clear, insertBefore } from './utils';\n\nfunction MorphList() {\n  // morph graph\n  this.firstChildMorph = null;\n  this.lastChildMorph  = null;\n\n  this.mountedMorph = null;\n}\n\nvar prototype = MorphList.prototype;\n\nprototype.clear = function MorphList$clear() {\n  var current = this.firstChildMorph;\n\n  while (current) {\n    var next = current.nextMorph;\n    current.previousMorph = null;\n    current.nextMorph = null;\n    current.parentMorphList = null;\n    current = next;\n  }\n\n  this.firstChildMorph = this.lastChildMorph = null;\n};\n\nprototype.destroy = function MorphList$destroy() {\n};\n\nprototype.appendMorph = function MorphList$appendMorph(morph) {\n  this.insertBeforeMorph(morph, null);\n};\n\nprototype.insertBeforeMorph = function MorphList$insertBeforeMorph(morph, referenceMorph) {\n  if (morph.parentMorphList !== null) {\n    morph.unlink();\n  }\n  if (referenceMorph && referenceMorph.parentMorphList !== this) {\n    throw new Error('The morph before which the new morph is to be inserted is not a child of this morph.');\n  }\n\n  var mountedMorph = this.mountedMorph;\n\n  if (mountedMorph) {\n\n    var parentNode = mountedMorph.firstNode.parentNode;\n    var referenceNode = referenceMorph ? referenceMorph.firstNode : mountedMorph.lastNode.nextSibling;\n\n    insertBefore(\n      parentNode,\n      morph.firstNode,\n      morph.lastNode,\n      referenceNode\n    );\n\n    // was not in list mode replace current content\n    if (!this.firstChildMorph) {\n      clear(this.mountedMorph.firstNode.parentNode,\n            this.mountedMorph.firstNode,\n            this.mountedMorph.lastNode);\n    }\n  }\n\n  morph.parentMorphList = this;\n\n  var previousMorph = referenceMorph ? referenceMorph.previousMorph : this.lastChildMorph;\n  if (previousMorph) {\n    previousMorph.nextMorph = morph;\n    morph.previousMorph = previousMorph;\n  } else {\n    this.firstChildMorph = morph;\n  }\n\n  if (referenceMorph) {\n    referenceMorph.previousMorph = morph;\n    morph.nextMorph = referenceMorph;\n  } else {\n    this.lastChildMorph = morph;\n  }\n\n  this.firstChildMorph._syncFirstNode();\n  this.lastChildMorph._syncLastNode();\n};\n\nprototype.removeChildMorph = function MorphList$removeChildMorph(morph) {\n  if (morph.parentMorphList !== this) {\n    throw new Error(\"Cannot remove a morph from a parent it is not inside of\");\n  }\n\n  morph.destroy();\n};\n\nexport default MorphList;\n","// inclusive of both nodes\nexport function clear(parentNode, firstNode, lastNode) {\n  if (!parentNode) { return; }\n\n  var node = firstNode;\n  var nextNode;\n  do {\n    nextNode = node.nextSibling;\n    parentNode.removeChild(node);\n    if (node === lastNode) {\n      break;\n    }\n    node = nextNode;\n  } while (node);\n}\n\nexport function insertBefore(parentNode, firstNode, lastNode, refNode) {\n  var node = firstNode;\n  var nextNode;\n  do {\n    nextNode = node.nextSibling;\n    parentNode.insertBefore(node, refNode);\n    if (node === lastNode) {\n      break;\n    }\n    node = nextNode;\n  } while (node);\n}\n","// Load modules\n\nvar Stringify = require('./stringify');\nvar Parse = require('./parse');\n\n\n// Declare internals\n\nvar internals = {};\n\n\nmodule.exports = {\n    stringify: Stringify,\n    parse: Parse\n};\n","// Load modules\n\nvar Utils = require('./utils');\n\n\n// Declare internals\n\nvar internals = {\n    delimiter: '&',\n    depth: 5,\n    arrayLimit: 20,\n    parameterLimit: 1000,\n    strictNullHandling: false,\n    plainObjects: false,\n    allowPrototypes: false,\n    allowDots: false\n};\n\n\ninternals.parseValues = function (str, options) {\n\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0, il = parts.length; i < il; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        if (pos === -1) {\n            obj[Utils.decode(part)] = '';\n\n            if (options.strictNullHandling) {\n                obj[Utils.decode(part)] = null;\n            }\n        }\n        else {\n            var key = Utils.decode(part.slice(0, pos));\n            var val = Utils.decode(part.slice(pos + 1));\n\n            if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n                obj[key] = val;\n            }\n            else {\n                obj[key] = [].concat(obj[key]).concat(val);\n            }\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.parseObject = function (chain, val, options) {\n\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj;\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(internals.parseObject(chain, val, options));\n    }\n    else {\n        obj = options.plainObjects ? Object.create(null) : {};\n        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n        var index = parseInt(cleanRoot, 10);\n        var indexString = '' + index;\n        if (!isNaN(index) &&\n            root !== cleanRoot &&\n            indexString === cleanRoot &&\n            index >= 0 &&\n            (options.parseArrays &&\n             index <= options.arrayLimit)) {\n\n            obj = [];\n            obj[index] = internals.parseObject(chain, val, options);\n        }\n        else {\n            obj[cleanRoot] = internals.parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.parseKeys = function (key, val, options) {\n\n    if (!key) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n\n    if (options.allowDots) {\n        key = key.replace(/\\.([^\\.\\[]+)/g, '[$1]');\n    }\n\n    // The regex chunks\n\n    var parent = /^([^\\[\\]]*)/;\n    var child = /(\\[[^\\[\\]]*\\])/g;\n\n    // Get the parent\n\n    var segment = parent.exec(key);\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (segment[1]) {\n        // If we aren't using plain objects, optionally prefix keys\n        // that would overwrite object prototype properties\n        if (!options.plainObjects &&\n            Object.prototype.hasOwnProperty(segment[1])) {\n\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(segment[1]);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n\n        ++i;\n        if (!options.plainObjects &&\n            Object.prototype.hasOwnProperty(segment[1].replace(/\\[|\\]/g, ''))) {\n\n            if (!options.allowPrototypes) {\n                continue;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return internals.parseObject(keys, val, options);\n};\n\n\nmodule.exports = function (str, options) {\n\n    options = options || {};\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;\n    options.parseArrays = options.parseArrays !== false;\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : internals.allowDots;\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : internals.plainObjects;\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : internals.allowPrototypes;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;\n\n    if (str === '' ||\n        str === null ||\n        typeof str === 'undefined') {\n\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0, il = keys.length; i < il; ++i) {\n        var key = keys[i];\n        var newObj = internals.parseKeys(key, tempObj[key], options);\n        obj = Utils.merge(obj, newObj, options);\n    }\n\n    return Utils.compact(obj);\n};\n","// Load modules\n\nvar Utils = require('./utils');\n\n\n// Declare internals\n\nvar internals = {\n    delimiter: '&',\n    arrayPrefixGenerators: {\n        brackets: function (prefix, key) {\n\n            return prefix + '[]';\n        },\n        indices: function (prefix, key) {\n\n            return prefix + '[' + key + ']';\n        },\n        repeat: function (prefix, key) {\n\n            return prefix;\n        }\n    },\n    strictNullHandling: false\n};\n\n\ninternals.stringify = function (obj, prefix, generateArrayPrefix, strictNullHandling, filter) {\n\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    }\n    else if (Utils.isBuffer(obj)) {\n        obj = obj.toString();\n    }\n    else if (obj instanceof Date) {\n        obj = obj.toISOString();\n    }\n    else if (obj === null) {\n        if (strictNullHandling) {\n            return Utils.encode(prefix);\n        }\n\n        obj = '';\n    }\n\n    if (typeof obj === 'string' ||\n        typeof obj === 'number' ||\n        typeof obj === 'boolean') {\n\n        return [Utils.encode(prefix) + '=' + Utils.encode(obj)];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys = Array.isArray(filter) ? filter : Object.keys(obj);\n    for (var i = 0, il = objKeys.length; i < il; ++i) {\n        var key = objKeys[i];\n\n        if (Array.isArray(obj)) {\n            values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, filter));\n        }\n        else {\n            values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', generateArrayPrefix, strictNullHandling, filter));\n        }\n    }\n\n    return values;\n};\n\n\nmodule.exports = function (obj, options) {\n\n    options = options || {};\n    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;\n    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;\n    var objKeys;\n    var filter;\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    }\n    else if (Array.isArray(options.filter)) {\n        objKeys = filter = options.filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return '';\n    }\n\n    var arrayFormat;\n    if (options.arrayFormat in internals.arrayPrefixGenerators) {\n        arrayFormat = options.arrayFormat;\n    }\n    else if ('indices' in options) {\n        arrayFormat = options.indices ? 'indices' : 'repeat';\n    }\n    else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n    for (var i = 0, il = objKeys.length; i < il; ++i) {\n        var key = objKeys[i];\n        keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix, strictNullHandling, filter));\n    }\n\n    return keys.join(delimiter);\n};\n","// Load modules\n\n\n// Declare internals\n\nvar internals = {};\ninternals.hexTable = new Array(256);\nfor (var h = 0; h < 256; ++h) {\n    internals.hexTable[h] = '%' + ((h < 16 ? '0' : '') + h.toString(16)).toUpperCase();\n}\n\n\nexports.arrayToObject = function (source, options) {\n\n    var obj = options.plainObjects ? Object.create(null) : {};\n    for (var i = 0, il = source.length; i < il; ++i) {\n        if (typeof source[i] !== 'undefined') {\n\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\n\nexports.merge = function (target, source, options) {\n\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (Array.isArray(target)) {\n            target.push(source);\n        }\n        else if (typeof target === 'object') {\n            target[source] = true;\n        }\n        else {\n            target = [target, source];\n        }\n\n        return target;\n    }\n\n    if (typeof target !== 'object') {\n        target = [target].concat(source);\n        return target;\n    }\n\n    if (Array.isArray(target) &&\n        !Array.isArray(source)) {\n\n        target = exports.arrayToObject(target, options);\n    }\n\n    var keys = Object.keys(source);\n    for (var k = 0, kl = keys.length; k < kl; ++k) {\n        var key = keys[k];\n        var value = source[key];\n\n        if (!Object.prototype.hasOwnProperty.call(target, key)) {\n            target[key] = value;\n        }\n        else {\n            target[key] = exports.merge(target[key], value, options);\n        }\n    }\n\n    return target;\n};\n\n\nexports.decode = function (str) {\n\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\nexports.encode = function (str) {\n\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    if (typeof str !== 'string') {\n        str = '' + str;\n    }\n\n    var out = '';\n    for (var i = 0, il = str.length; i < il; ++i) {\n        var c = str.charCodeAt(i);\n\n        if (c === 0x2D || // -\n            c === 0x2E || // .\n            c === 0x5F || // _\n            c === 0x7E || // ~\n            (c >= 0x30 && c <= 0x39) || // 0-9\n            (c >= 0x41 && c <= 0x5A) || // a-z\n            (c >= 0x61 && c <= 0x7A)) { // A-Z\n\n            out += str[i];\n            continue;\n        }\n\n        if (c < 0x80) {\n            out += internals.hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out += internals.hexTable[0xC0 | (c >> 6)] + internals.hexTable[0x80 | (c & 0x3F)];\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out += internals.hexTable[0xE0 | (c >> 12)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];\n            continue;\n        }\n\n        ++i;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (str.charCodeAt(i) & 0x3FF));\n        out += internals.hexTable[0xF0 | (c >> 18)] + internals.hexTable[0x80 | ((c >> 12) & 0x3F)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nexports.compact = function (obj, refs) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    refs = refs || [];\n    var lookup = refs.indexOf(obj);\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs.push(obj);\n\n    if (Array.isArray(obj)) {\n        var compacted = [];\n\n        for (var i = 0, il = obj.length; i < il; ++i) {\n            if (typeof obj[i] !== 'undefined') {\n                compacted.push(obj[i]);\n            }\n        }\n\n        return compacted;\n    }\n\n    var keys = Object.keys(obj);\n    for (i = 0, il = keys.length; i < il; ++i) {\n        var key = keys[i];\n        obj[key] = exports.compact(obj[key], refs);\n    }\n\n    return obj;\n};\n\n\nexports.isRegExp = function (obj) {\n\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\n\nexports.isBuffer = function (obj) {\n\n    if (obj === null ||\n        typeof obj === 'undefined') {\n\n        return false;\n    }\n\n    return !!(obj.constructor &&\n              obj.constructor.isBuffer &&\n              obj.constructor.isBuffer(obj));\n};\n"],"sourceRoot":"/source/"}